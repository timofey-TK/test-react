(function () { const e = document.createElement("link").relList; if (e && e.supports && e.supports("modulepreload")) return; for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i); new MutationObserver(i => { for (const s of i) if (s.type === "childList") for (const l of s.addedNodes) l.tagName === "LINK" && l.rel === "modulepreload" && r(l) }).observe(document, { childList: !0, subtree: !0 }); function n(i) { const s = {}; return i.integrity && (s.integrity = i.integrity), i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? s.credentials = "include" : i.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s } function r(i) { if (i.ep) return; i.ep = !0; const s = n(i); fetch(i.href, s) } })(); var oe = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}; function bc(t) { return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t } var Cc = { exports: {} }, us = {}, Pc = { exports: {} }, W = {};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Br = Symbol.for("react.element"), xp = Symbol.for("react.portal"), Tp = Symbol.for("react.fragment"), bp = Symbol.for("react.strict_mode"), Cp = Symbol.for("react.profiler"), Pp = Symbol.for("react.provider"), kp = Symbol.for("react.context"), Mp = Symbol.for("react.forward_ref"), _p = Symbol.for("react.suspense"), Lp = Symbol.for("react.memo"), zp = Symbol.for("react.lazy"), Bo = Symbol.iterator; function Ip(t) { return t === null || typeof t != "object" ? null : (t = Bo && t[Bo] || t["@@iterator"], typeof t == "function" ? t : null) } var kc = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, Mc = Object.assign, _c = {}; function Wn(t, e, n) { this.props = t, this.context = e, this.refs = _c, this.updater = n || kc } Wn.prototype.isReactComponent = {}; Wn.prototype.setState = function (t, e) { if (typeof t != "object" && typeof t != "function" && t != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, t, e, "setState") }; Wn.prototype.forceUpdate = function (t) { this.updater.enqueueForceUpdate(this, t, "forceUpdate") }; function Lc() { } Lc.prototype = Wn.prototype; function ka(t, e, n) { this.props = t, this.context = e, this.refs = _c, this.updater = n || kc } var Ma = ka.prototype = new Lc; Ma.constructor = ka; Mc(Ma, Wn.prototype); Ma.isPureReactComponent = !0; var Vo = Array.isArray, zc = Object.prototype.hasOwnProperty, _a = { current: null }, Ic = { key: !0, ref: !0, __self: !0, __source: !0 }; function Oc(t, e, n) { var r, i = {}, s = null, l = null; if (e != null) for (r in e.ref !== void 0 && (l = e.ref), e.key !== void 0 && (s = "" + e.key), e) zc.call(e, r) && !Ic.hasOwnProperty(r) && (i[r] = e[r]); var o = arguments.length - 2; if (o === 1) i.children = n; else if (1 < o) { for (var a = Array(o), u = 0; u < o; u++)a[u] = arguments[u + 2]; i.children = a } if (t && t.defaultProps) for (r in o = t.defaultProps, o) i[r] === void 0 && (i[r] = o[r]); return { $$typeof: Br, type: t, key: s, ref: l, props: i, _owner: _a.current } } function Op(t, e) { return { $$typeof: Br, type: t.type, key: e, ref: t.ref, props: t.props, _owner: t._owner } } function La(t) { return typeof t == "object" && t !== null && t.$$typeof === Br } function Np(t) { var e = { "=": "=0", ":": "=2" }; return "$" + t.replace(/[=:]/g, function (n) { return e[n] }) } var Go = /\/+/g; function $s(t, e) { return typeof t == "object" && t !== null && t.key != null ? Np("" + t.key) : e.toString(36) } function yi(t, e, n, r, i) { var s = typeof t; (s === "undefined" || s === "boolean") && (t = null); var l = !1; if (t === null) l = !0; else switch (s) { case "string": case "number": l = !0; break; case "object": switch (t.$$typeof) { case Br: case xp: l = !0 } }if (l) return l = t, i = i(l), t = r === "" ? "." + $s(l, 0) : r, Vo(i) ? (n = "", t != null && (n = t.replace(Go, "$&/") + "/"), yi(i, e, n, "", function (u) { return u })) : i != null && (La(i) && (i = Op(i, n + (!i.key || l && l.key === i.key ? "" : ("" + i.key).replace(Go, "$&/") + "/") + t)), e.push(i)), 1; if (l = 0, r = r === "" ? "." : r + ":", Vo(t)) for (var o = 0; o < t.length; o++) { s = t[o]; var a = r + $s(s, o); l += yi(s, e, n, a, i) } else if (a = Ip(t), typeof a == "function") for (t = a.call(t), o = 0; !(s = t.next()).done;)s = s.value, a = r + $s(s, o++), l += yi(s, e, n, a, i); else if (s === "object") throw e = String(t), Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead."); return l } function Kr(t, e, n) { if (t == null) return t; var r = [], i = 0; return yi(t, r, "", "", function (s) { return e.call(n, s, i++) }), r } function Ap(t) { if (t._status === -1) { var e = t._result; e = e(), e.then(function (n) { (t._status === 0 || t._status === -1) && (t._status = 1, t._result = n) }, function (n) { (t._status === 0 || t._status === -1) && (t._status = 2, t._result = n) }), t._status === -1 && (t._status = 0, t._result = e) } if (t._status === 1) return t._result.default; throw t._result } var Me = { current: null }, Si = { transition: null }, Dp = { ReactCurrentDispatcher: Me, ReactCurrentBatchConfig: Si, ReactCurrentOwner: _a }; W.Children = { map: Kr, forEach: function (t, e, n) { Kr(t, function () { e.apply(this, arguments) }, n) }, count: function (t) { var e = 0; return Kr(t, function () { e++ }), e }, toArray: function (t) { return Kr(t, function (e) { return e }) || [] }, only: function (t) { if (!La(t)) throw Error("React.Children.only expected to receive a single React element child."); return t } }; W.Component = Wn; W.Fragment = Tp; W.Profiler = Cp; W.PureComponent = ka; W.StrictMode = bp; W.Suspense = _p; W.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Dp; W.cloneElement = function (t, e, n) { if (t == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + t + "."); var r = Mc({}, t.props), i = t.key, s = t.ref, l = t._owner; if (e != null) { if (e.ref !== void 0 && (s = e.ref, l = _a.current), e.key !== void 0 && (i = "" + e.key), t.type && t.type.defaultProps) var o = t.type.defaultProps; for (a in e) zc.call(e, a) && !Ic.hasOwnProperty(a) && (r[a] = e[a] === void 0 && o !== void 0 ? o[a] : e[a]) } var a = arguments.length - 2; if (a === 1) r.children = n; else if (1 < a) { o = Array(a); for (var u = 0; u < a; u++)o[u] = arguments[u + 2]; r.children = o } return { $$typeof: Br, type: t.type, key: i, ref: s, props: r, _owner: l } }; W.createContext = function (t) { return t = { $$typeof: kp, _currentValue: t, _currentValue2: t, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, t.Provider = { $$typeof: Pp, _context: t }, t.Consumer = t }; W.createElement = Oc; W.createFactory = function (t) { var e = Oc.bind(null, t); return e.type = t, e }; W.createRef = function () { return { current: null } }; W.forwardRef = function (t) { return { $$typeof: Mp, render: t } }; W.isValidElement = La; W.lazy = function (t) { return { $$typeof: zp, _payload: { _status: -1, _result: t }, _init: Ap } }; W.memo = function (t, e) { return { $$typeof: Lp, type: t, compare: e === void 0 ? null : e } }; W.startTransition = function (t) { var e = Si.transition; Si.transition = {}; try { t() } finally { Si.transition = e } }; W.unstable_act = function () { throw Error("act(...) is not supported in production builds of React.") }; W.useCallback = function (t, e) { return Me.current.useCallback(t, e) }; W.useContext = function (t) { return Me.current.useContext(t) }; W.useDebugValue = function () { }; W.useDeferredValue = function (t) { return Me.current.useDeferredValue(t) }; W.useEffect = function (t, e) { return Me.current.useEffect(t, e) }; W.useId = function () { return Me.current.useId() }; W.useImperativeHandle = function (t, e, n) { return Me.current.useImperativeHandle(t, e, n) }; W.useInsertionEffect = function (t, e) { return Me.current.useInsertionEffect(t, e) }; W.useLayoutEffect = function (t, e) { return Me.current.useLayoutEffect(t, e) }; W.useMemo = function (t, e) { return Me.current.useMemo(t, e) }; W.useReducer = function (t, e, n) { return Me.current.useReducer(t, e, n) }; W.useRef = function (t) { return Me.current.useRef(t) }; W.useState = function (t) { return Me.current.useState(t) }; W.useSyncExternalStore = function (t, e, n) { return Me.current.useSyncExternalStore(t, e, n) }; W.useTransition = function () { return Me.current.useTransition() }; W.version = "18.2.0"; Pc.exports = W; var Y = Pc.exports; const Nc = bc(Y);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Rp = Y, $p = Symbol.for("react.element"), jp = Symbol.for("react.fragment"), Fp = Object.prototype.hasOwnProperty, Hp = Rp.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, Bp = { key: !0, ref: !0, __self: !0, __source: !0 }; function Ac(t, e, n) { var r, i = {}, s = null, l = null; n !== void 0 && (s = "" + n), e.key !== void 0 && (s = "" + e.key), e.ref !== void 0 && (l = e.ref); for (r in e) Fp.call(e, r) && !Bp.hasOwnProperty(r) && (i[r] = e[r]); if (t && t.defaultProps) for (r in e = t.defaultProps, e) i[r] === void 0 && (i[r] = e[r]); return { $$typeof: $p, type: t, key: s, ref: l, props: i, _owner: Hp.current } } us.Fragment = jp; us.jsx = Ac; us.jsxs = Ac; Cc.exports = us; var A = Cc.exports, El = {}, Dc = { exports: {} }, Ge = {}, Rc = { exports: {} }, $c = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function (t) { function e(E, k) { var z = E.length; E.push(k); e: for (; 0 < z;) { var F = z - 1 >>> 1, B = E[F]; if (0 < i(B, k)) E[F] = k, E[z] = B, z = F; else break e } } function n(E) { return E.length === 0 ? null : E[0] } function r(E) { if (E.length === 0) return null; var k = E[0], z = E.pop(); if (z !== k) { E[0] = z; e: for (var F = 0, B = E.length, ue = B >>> 1; F < ue;) { var fe = 2 * (F + 1) - 1, H = E[fe], X = fe + 1, re = E[X]; if (0 > i(H, z)) X < B && 0 > i(re, H) ? (E[F] = re, E[X] = z, F = X) : (E[F] = H, E[fe] = z, F = fe); else if (X < B && 0 > i(re, z)) E[F] = re, E[X] = z, F = X; else break e } } return k } function i(E, k) { var z = E.sortIndex - k.sortIndex; return z !== 0 ? z : E.id - k.id } if (typeof performance == "object" && typeof performance.now == "function") { var s = performance; t.unstable_now = function () { return s.now() } } else { var l = Date, o = l.now(); t.unstable_now = function () { return l.now() - o } } var a = [], u = [], c = 1, d = null, f = 3, v = !1, g = !1, w = !1, y = typeof setTimeout == "function" ? setTimeout : null, p = typeof clearTimeout == "function" ? clearTimeout : null, m = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function h(E) { for (var k = n(u); k !== null;) { if (k.callback === null) r(u); else if (k.startTime <= E) r(u), k.sortIndex = k.expirationTime, e(a, k); else break; k = n(u) } } function S(E) { if (w = !1, h(E), !g) if (n(a) !== null) g = !0, j(x); else { var k = n(u); k !== null && I(S, k.startTime - E) } } function x(E, k) { g = !1, w && (w = !1, p(b), b = -1), v = !0; var z = f; try { for (h(k), d = n(a); d !== null && (!(d.expirationTime > k) || E && !N());) { var F = d.callback; if (typeof F == "function") { d.callback = null, f = d.priorityLevel; var B = F(d.expirationTime <= k); k = t.unstable_now(), typeof B == "function" ? d.callback = B : d === n(a) && r(a), h(k) } else r(a); d = n(a) } if (d !== null) var ue = !0; else { var fe = n(u); fe !== null && I(S, fe.startTime - k), ue = !1 } return ue } finally { d = null, f = z, v = !1 } } var T = !1, L = null, b = -1, C = 5, P = -1; function N() { return !(t.unstable_now() - P < C) } function M() { if (L !== null) { var E = t.unstable_now(); P = E; var k = !0; try { k = L(!0, E) } finally { k ? _() : (T = !1, L = null) } } else T = !1 } var _; if (typeof m == "function") _ = function () { m(M) }; else if (typeof MessageChannel < "u") { var O = new MessageChannel, R = O.port2; O.port1.onmessage = M, _ = function () { R.postMessage(null) } } else _ = function () { y(M, 0) }; function j(E) { L = E, T || (T = !0, _()) } function I(E, k) { b = y(function () { E(t.unstable_now()) }, k) } t.unstable_IdlePriority = 5, t.unstable_ImmediatePriority = 1, t.unstable_LowPriority = 4, t.unstable_NormalPriority = 3, t.unstable_Profiling = null, t.unstable_UserBlockingPriority = 2, t.unstable_cancelCallback = function (E) { E.callback = null }, t.unstable_continueExecution = function () { g || v || (g = !0, j(x)) }, t.unstable_forceFrameRate = function (E) { 0 > E || 125 < E ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : C = 0 < E ? Math.floor(1e3 / E) : 5 }, t.unstable_getCurrentPriorityLevel = function () { return f }, t.unstable_getFirstCallbackNode = function () { return n(a) }, t.unstable_next = function (E) { switch (f) { case 1: case 2: case 3: var k = 3; break; default: k = f }var z = f; f = k; try { return E() } finally { f = z } }, t.unstable_pauseExecution = function () { }, t.unstable_requestPaint = function () { }, t.unstable_runWithPriority = function (E, k) { switch (E) { case 1: case 2: case 3: case 4: case 5: break; default: E = 3 }var z = f; f = E; try { return k() } finally { f = z } }, t.unstable_scheduleCallback = function (E, k, z) { var F = t.unstable_now(); switch (typeof z == "object" && z !== null ? (z = z.delay, z = typeof z == "number" && 0 < z ? F + z : F) : z = F, E) { case 1: var B = -1; break; case 2: B = 250; break; case 5: B = 1073741823; break; case 4: B = 1e4; break; default: B = 5e3 }return B = z + B, E = { id: c++, callback: k, priorityLevel: E, startTime: z, expirationTime: B, sortIndex: -1 }, z > F ? (E.sortIndex = z, e(u, E), n(a) === null && E === n(u) && (w ? (p(b), b = -1) : w = !0, I(S, z - F))) : (E.sortIndex = B, e(a, E), g || v || (g = !0, j(x))), E }, t.unstable_shouldYield = N, t.unstable_wrapCallback = function (E) { var k = f; return function () { var z = f; f = k; try { return E.apply(this, arguments) } finally { f = z } } } })($c); Rc.exports = $c; var Vp = Rc.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var jc = Y, Ve = Vp; function D(t) { for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, n = 1; n < arguments.length; n++)e += "&args[]=" + encodeURIComponent(arguments[n]); return "Minified React error #" + t + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var Fc = new Set, br = {}; function dn(t, e) { An(t, e), An(t + "Capture", e) } function An(t, e) { for (br[t] = e, t = 0; t < e.length; t++)Fc.add(e[t]) } var wt = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), xl = Object.prototype.hasOwnProperty, Gp = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, Wo = {}, Xo = {}; function Wp(t) { return xl.call(Xo, t) ? !0 : xl.call(Wo, t) ? !1 : Gp.test(t) ? Xo[t] = !0 : (Wo[t] = !0, !1) } function Xp(t, e, n, r) { if (n !== null && n.type === 0) return !1; switch (typeof e) { case "function": case "symbol": return !0; case "boolean": return r ? !1 : n !== null ? !n.acceptsBooleans : (t = t.toLowerCase().slice(0, 5), t !== "data-" && t !== "aria-"); default: return !1 } } function Up(t, e, n, r) { if (e === null || typeof e > "u" || Xp(t, e, n, r)) return !0; if (r) return !1; if (n !== null) switch (n.type) { case 3: return !e; case 4: return e === !1; case 5: return isNaN(e); case 6: return isNaN(e) || 1 > e }return !1 } function _e(t, e, n, r, i, s, l) { this.acceptsBooleans = e === 2 || e === 3 || e === 4, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = n, this.propertyName = t, this.type = e, this.sanitizeURL = s, this.removeEmptyString = l } var ye = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (t) { ye[t] = new _e(t, 0, !1, t, null, !1, !1) });[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (t) { var e = t[0]; ye[e] = new _e(e, 1, !1, t[1], null, !1, !1) });["contentEditable", "draggable", "spellCheck", "value"].forEach(function (t) { ye[t] = new _e(t, 2, !1, t.toLowerCase(), null, !1, !1) });["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (t) { ye[t] = new _e(t, 2, !1, t, null, !1, !1) }); "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (t) { ye[t] = new _e(t, 3, !1, t.toLowerCase(), null, !1, !1) });["checked", "multiple", "muted", "selected"].forEach(function (t) { ye[t] = new _e(t, 3, !0, t, null, !1, !1) });["capture", "download"].forEach(function (t) { ye[t] = new _e(t, 4, !1, t, null, !1, !1) });["cols", "rows", "size", "span"].forEach(function (t) { ye[t] = new _e(t, 6, !1, t, null, !1, !1) });["rowSpan", "start"].forEach(function (t) { ye[t] = new _e(t, 5, !1, t.toLowerCase(), null, !1, !1) }); var za = /[\-:]([a-z])/g; function Ia(t) { return t[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (t) { var e = t.replace(za, Ia); ye[e] = new _e(e, 1, !1, t, null, !1, !1) }); "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (t) { var e = t.replace(za, Ia); ye[e] = new _e(e, 1, !1, t, "http://www.w3.org/1999/xlink", !1, !1) });["xml:base", "xml:lang", "xml:space"].forEach(function (t) { var e = t.replace(za, Ia); ye[e] = new _e(e, 1, !1, t, "http://www.w3.org/XML/1998/namespace", !1, !1) });["tabIndex", "crossOrigin"].forEach(function (t) { ye[t] = new _e(t, 1, !1, t.toLowerCase(), null, !1, !1) }); ye.xlinkHref = new _e("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);["src", "href", "action", "formAction"].forEach(function (t) { ye[t] = new _e(t, 1, !1, t.toLowerCase(), null, !0, !0) }); function Oa(t, e, n, r) { var i = ye.hasOwnProperty(e) ? ye[e] : null; (i !== null ? i.type !== 0 : r || !(2 < e.length) || e[0] !== "o" && e[0] !== "O" || e[1] !== "n" && e[1] !== "N") && (Up(e, n, i, r) && (n = null), r || i === null ? Wp(e) && (n === null ? t.removeAttribute(e) : t.setAttribute(e, "" + n)) : i.mustUseProperty ? t[i.propertyName] = n === null ? i.type === 3 ? !1 : "" : n : (e = i.attributeName, r = i.attributeNamespace, n === null ? t.removeAttribute(e) : (i = i.type, n = i === 3 || i === 4 && n === !0 ? "" : "" + n, r ? t.setAttributeNS(r, e, n) : t.setAttribute(e, n)))) } var xt = jc.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, Zr = Symbol.for("react.element"), vn = Symbol.for("react.portal"), wn = Symbol.for("react.fragment"), Na = Symbol.for("react.strict_mode"), Tl = Symbol.for("react.profiler"), Hc = Symbol.for("react.provider"), Bc = Symbol.for("react.context"), Aa = Symbol.for("react.forward_ref"), bl = Symbol.for("react.suspense"), Cl = Symbol.for("react.suspense_list"), Da = Symbol.for("react.memo"), Ct = Symbol.for("react.lazy"), Vc = Symbol.for("react.offscreen"), Uo = Symbol.iterator; function Kn(t) { return t === null || typeof t != "object" ? null : (t = Uo && t[Uo] || t["@@iterator"], typeof t == "function" ? t : null) } var ne = Object.assign, js; function sr(t) {
  if (js === void 0) try { throw Error() } catch (n) { var e = n.stack.trim().match(/\n( *(at )?)/); js = e && e[1] || "" } return `
`+ js + t
} var Fs = !1; function Hs(t, e) {
  if (!t || Fs) return ""; Fs = !0; var n = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (e) if (e = function () { throw Error() }, Object.defineProperty(e.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(e, []) } catch (u) { var r = u } Reflect.construct(t, [], e) } else { try { e.call() } catch (u) { r = u } t.call(e.prototype) } else { try { throw Error() } catch (u) { r = u } t() } } catch (u) {
    if (u && r && typeof u.stack == "string") {
      for (var i = u.stack.split(`
`), s = r.stack.split(`
`), l = i.length - 1, o = s.length - 1; 1 <= l && 0 <= o && i[l] !== s[o];)o--; for (; 1 <= l && 0 <= o; l--, o--)if (i[l] !== s[o]) {
        if (l !== 1 || o !== 1) do if (l--, o--, 0 > o || i[l] !== s[o]) {
          var a = `
`+ i[l].replace(" at new ", " at "); return t.displayName && a.includes("<anonymous>") && (a = a.replace("<anonymous>", t.displayName)), a
        } while (1 <= l && 0 <= o); break
      }
    }
  } finally { Fs = !1, Error.prepareStackTrace = n } return (t = t ? t.displayName || t.name : "") ? sr(t) : ""
} function Yp(t) { switch (t.tag) { case 5: return sr(t.type); case 16: return sr("Lazy"); case 13: return sr("Suspense"); case 19: return sr("SuspenseList"); case 0: case 2: case 15: return t = Hs(t.type, !1), t; case 11: return t = Hs(t.type.render, !1), t; case 1: return t = Hs(t.type, !0), t; default: return "" } } function Pl(t) { if (t == null) return null; if (typeof t == "function") return t.displayName || t.name || null; if (typeof t == "string") return t; switch (t) { case wn: return "Fragment"; case vn: return "Portal"; case Tl: return "Profiler"; case Na: return "StrictMode"; case bl: return "Suspense"; case Cl: return "SuspenseList" }if (typeof t == "object") switch (t.$$typeof) { case Bc: return (t.displayName || "Context") + ".Consumer"; case Hc: return (t._context.displayName || "Context") + ".Provider"; case Aa: var e = t.render; return t = t.displayName, t || (t = e.displayName || e.name || "", t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"), t; case Da: return e = t.displayName || null, e !== null ? e : Pl(t.type) || "Memo"; case Ct: e = t._payload, t = t._init; try { return Pl(t(e)) } catch { } }return null } function qp(t) { var e = t.type; switch (t.tag) { case 24: return "Cache"; case 9: return (e.displayName || "Context") + ".Consumer"; case 10: return (e._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return t = e.render, t = t.displayName || t.name || "", e.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return e; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return Pl(e); case 8: return e === Na ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof e == "function") return e.displayName || e.name || null; if (typeof e == "string") return e }return null } function Ft(t) { switch (typeof t) { case "boolean": case "number": case "string": case "undefined": return t; case "object": return t; default: return "" } } function Gc(t) { var e = t.type; return (t = t.nodeName) && t.toLowerCase() === "input" && (e === "checkbox" || e === "radio") } function Qp(t) { var e = Gc(t) ? "checked" : "value", n = Object.getOwnPropertyDescriptor(t.constructor.prototype, e), r = "" + t[e]; if (!t.hasOwnProperty(e) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") { var i = n.get, s = n.set; return Object.defineProperty(t, e, { configurable: !0, get: function () { return i.call(this) }, set: function (l) { r = "" + l, s.call(this, l) } }), Object.defineProperty(t, e, { enumerable: n.enumerable }), { getValue: function () { return r }, setValue: function (l) { r = "" + l }, stopTracking: function () { t._valueTracker = null, delete t[e] } } } } function Jr(t) { t._valueTracker || (t._valueTracker = Qp(t)) } function Wc(t) { if (!t) return !1; var e = t._valueTracker; if (!e) return !0; var n = e.getValue(), r = ""; return t && (r = Gc(t) ? t.checked ? "true" : "false" : t.value), t = r, t !== n ? (e.setValue(t), !0) : !1 } function Oi(t) { if (t = t || (typeof document < "u" ? document : void 0), typeof t > "u") return null; try { return t.activeElement || t.body } catch { return t.body } } function kl(t, e) { var n = e.checked; return ne({}, e, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: n ?? t._wrapperState.initialChecked }) } function Yo(t, e) { var n = e.defaultValue == null ? "" : e.defaultValue, r = e.checked != null ? e.checked : e.defaultChecked; n = Ft(e.value != null ? e.value : n), t._wrapperState = { initialChecked: r, initialValue: n, controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null } } function Xc(t, e) { e = e.checked, e != null && Oa(t, "checked", e, !1) } function Ml(t, e) { Xc(t, e); var n = Ft(e.value), r = e.type; if (n != null) r === "number" ? (n === 0 && t.value === "" || t.value != n) && (t.value = "" + n) : t.value !== "" + n && (t.value = "" + n); else if (r === "submit" || r === "reset") { t.removeAttribute("value"); return } e.hasOwnProperty("value") ? _l(t, e.type, n) : e.hasOwnProperty("defaultValue") && _l(t, e.type, Ft(e.defaultValue)), e.checked == null && e.defaultChecked != null && (t.defaultChecked = !!e.defaultChecked) } function qo(t, e, n) { if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) { var r = e.type; if (!(r !== "submit" && r !== "reset" || e.value !== void 0 && e.value !== null)) return; e = "" + t._wrapperState.initialValue, n || e === t.value || (t.value = e), t.defaultValue = e } n = t.name, n !== "" && (t.name = ""), t.defaultChecked = !!t._wrapperState.initialChecked, n !== "" && (t.name = n) } function _l(t, e, n) { (e !== "number" || Oi(t.ownerDocument) !== t) && (n == null ? t.defaultValue = "" + t._wrapperState.initialValue : t.defaultValue !== "" + n && (t.defaultValue = "" + n)) } var lr = Array.isArray; function _n(t, e, n, r) { if (t = t.options, e) { e = {}; for (var i = 0; i < n.length; i++)e["$" + n[i]] = !0; for (n = 0; n < t.length; n++)i = e.hasOwnProperty("$" + t[n].value), t[n].selected !== i && (t[n].selected = i), i && r && (t[n].defaultSelected = !0) } else { for (n = "" + Ft(n), e = null, i = 0; i < t.length; i++) { if (t[i].value === n) { t[i].selected = !0, r && (t[i].defaultSelected = !0); return } e !== null || t[i].disabled || (e = t[i]) } e !== null && (e.selected = !0) } } function Ll(t, e) { if (e.dangerouslySetInnerHTML != null) throw Error(D(91)); return ne({}, e, { value: void 0, defaultValue: void 0, children: "" + t._wrapperState.initialValue }) } function Qo(t, e) { var n = e.value; if (n == null) { if (n = e.children, e = e.defaultValue, n != null) { if (e != null) throw Error(D(92)); if (lr(n)) { if (1 < n.length) throw Error(D(93)); n = n[0] } e = n } e == null && (e = ""), n = e } t._wrapperState = { initialValue: Ft(n) } } function Uc(t, e) { var n = Ft(e.value), r = Ft(e.defaultValue); n != null && (n = "" + n, n !== t.value && (t.value = n), e.defaultValue == null && t.defaultValue !== n && (t.defaultValue = n)), r != null && (t.defaultValue = "" + r) } function Ko(t) { var e = t.textContent; e === t._wrapperState.initialValue && e !== "" && e !== null && (t.value = e) } function Yc(t) { switch (t) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function zl(t, e) { return t == null || t === "http://www.w3.org/1999/xhtml" ? Yc(e) : t === "http://www.w3.org/2000/svg" && e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : t } var ei, qc = function (t) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (e, n, r, i) { MSApp.execUnsafeLocalFunction(function () { return t(e, n, r, i) }) } : t }(function (t, e) { if (t.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in t) t.innerHTML = e; else { for (ei = ei || document.createElement("div"), ei.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>", e = ei.firstChild; t.firstChild;)t.removeChild(t.firstChild); for (; e.firstChild;)t.appendChild(e.firstChild) } }); function Cr(t, e) { if (e) { var n = t.firstChild; if (n && n === t.lastChild && n.nodeType === 3) { n.nodeValue = e; return } } t.textContent = e } var fr = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, Kp = ["Webkit", "ms", "Moz", "O"]; Object.keys(fr).forEach(function (t) { Kp.forEach(function (e) { e = e + t.charAt(0).toUpperCase() + t.substring(1), fr[e] = fr[t] }) }); function Qc(t, e, n) { return e == null || typeof e == "boolean" || e === "" ? "" : n || typeof e != "number" || e === 0 || fr.hasOwnProperty(t) && fr[t] ? ("" + e).trim() : e + "px" } function Kc(t, e) { t = t.style; for (var n in e) if (e.hasOwnProperty(n)) { var r = n.indexOf("--") === 0, i = Qc(n, e[n], r); n === "float" && (n = "cssFloat"), r ? t.setProperty(n, i) : t[n] = i } } var Zp = ne({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function Il(t, e) { if (e) { if (Zp[t] && (e.children != null || e.dangerouslySetInnerHTML != null)) throw Error(D(137, t)); if (e.dangerouslySetInnerHTML != null) { if (e.children != null) throw Error(D(60)); if (typeof e.dangerouslySetInnerHTML != "object" || !("__html" in e.dangerouslySetInnerHTML)) throw Error(D(61)) } if (e.style != null && typeof e.style != "object") throw Error(D(62)) } } function Ol(t, e) { if (t.indexOf("-") === -1) return typeof e.is == "string"; switch (t) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var Nl = null; function Ra(t) { return t = t.target || t.srcElement || window, t.correspondingUseElement && (t = t.correspondingUseElement), t.nodeType === 3 ? t.parentNode : t } var Al = null, Ln = null, zn = null; function Zo(t) { if (t = Wr(t)) { if (typeof Al != "function") throw Error(D(280)); var e = t.stateNode; e && (e = ms(e), Al(t.stateNode, t.type, e)) } } function Zc(t) { Ln ? zn ? zn.push(t) : zn = [t] : Ln = t } function Jc() { if (Ln) { var t = Ln, e = zn; if (zn = Ln = null, Zo(t), e) for (t = 0; t < e.length; t++)Zo(e[t]) } } function ed(t, e) { return t(e) } function td() { } var Bs = !1; function nd(t, e, n) { if (Bs) return t(e, n); Bs = !0; try { return ed(t, e, n) } finally { Bs = !1, (Ln !== null || zn !== null) && (td(), Jc()) } } function Pr(t, e) { var n = t.stateNode; if (n === null) return null; var r = ms(n); if (r === null) return null; n = r[e]; e: switch (e) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (r = !r.disabled) || (t = t.type, r = !(t === "button" || t === "input" || t === "select" || t === "textarea")), t = !r; break e; default: t = !1 }if (t) return null; if (n && typeof n != "function") throw Error(D(231, e, typeof n)); return n } var Dl = !1; if (wt) try { var Zn = {}; Object.defineProperty(Zn, "passive", { get: function () { Dl = !0 } }), window.addEventListener("test", Zn, Zn), window.removeEventListener("test", Zn, Zn) } catch { Dl = !1 } function Jp(t, e, n, r, i, s, l, o, a) { var u = Array.prototype.slice.call(arguments, 3); try { e.apply(n, u) } catch (c) { this.onError(c) } } var pr = !1, Ni = null, Ai = !1, Rl = null, em = { onError: function (t) { pr = !0, Ni = t } }; function tm(t, e, n, r, i, s, l, o, a) { pr = !1, Ni = null, Jp.apply(em, arguments) } function nm(t, e, n, r, i, s, l, o, a) { if (tm.apply(this, arguments), pr) { if (pr) { var u = Ni; pr = !1, Ni = null } else throw Error(D(198)); Ai || (Ai = !0, Rl = u) } } function fn(t) { var e = t, n = t; if (t.alternate) for (; e.return;)e = e.return; else { t = e; do e = t, e.flags & 4098 && (n = e.return), t = e.return; while (t) } return e.tag === 3 ? n : null } function rd(t) { if (t.tag === 13) { var e = t.memoizedState; if (e === null && (t = t.alternate, t !== null && (e = t.memoizedState)), e !== null) return e.dehydrated } return null } function Jo(t) { if (fn(t) !== t) throw Error(D(188)) } function rm(t) { var e = t.alternate; if (!e) { if (e = fn(t), e === null) throw Error(D(188)); return e !== t ? null : t } for (var n = t, r = e; ;) { var i = n.return; if (i === null) break; var s = i.alternate; if (s === null) { if (r = i.return, r !== null) { n = r; continue } break } if (i.child === s.child) { for (s = i.child; s;) { if (s === n) return Jo(i), t; if (s === r) return Jo(i), e; s = s.sibling } throw Error(D(188)) } if (n.return !== r.return) n = i, r = s; else { for (var l = !1, o = i.child; o;) { if (o === n) { l = !0, n = i, r = s; break } if (o === r) { l = !0, r = i, n = s; break } o = o.sibling } if (!l) { for (o = s.child; o;) { if (o === n) { l = !0, n = s, r = i; break } if (o === r) { l = !0, r = s, n = i; break } o = o.sibling } if (!l) throw Error(D(189)) } } if (n.alternate !== r) throw Error(D(190)) } if (n.tag !== 3) throw Error(D(188)); return n.stateNode.current === n ? t : e } function id(t) { return t = rm(t), t !== null ? sd(t) : null } function sd(t) { if (t.tag === 5 || t.tag === 6) return t; for (t = t.child; t !== null;) { var e = sd(t); if (e !== null) return e; t = t.sibling } return null } var ld = Ve.unstable_scheduleCallback, eu = Ve.unstable_cancelCallback, im = Ve.unstable_shouldYield, sm = Ve.unstable_requestPaint, le = Ve.unstable_now, lm = Ve.unstable_getCurrentPriorityLevel, $a = Ve.unstable_ImmediatePriority, ad = Ve.unstable_UserBlockingPriority, Di = Ve.unstable_NormalPriority, am = Ve.unstable_LowPriority, od = Ve.unstable_IdlePriority, cs = null, ct = null; function om(t) { if (ct && typeof ct.onCommitFiberRoot == "function") try { ct.onCommitFiberRoot(cs, t, void 0, (t.current.flags & 128) === 128) } catch { } } var rt = Math.clz32 ? Math.clz32 : dm, um = Math.log, cm = Math.LN2; function dm(t) { return t >>>= 0, t === 0 ? 32 : 31 - (um(t) / cm | 0) | 0 } var ti = 64, ni = 4194304; function ar(t) { switch (t & -t) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return t & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return t & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return t } } function Ri(t, e) { var n = t.pendingLanes; if (n === 0) return 0; var r = 0, i = t.suspendedLanes, s = t.pingedLanes, l = n & 268435455; if (l !== 0) { var o = l & ~i; o !== 0 ? r = ar(o) : (s &= l, s !== 0 && (r = ar(s))) } else l = n & ~i, l !== 0 ? r = ar(l) : s !== 0 && (r = ar(s)); if (r === 0) return 0; if (e !== 0 && e !== r && !(e & i) && (i = r & -r, s = e & -e, i >= s || i === 16 && (s & 4194240) !== 0)) return e; if (r & 4 && (r |= n & 16), e = t.entangledLanes, e !== 0) for (t = t.entanglements, e &= r; 0 < e;)n = 31 - rt(e), i = 1 << n, r |= t[n], e &= ~i; return r } function fm(t, e) { switch (t) { case 1: case 2: case 4: return e + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return e + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function pm(t, e) { for (var n = t.suspendedLanes, r = t.pingedLanes, i = t.expirationTimes, s = t.pendingLanes; 0 < s;) { var l = 31 - rt(s), o = 1 << l, a = i[l]; a === -1 ? (!(o & n) || o & r) && (i[l] = fm(o, e)) : a <= e && (t.expiredLanes |= o), s &= ~o } } function $l(t) { return t = t.pendingLanes & -1073741825, t !== 0 ? t : t & 1073741824 ? 1073741824 : 0 } function ud() { var t = ti; return ti <<= 1, !(ti & 4194240) && (ti = 64), t } function Vs(t) { for (var e = [], n = 0; 31 > n; n++)e.push(t); return e } function Vr(t, e, n) { t.pendingLanes |= e, e !== 536870912 && (t.suspendedLanes = 0, t.pingedLanes = 0), t = t.eventTimes, e = 31 - rt(e), t[e] = n } function mm(t, e) { var n = t.pendingLanes & ~e; t.pendingLanes = e, t.suspendedLanes = 0, t.pingedLanes = 0, t.expiredLanes &= e, t.mutableReadLanes &= e, t.entangledLanes &= e, e = t.entanglements; var r = t.eventTimes; for (t = t.expirationTimes; 0 < n;) { var i = 31 - rt(n), s = 1 << i; e[i] = 0, r[i] = -1, t[i] = -1, n &= ~s } } function ja(t, e) { var n = t.entangledLanes |= e; for (t = t.entanglements; n;) { var r = 31 - rt(n), i = 1 << r; i & e | t[r] & e && (t[r] |= e), n &= ~i } } var q = 0; function cd(t) { return t &= -t, 1 < t ? 4 < t ? t & 268435455 ? 16 : 536870912 : 4 : 1 } var dd, Fa, fd, pd, md, jl = !1, ri = [], It = null, Ot = null, Nt = null, kr = new Map, Mr = new Map, kt = [], hm = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function tu(t, e) { switch (t) { case "focusin": case "focusout": It = null; break; case "dragenter": case "dragleave": Ot = null; break; case "mouseover": case "mouseout": Nt = null; break; case "pointerover": case "pointerout": kr.delete(e.pointerId); break; case "gotpointercapture": case "lostpointercapture": Mr.delete(e.pointerId) } } function Jn(t, e, n, r, i, s) { return t === null || t.nativeEvent !== s ? (t = { blockedOn: e, domEventName: n, eventSystemFlags: r, nativeEvent: s, targetContainers: [i] }, e !== null && (e = Wr(e), e !== null && Fa(e)), t) : (t.eventSystemFlags |= r, e = t.targetContainers, i !== null && e.indexOf(i) === -1 && e.push(i), t) } function gm(t, e, n, r, i) { switch (e) { case "focusin": return It = Jn(It, t, e, n, r, i), !0; case "dragenter": return Ot = Jn(Ot, t, e, n, r, i), !0; case "mouseover": return Nt = Jn(Nt, t, e, n, r, i), !0; case "pointerover": var s = i.pointerId; return kr.set(s, Jn(kr.get(s) || null, t, e, n, r, i)), !0; case "gotpointercapture": return s = i.pointerId, Mr.set(s, Jn(Mr.get(s) || null, t, e, n, r, i)), !0 }return !1 } function hd(t) { var e = Zt(t.target); if (e !== null) { var n = fn(e); if (n !== null) { if (e = n.tag, e === 13) { if (e = rd(n), e !== null) { t.blockedOn = e, md(t.priority, function () { fd(n) }); return } } else if (e === 3 && n.stateNode.current.memoizedState.isDehydrated) { t.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null; return } } } t.blockedOn = null } function Ei(t) { if (t.blockedOn !== null) return !1; for (var e = t.targetContainers; 0 < e.length;) { var n = Fl(t.domEventName, t.eventSystemFlags, e[0], t.nativeEvent); if (n === null) { n = t.nativeEvent; var r = new n.constructor(n.type, n); Nl = r, n.target.dispatchEvent(r), Nl = null } else return e = Wr(n), e !== null && Fa(e), t.blockedOn = n, !1; e.shift() } return !0 } function nu(t, e, n) { Ei(t) && n.delete(e) } function vm() { jl = !1, It !== null && Ei(It) && (It = null), Ot !== null && Ei(Ot) && (Ot = null), Nt !== null && Ei(Nt) && (Nt = null), kr.forEach(nu), Mr.forEach(nu) } function er(t, e) { t.blockedOn === e && (t.blockedOn = null, jl || (jl = !0, Ve.unstable_scheduleCallback(Ve.unstable_NormalPriority, vm))) } function _r(t) { function e(i) { return er(i, t) } if (0 < ri.length) { er(ri[0], t); for (var n = 1; n < ri.length; n++) { var r = ri[n]; r.blockedOn === t && (r.blockedOn = null) } } for (It !== null && er(It, t), Ot !== null && er(Ot, t), Nt !== null && er(Nt, t), kr.forEach(e), Mr.forEach(e), n = 0; n < kt.length; n++)r = kt[n], r.blockedOn === t && (r.blockedOn = null); for (; 0 < kt.length && (n = kt[0], n.blockedOn === null);)hd(n), n.blockedOn === null && kt.shift() } var In = xt.ReactCurrentBatchConfig, $i = !0; function wm(t, e, n, r) { var i = q, s = In.transition; In.transition = null; try { q = 1, Ha(t, e, n, r) } finally { q = i, In.transition = s } } function ym(t, e, n, r) { var i = q, s = In.transition; In.transition = null; try { q = 4, Ha(t, e, n, r) } finally { q = i, In.transition = s } } function Ha(t, e, n, r) { if ($i) { var i = Fl(t, e, n, r); if (i === null) Js(t, e, r, ji, n), tu(t, r); else if (gm(i, t, e, n, r)) r.stopPropagation(); else if (tu(t, r), e & 4 && -1 < hm.indexOf(t)) { for (; i !== null;) { var s = Wr(i); if (s !== null && dd(s), s = Fl(t, e, n, r), s === null && Js(t, e, r, ji, n), s === i) break; i = s } i !== null && r.stopPropagation() } else Js(t, e, r, null, n) } } var ji = null; function Fl(t, e, n, r) { if (ji = null, t = Ra(r), t = Zt(t), t !== null) if (e = fn(t), e === null) t = null; else if (n = e.tag, n === 13) { if (t = rd(e), t !== null) return t; t = null } else if (n === 3) { if (e.stateNode.current.memoizedState.isDehydrated) return e.tag === 3 ? e.stateNode.containerInfo : null; t = null } else e !== t && (t = null); return ji = t, null } function gd(t) { switch (t) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (lm()) { case $a: return 1; case ad: return 4; case Di: case am: return 16; case od: return 536870912; default: return 16 }default: return 16 } } var _t = null, Ba = null, xi = null; function vd() { if (xi) return xi; var t, e = Ba, n = e.length, r, i = "value" in _t ? _t.value : _t.textContent, s = i.length; for (t = 0; t < n && e[t] === i[t]; t++); var l = n - t; for (r = 1; r <= l && e[n - r] === i[s - r]; r++); return xi = i.slice(t, 1 < r ? 1 - r : void 0) } function Ti(t) { var e = t.keyCode; return "charCode" in t ? (t = t.charCode, t === 0 && e === 13 && (t = 13)) : t = e, t === 10 && (t = 13), 32 <= t || t === 13 ? t : 0 } function ii() { return !0 } function ru() { return !1 } function We(t) { function e(n, r, i, s, l) { this._reactName = n, this._targetInst = i, this.type = r, this.nativeEvent = s, this.target = l, this.currentTarget = null; for (var o in t) t.hasOwnProperty(o) && (n = t[o], this[o] = n ? n(s) : s[o]); return this.isDefaultPrevented = (s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1) ? ii : ru, this.isPropagationStopped = ru, this } return ne(e.prototype, { preventDefault: function () { this.defaultPrevented = !0; var n = this.nativeEvent; n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = !1), this.isDefaultPrevented = ii) }, stopPropagation: function () { var n = this.nativeEvent; n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0), this.isPropagationStopped = ii) }, persist: function () { }, isPersistent: ii }), e } var Xn = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (t) { return t.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, Va = We(Xn), Gr = ne({}, Xn, { view: 0, detail: 0 }), Sm = We(Gr), Gs, Ws, tr, ds = ne({}, Gr, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Ga, button: 0, buttons: 0, relatedTarget: function (t) { return t.relatedTarget === void 0 ? t.fromElement === t.srcElement ? t.toElement : t.fromElement : t.relatedTarget }, movementX: function (t) { return "movementX" in t ? t.movementX : (t !== tr && (tr && t.type === "mousemove" ? (Gs = t.screenX - tr.screenX, Ws = t.screenY - tr.screenY) : Ws = Gs = 0, tr = t), Gs) }, movementY: function (t) { return "movementY" in t ? t.movementY : Ws } }), iu = We(ds), Em = ne({}, ds, { dataTransfer: 0 }), xm = We(Em), Tm = ne({}, Gr, { relatedTarget: 0 }), Xs = We(Tm), bm = ne({}, Xn, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Cm = We(bm), Pm = ne({}, Xn, { clipboardData: function (t) { return "clipboardData" in t ? t.clipboardData : window.clipboardData } }), km = We(Pm), Mm = ne({}, Xn, { data: 0 }), su = We(Mm), _m = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, Lm = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, zm = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function Im(t) { var e = this.nativeEvent; return e.getModifierState ? e.getModifierState(t) : (t = zm[t]) ? !!e[t] : !1 } function Ga() { return Im } var Om = ne({}, Gr, { key: function (t) { if (t.key) { var e = _m[t.key] || t.key; if (e !== "Unidentified") return e } return t.type === "keypress" ? (t = Ti(t), t === 13 ? "Enter" : String.fromCharCode(t)) : t.type === "keydown" || t.type === "keyup" ? Lm[t.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Ga, charCode: function (t) { return t.type === "keypress" ? Ti(t) : 0 }, keyCode: function (t) { return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0 }, which: function (t) { return t.type === "keypress" ? Ti(t) : t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0 } }), Nm = We(Om), Am = ne({}, ds, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), lu = We(Am), Dm = ne({}, Gr, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Ga }), Rm = We(Dm), $m = ne({}, Xn, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), jm = We($m), Fm = ne({}, ds, { deltaX: function (t) { return "deltaX" in t ? t.deltaX : "wheelDeltaX" in t ? -t.wheelDeltaX : 0 }, deltaY: function (t) { return "deltaY" in t ? t.deltaY : "wheelDeltaY" in t ? -t.wheelDeltaY : "wheelDelta" in t ? -t.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), Hm = We(Fm), Bm = [9, 13, 27, 32], Wa = wt && "CompositionEvent" in window, mr = null; wt && "documentMode" in document && (mr = document.documentMode); var Vm = wt && "TextEvent" in window && !mr, wd = wt && (!Wa || mr && 8 < mr && 11 >= mr), au = " ", ou = !1; function yd(t, e) { switch (t) { case "keyup": return Bm.indexOf(e.keyCode) !== -1; case "keydown": return e.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function Sd(t) { return t = t.detail, typeof t == "object" && "data" in t ? t.data : null } var yn = !1; function Gm(t, e) { switch (t) { case "compositionend": return Sd(e); case "keypress": return e.which !== 32 ? null : (ou = !0, au); case "textInput": return t = e.data, t === au && ou ? null : t; default: return null } } function Wm(t, e) { if (yn) return t === "compositionend" || !Wa && yd(t, e) ? (t = vd(), xi = Ba = _t = null, yn = !1, t) : null; switch (t) { case "paste": return null; case "keypress": if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) { if (e.char && 1 < e.char.length) return e.char; if (e.which) return String.fromCharCode(e.which) } return null; case "compositionend": return wd && e.locale !== "ko" ? null : e.data; default: return null } } var Xm = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function uu(t) { var e = t && t.nodeName && t.nodeName.toLowerCase(); return e === "input" ? !!Xm[t.type] : e === "textarea" } function Ed(t, e, n, r) { Zc(r), e = Fi(e, "onChange"), 0 < e.length && (n = new Va("onChange", "change", null, n, r), t.push({ event: n, listeners: e })) } var hr = null, Lr = null; function Um(t) { Id(t, 0) } function fs(t) { var e = xn(t); if (Wc(e)) return t } function Ym(t, e) { if (t === "change") return e } var xd = !1; if (wt) { var Us; if (wt) { var Ys = "oninput" in document; if (!Ys) { var cu = document.createElement("div"); cu.setAttribute("oninput", "return;"), Ys = typeof cu.oninput == "function" } Us = Ys } else Us = !1; xd = Us && (!document.documentMode || 9 < document.documentMode) } function du() { hr && (hr.detachEvent("onpropertychange", Td), Lr = hr = null) } function Td(t) { if (t.propertyName === "value" && fs(Lr)) { var e = []; Ed(e, Lr, t, Ra(t)), nd(Um, e) } } function qm(t, e, n) { t === "focusin" ? (du(), hr = e, Lr = n, hr.attachEvent("onpropertychange", Td)) : t === "focusout" && du() } function Qm(t) { if (t === "selectionchange" || t === "keyup" || t === "keydown") return fs(Lr) } function Km(t, e) { if (t === "click") return fs(e) } function Zm(t, e) { if (t === "input" || t === "change") return fs(e) } function Jm(t, e) { return t === e && (t !== 0 || 1 / t === 1 / e) || t !== t && e !== e } var st = typeof Object.is == "function" ? Object.is : Jm; function zr(t, e) { if (st(t, e)) return !0; if (typeof t != "object" || t === null || typeof e != "object" || e === null) return !1; var n = Object.keys(t), r = Object.keys(e); if (n.length !== r.length) return !1; for (r = 0; r < n.length; r++) { var i = n[r]; if (!xl.call(e, i) || !st(t[i], e[i])) return !1 } return !0 } function fu(t) { for (; t && t.firstChild;)t = t.firstChild; return t } function pu(t, e) { var n = fu(t); t = 0; for (var r; n;) { if (n.nodeType === 3) { if (r = t + n.textContent.length, t <= e && r >= e) return { node: n, offset: e - t }; t = r } e: { for (; n;) { if (n.nextSibling) { n = n.nextSibling; break e } n = n.parentNode } n = void 0 } n = fu(n) } } function bd(t, e) { return t && e ? t === e ? !0 : t && t.nodeType === 3 ? !1 : e && e.nodeType === 3 ? bd(t, e.parentNode) : "contains" in t ? t.contains(e) : t.compareDocumentPosition ? !!(t.compareDocumentPosition(e) & 16) : !1 : !1 } function Cd() { for (var t = window, e = Oi(); e instanceof t.HTMLIFrameElement;) { try { var n = typeof e.contentWindow.location.href == "string" } catch { n = !1 } if (n) t = e.contentWindow; else break; e = Oi(t.document) } return e } function Xa(t) { var e = t && t.nodeName && t.nodeName.toLowerCase(); return e && (e === "input" && (t.type === "text" || t.type === "search" || t.type === "tel" || t.type === "url" || t.type === "password") || e === "textarea" || t.contentEditable === "true") } function eh(t) { var e = Cd(), n = t.focusedElem, r = t.selectionRange; if (e !== n && n && n.ownerDocument && bd(n.ownerDocument.documentElement, n)) { if (r !== null && Xa(n)) { if (e = r.start, t = r.end, t === void 0 && (t = e), "selectionStart" in n) n.selectionStart = e, n.selectionEnd = Math.min(t, n.value.length); else if (t = (e = n.ownerDocument || document) && e.defaultView || window, t.getSelection) { t = t.getSelection(); var i = n.textContent.length, s = Math.min(r.start, i); r = r.end === void 0 ? s : Math.min(r.end, i), !t.extend && s > r && (i = r, r = s, s = i), i = pu(n, s); var l = pu(n, r); i && l && (t.rangeCount !== 1 || t.anchorNode !== i.node || t.anchorOffset !== i.offset || t.focusNode !== l.node || t.focusOffset !== l.offset) && (e = e.createRange(), e.setStart(i.node, i.offset), t.removeAllRanges(), s > r ? (t.addRange(e), t.extend(l.node, l.offset)) : (e.setEnd(l.node, l.offset), t.addRange(e))) } } for (e = [], t = n; t = t.parentNode;)t.nodeType === 1 && e.push({ element: t, left: t.scrollLeft, top: t.scrollTop }); for (typeof n.focus == "function" && n.focus(), n = 0; n < e.length; n++)t = e[n], t.element.scrollLeft = t.left, t.element.scrollTop = t.top } } var th = wt && "documentMode" in document && 11 >= document.documentMode, Sn = null, Hl = null, gr = null, Bl = !1; function mu(t, e, n) { var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument; Bl || Sn == null || Sn !== Oi(r) || (r = Sn, "selectionStart" in r && Xa(r) ? r = { start: r.selectionStart, end: r.selectionEnd } : (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection(), r = { anchorNode: r.anchorNode, anchorOffset: r.anchorOffset, focusNode: r.focusNode, focusOffset: r.focusOffset }), gr && zr(gr, r) || (gr = r, r = Fi(Hl, "onSelect"), 0 < r.length && (e = new Va("onSelect", "select", null, e, n), t.push({ event: e, listeners: r }), e.target = Sn))) } function si(t, e) { var n = {}; return n[t.toLowerCase()] = e.toLowerCase(), n["Webkit" + t] = "webkit" + e, n["Moz" + t] = "moz" + e, n } var En = { animationend: si("Animation", "AnimationEnd"), animationiteration: si("Animation", "AnimationIteration"), animationstart: si("Animation", "AnimationStart"), transitionend: si("Transition", "TransitionEnd") }, qs = {}, Pd = {}; wt && (Pd = document.createElement("div").style, "AnimationEvent" in window || (delete En.animationend.animation, delete En.animationiteration.animation, delete En.animationstart.animation), "TransitionEvent" in window || delete En.transitionend.transition); function ps(t) { if (qs[t]) return qs[t]; if (!En[t]) return t; var e = En[t], n; for (n in e) if (e.hasOwnProperty(n) && n in Pd) return qs[t] = e[n]; return t } var kd = ps("animationend"), Md = ps("animationiteration"), _d = ps("animationstart"), Ld = ps("transitionend"), zd = new Map, hu = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function Bt(t, e) { zd.set(t, e), dn(e, [t]) } for (var Qs = 0; Qs < hu.length; Qs++) { var Ks = hu[Qs], nh = Ks.toLowerCase(), rh = Ks[0].toUpperCase() + Ks.slice(1); Bt(nh, "on" + rh) } Bt(kd, "onAnimationEnd"); Bt(Md, "onAnimationIteration"); Bt(_d, "onAnimationStart"); Bt("dblclick", "onDoubleClick"); Bt("focusin", "onFocus"); Bt("focusout", "onBlur"); Bt(Ld, "onTransitionEnd"); An("onMouseEnter", ["mouseout", "mouseover"]); An("onMouseLeave", ["mouseout", "mouseover"]); An("onPointerEnter", ["pointerout", "pointerover"]); An("onPointerLeave", ["pointerout", "pointerover"]); dn("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")); dn("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")); dn("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]); dn("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")); dn("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")); dn("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var or = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), ih = new Set("cancel close invalid load scroll toggle".split(" ").concat(or)); function gu(t, e, n) { var r = t.type || "unknown-event"; t.currentTarget = n, nm(r, e, void 0, t), t.currentTarget = null } function Id(t, e) { e = (e & 4) !== 0; for (var n = 0; n < t.length; n++) { var r = t[n], i = r.event; r = r.listeners; e: { var s = void 0; if (e) for (var l = r.length - 1; 0 <= l; l--) { var o = r[l], a = o.instance, u = o.currentTarget; if (o = o.listener, a !== s && i.isPropagationStopped()) break e; gu(i, o, u), s = a } else for (l = 0; l < r.length; l++) { if (o = r[l], a = o.instance, u = o.currentTarget, o = o.listener, a !== s && i.isPropagationStopped()) break e; gu(i, o, u), s = a } } } if (Ai) throw t = Rl, Ai = !1, Rl = null, t } function K(t, e) { var n = e[Ul]; n === void 0 && (n = e[Ul] = new Set); var r = t + "__bubble"; n.has(r) || (Od(e, t, 2, !1), n.add(r)) } function Zs(t, e, n) { var r = 0; e && (r |= 4), Od(n, t, r, e) } var li = "_reactListening" + Math.random().toString(36).slice(2); function Ir(t) { if (!t[li]) { t[li] = !0, Fc.forEach(function (n) { n !== "selectionchange" && (ih.has(n) || Zs(n, !1, t), Zs(n, !0, t)) }); var e = t.nodeType === 9 ? t : t.ownerDocument; e === null || e[li] || (e[li] = !0, Zs("selectionchange", !1, e)) } } function Od(t, e, n, r) { switch (gd(e)) { case 1: var i = wm; break; case 4: i = ym; break; default: i = Ha }n = i.bind(null, e, n, t), i = void 0, !Dl || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (i = !0), r ? i !== void 0 ? t.addEventListener(e, n, { capture: !0, passive: i }) : t.addEventListener(e, n, !0) : i !== void 0 ? t.addEventListener(e, n, { passive: i }) : t.addEventListener(e, n, !1) } function Js(t, e, n, r, i) { var s = r; if (!(e & 1) && !(e & 2) && r !== null) e: for (; ;) { if (r === null) return; var l = r.tag; if (l === 3 || l === 4) { var o = r.stateNode.containerInfo; if (o === i || o.nodeType === 8 && o.parentNode === i) break; if (l === 4) for (l = r.return; l !== null;) { var a = l.tag; if ((a === 3 || a === 4) && (a = l.stateNode.containerInfo, a === i || a.nodeType === 8 && a.parentNode === i)) return; l = l.return } for (; o !== null;) { if (l = Zt(o), l === null) return; if (a = l.tag, a === 5 || a === 6) { r = s = l; continue e } o = o.parentNode } } r = r.return } nd(function () { var u = s, c = Ra(n), d = []; e: { var f = zd.get(t); if (f !== void 0) { var v = Va, g = t; switch (t) { case "keypress": if (Ti(n) === 0) break e; case "keydown": case "keyup": v = Nm; break; case "focusin": g = "focus", v = Xs; break; case "focusout": g = "blur", v = Xs; break; case "beforeblur": case "afterblur": v = Xs; break; case "click": if (n.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": v = iu; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": v = xm; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": v = Rm; break; case kd: case Md: case _d: v = Cm; break; case Ld: v = jm; break; case "scroll": v = Sm; break; case "wheel": v = Hm; break; case "copy": case "cut": case "paste": v = km; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": v = lu }var w = (e & 4) !== 0, y = !w && t === "scroll", p = w ? f !== null ? f + "Capture" : null : f; w = []; for (var m = u, h; m !== null;) { h = m; var S = h.stateNode; if (h.tag === 5 && S !== null && (h = S, p !== null && (S = Pr(m, p), S != null && w.push(Or(m, S, h)))), y) break; m = m.return } 0 < w.length && (f = new v(f, g, null, n, c), d.push({ event: f, listeners: w })) } } if (!(e & 7)) { e: { if (f = t === "mouseover" || t === "pointerover", v = t === "mouseout" || t === "pointerout", f && n !== Nl && (g = n.relatedTarget || n.fromElement) && (Zt(g) || g[yt])) break e; if ((v || f) && (f = c.window === c ? c : (f = c.ownerDocument) ? f.defaultView || f.parentWindow : window, v ? (g = n.relatedTarget || n.toElement, v = u, g = g ? Zt(g) : null, g !== null && (y = fn(g), g !== y || g.tag !== 5 && g.tag !== 6) && (g = null)) : (v = null, g = u), v !== g)) { if (w = iu, S = "onMouseLeave", p = "onMouseEnter", m = "mouse", (t === "pointerout" || t === "pointerover") && (w = lu, S = "onPointerLeave", p = "onPointerEnter", m = "pointer"), y = v == null ? f : xn(v), h = g == null ? f : xn(g), f = new w(S, m + "leave", v, n, c), f.target = y, f.relatedTarget = h, S = null, Zt(c) === u && (w = new w(p, m + "enter", g, n, c), w.target = h, w.relatedTarget = y, S = w), y = S, v && g) t: { for (w = v, p = g, m = 0, h = w; h; h = mn(h))m++; for (h = 0, S = p; S; S = mn(S))h++; for (; 0 < m - h;)w = mn(w), m--; for (; 0 < h - m;)p = mn(p), h--; for (; m--;) { if (w === p || p !== null && w === p.alternate) break t; w = mn(w), p = mn(p) } w = null } else w = null; v !== null && vu(d, f, v, w, !1), g !== null && y !== null && vu(d, y, g, w, !0) } } e: { if (f = u ? xn(u) : window, v = f.nodeName && f.nodeName.toLowerCase(), v === "select" || v === "input" && f.type === "file") var x = Ym; else if (uu(f)) if (xd) x = Zm; else { x = Qm; var T = qm } else (v = f.nodeName) && v.toLowerCase() === "input" && (f.type === "checkbox" || f.type === "radio") && (x = Km); if (x && (x = x(t, u))) { Ed(d, x, n, c); break e } T && T(t, f, u), t === "focusout" && (T = f._wrapperState) && T.controlled && f.type === "number" && _l(f, "number", f.value) } switch (T = u ? xn(u) : window, t) { case "focusin": (uu(T) || T.contentEditable === "true") && (Sn = T, Hl = u, gr = null); break; case "focusout": gr = Hl = Sn = null; break; case "mousedown": Bl = !0; break; case "contextmenu": case "mouseup": case "dragend": Bl = !1, mu(d, n, c); break; case "selectionchange": if (th) break; case "keydown": case "keyup": mu(d, n, c) }var L; if (Wa) e: { switch (t) { case "compositionstart": var b = "onCompositionStart"; break e; case "compositionend": b = "onCompositionEnd"; break e; case "compositionupdate": b = "onCompositionUpdate"; break e }b = void 0 } else yn ? yd(t, n) && (b = "onCompositionEnd") : t === "keydown" && n.keyCode === 229 && (b = "onCompositionStart"); b && (wd && n.locale !== "ko" && (yn || b !== "onCompositionStart" ? b === "onCompositionEnd" && yn && (L = vd()) : (_t = c, Ba = "value" in _t ? _t.value : _t.textContent, yn = !0)), T = Fi(u, b), 0 < T.length && (b = new su(b, t, null, n, c), d.push({ event: b, listeners: T }), L ? b.data = L : (L = Sd(n), L !== null && (b.data = L)))), (L = Vm ? Gm(t, n) : Wm(t, n)) && (u = Fi(u, "onBeforeInput"), 0 < u.length && (c = new su("onBeforeInput", "beforeinput", null, n, c), d.push({ event: c, listeners: u }), c.data = L)) } Id(d, e) }) } function Or(t, e, n) { return { instance: t, listener: e, currentTarget: n } } function Fi(t, e) { for (var n = e + "Capture", r = []; t !== null;) { var i = t, s = i.stateNode; i.tag === 5 && s !== null && (i = s, s = Pr(t, n), s != null && r.unshift(Or(t, s, i)), s = Pr(t, e), s != null && r.push(Or(t, s, i))), t = t.return } return r } function mn(t) { if (t === null) return null; do t = t.return; while (t && t.tag !== 5); return t || null } function vu(t, e, n, r, i) { for (var s = e._reactName, l = []; n !== null && n !== r;) { var o = n, a = o.alternate, u = o.stateNode; if (a !== null && a === r) break; o.tag === 5 && u !== null && (o = u, i ? (a = Pr(n, s), a != null && l.unshift(Or(n, a, o))) : i || (a = Pr(n, s), a != null && l.push(Or(n, a, o)))), n = n.return } l.length !== 0 && t.push({ event: e, listeners: l }) } var sh = /\r\n?/g, lh = /\u0000|\uFFFD/g; function wu(t) {
  return (typeof t == "string" ? t : "" + t).replace(sh, `
`).replace(lh, "")
} function ai(t, e, n) { if (e = wu(e), wu(t) !== e && n) throw Error(D(425)) } function Hi() { } var Vl = null, Gl = null; function Wl(t, e) { return t === "textarea" || t === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null } var Xl = typeof setTimeout == "function" ? setTimeout : void 0, ah = typeof clearTimeout == "function" ? clearTimeout : void 0, yu = typeof Promise == "function" ? Promise : void 0, oh = typeof queueMicrotask == "function" ? queueMicrotask : typeof yu < "u" ? function (t) { return yu.resolve(null).then(t).catch(uh) } : Xl; function uh(t) { setTimeout(function () { throw t }) } function el(t, e) { var n = e, r = 0; do { var i = n.nextSibling; if (t.removeChild(n), i && i.nodeType === 8) if (n = i.data, n === "/$") { if (r === 0) { t.removeChild(i), _r(e); return } r-- } else n !== "$" && n !== "$?" && n !== "$!" || r++; n = i } while (n); _r(e) } function At(t) { for (; t != null; t = t.nextSibling) { var e = t.nodeType; if (e === 1 || e === 3) break; if (e === 8) { if (e = t.data, e === "$" || e === "$!" || e === "$?") break; if (e === "/$") return null } } return t } function Su(t) { t = t.previousSibling; for (var e = 0; t;) { if (t.nodeType === 8) { var n = t.data; if (n === "$" || n === "$!" || n === "$?") { if (e === 0) return t; e-- } else n === "/$" && e++ } t = t.previousSibling } return null } var Un = Math.random().toString(36).slice(2), ut = "__reactFiber$" + Un, Nr = "__reactProps$" + Un, yt = "__reactContainer$" + Un, Ul = "__reactEvents$" + Un, ch = "__reactListeners$" + Un, dh = "__reactHandles$" + Un; function Zt(t) { var e = t[ut]; if (e) return e; for (var n = t.parentNode; n;) { if (e = n[yt] || n[ut]) { if (n = e.alternate, e.child !== null || n !== null && n.child !== null) for (t = Su(t); t !== null;) { if (n = t[ut]) return n; t = Su(t) } return e } t = n, n = t.parentNode } return null } function Wr(t) { return t = t[ut] || t[yt], !t || t.tag !== 5 && t.tag !== 6 && t.tag !== 13 && t.tag !== 3 ? null : t } function xn(t) { if (t.tag === 5 || t.tag === 6) return t.stateNode; throw Error(D(33)) } function ms(t) { return t[Nr] || null } var Yl = [], Tn = -1; function Vt(t) { return { current: t } } function Z(t) { 0 > Tn || (t.current = Yl[Tn], Yl[Tn] = null, Tn--) } function Q(t, e) { Tn++, Yl[Tn] = t.current, t.current = e } var Ht = {}, Ce = Vt(Ht), Oe = Vt(!1), sn = Ht; function Dn(t, e) { var n = t.type.contextTypes; if (!n) return Ht; var r = t.stateNode; if (r && r.__reactInternalMemoizedUnmaskedChildContext === e) return r.__reactInternalMemoizedMaskedChildContext; var i = {}, s; for (s in n) i[s] = e[s]; return r && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = e, t.__reactInternalMemoizedMaskedChildContext = i), i } function Ne(t) { return t = t.childContextTypes, t != null } function Bi() { Z(Oe), Z(Ce) } function Eu(t, e, n) { if (Ce.current !== Ht) throw Error(D(168)); Q(Ce, e), Q(Oe, n) } function Nd(t, e, n) { var r = t.stateNode; if (e = e.childContextTypes, typeof r.getChildContext != "function") return n; r = r.getChildContext(); for (var i in r) if (!(i in e)) throw Error(D(108, qp(t) || "Unknown", i)); return ne({}, n, r) } function Vi(t) { return t = (t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext || Ht, sn = Ce.current, Q(Ce, t), Q(Oe, Oe.current), !0 } function xu(t, e, n) { var r = t.stateNode; if (!r) throw Error(D(169)); n ? (t = Nd(t, e, sn), r.__reactInternalMemoizedMergedChildContext = t, Z(Oe), Z(Ce), Q(Ce, t)) : Z(Oe), Q(Oe, n) } var pt = null, hs = !1, tl = !1; function Ad(t) { pt === null ? pt = [t] : pt.push(t) } function fh(t) { hs = !0, Ad(t) } function Gt() { if (!tl && pt !== null) { tl = !0; var t = 0, e = q; try { var n = pt; for (q = 1; t < n.length; t++) { var r = n[t]; do r = r(!0); while (r !== null) } pt = null, hs = !1 } catch (i) { throw pt !== null && (pt = pt.slice(t + 1)), ld($a, Gt), i } finally { q = e, tl = !1 } } return null } var bn = [], Cn = 0, Gi = null, Wi = 0, Xe = [], Ue = 0, ln = null, ht = 1, gt = ""; function Yt(t, e) { bn[Cn++] = Wi, bn[Cn++] = Gi, Gi = t, Wi = e } function Dd(t, e, n) { Xe[Ue++] = ht, Xe[Ue++] = gt, Xe[Ue++] = ln, ln = t; var r = ht; t = gt; var i = 32 - rt(r) - 1; r &= ~(1 << i), n += 1; var s = 32 - rt(e) + i; if (30 < s) { var l = i - i % 5; s = (r & (1 << l) - 1).toString(32), r >>= l, i -= l, ht = 1 << 32 - rt(e) + i | n << i | r, gt = s + t } else ht = 1 << s | n << i | r, gt = t } function Ua(t) { t.return !== null && (Yt(t, 1), Dd(t, 1, 0)) } function Ya(t) { for (; t === Gi;)Gi = bn[--Cn], bn[Cn] = null, Wi = bn[--Cn], bn[Cn] = null; for (; t === ln;)ln = Xe[--Ue], Xe[Ue] = null, gt = Xe[--Ue], Xe[Ue] = null, ht = Xe[--Ue], Xe[Ue] = null } var Be = null, Fe = null, J = !1, nt = null; function Rd(t, e) { var n = qe(5, null, null, 0); n.elementType = "DELETED", n.stateNode = e, n.return = t, e = t.deletions, e === null ? (t.deletions = [n], t.flags |= 16) : e.push(n) } function Tu(t, e) { switch (t.tag) { case 5: var n = t.type; return e = e.nodeType !== 1 || n.toLowerCase() !== e.nodeName.toLowerCase() ? null : e, e !== null ? (t.stateNode = e, Be = t, Fe = At(e.firstChild), !0) : !1; case 6: return e = t.pendingProps === "" || e.nodeType !== 3 ? null : e, e !== null ? (t.stateNode = e, Be = t, Fe = null, !0) : !1; case 13: return e = e.nodeType !== 8 ? null : e, e !== null ? (n = ln !== null ? { id: ht, overflow: gt } : null, t.memoizedState = { dehydrated: e, treeContext: n, retryLane: 1073741824 }, n = qe(18, null, null, 0), n.stateNode = e, n.return = t, t.child = n, Be = t, Fe = null, !0) : !1; default: return !1 } } function ql(t) { return (t.mode & 1) !== 0 && (t.flags & 128) === 0 } function Ql(t) { if (J) { var e = Fe; if (e) { var n = e; if (!Tu(t, e)) { if (ql(t)) throw Error(D(418)); e = At(n.nextSibling); var r = Be; e && Tu(t, e) ? Rd(r, n) : (t.flags = t.flags & -4097 | 2, J = !1, Be = t) } } else { if (ql(t)) throw Error(D(418)); t.flags = t.flags & -4097 | 2, J = !1, Be = t } } } function bu(t) { for (t = t.return; t !== null && t.tag !== 5 && t.tag !== 3 && t.tag !== 13;)t = t.return; Be = t } function oi(t) { if (t !== Be) return !1; if (!J) return bu(t), J = !0, !1; var e; if ((e = t.tag !== 3) && !(e = t.tag !== 5) && (e = t.type, e = e !== "head" && e !== "body" && !Wl(t.type, t.memoizedProps)), e && (e = Fe)) { if (ql(t)) throw $d(), Error(D(418)); for (; e;)Rd(t, e), e = At(e.nextSibling) } if (bu(t), t.tag === 13) { if (t = t.memoizedState, t = t !== null ? t.dehydrated : null, !t) throw Error(D(317)); e: { for (t = t.nextSibling, e = 0; t;) { if (t.nodeType === 8) { var n = t.data; if (n === "/$") { if (e === 0) { Fe = At(t.nextSibling); break e } e-- } else n !== "$" && n !== "$!" && n !== "$?" || e++ } t = t.nextSibling } Fe = null } } else Fe = Be ? At(t.stateNode.nextSibling) : null; return !0 } function $d() { for (var t = Fe; t;)t = At(t.nextSibling) } function Rn() { Fe = Be = null, J = !1 } function qa(t) { nt === null ? nt = [t] : nt.push(t) } var ph = xt.ReactCurrentBatchConfig; function et(t, e) { if (t && t.defaultProps) { e = ne({}, e), t = t.defaultProps; for (var n in t) e[n] === void 0 && (e[n] = t[n]); return e } return e } var Xi = Vt(null), Ui = null, Pn = null, Qa = null; function Ka() { Qa = Pn = Ui = null } function Za(t) { var e = Xi.current; Z(Xi), t._currentValue = e } function Kl(t, e, n) { for (; t !== null;) { var r = t.alternate; if ((t.childLanes & e) !== e ? (t.childLanes |= e, r !== null && (r.childLanes |= e)) : r !== null && (r.childLanes & e) !== e && (r.childLanes |= e), t === n) break; t = t.return } } function On(t, e) { Ui = t, Qa = Pn = null, t = t.dependencies, t !== null && t.firstContext !== null && (t.lanes & e && (Ie = !0), t.firstContext = null) } function Ke(t) { var e = t._currentValue; if (Qa !== t) if (t = { context: t, memoizedValue: e, next: null }, Pn === null) { if (Ui === null) throw Error(D(308)); Pn = t, Ui.dependencies = { lanes: 0, firstContext: t } } else Pn = Pn.next = t; return e } var Jt = null; function Ja(t) { Jt === null ? Jt = [t] : Jt.push(t) } function jd(t, e, n, r) { var i = e.interleaved; return i === null ? (n.next = n, Ja(e)) : (n.next = i.next, i.next = n), e.interleaved = n, St(t, r) } function St(t, e) { t.lanes |= e; var n = t.alternate; for (n !== null && (n.lanes |= e), n = t, t = t.return; t !== null;)t.childLanes |= e, n = t.alternate, n !== null && (n.childLanes |= e), n = t, t = t.return; return n.tag === 3 ? n.stateNode : null } var Pt = !1; function eo(t) { t.updateQueue = { baseState: t.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function Fd(t, e) { t = t.updateQueue, e.updateQueue === t && (e.updateQueue = { baseState: t.baseState, firstBaseUpdate: t.firstBaseUpdate, lastBaseUpdate: t.lastBaseUpdate, shared: t.shared, effects: t.effects }) } function vt(t, e) { return { eventTime: t, lane: e, tag: 0, payload: null, callback: null, next: null } } function Dt(t, e, n) { var r = t.updateQueue; if (r === null) return null; if (r = r.shared, U & 2) { var i = r.pending; return i === null ? e.next = e : (e.next = i.next, i.next = e), r.pending = e, St(t, n) } return i = r.interleaved, i === null ? (e.next = e, Ja(r)) : (e.next = i.next, i.next = e), r.interleaved = e, St(t, n) } function bi(t, e, n) { if (e = e.updateQueue, e !== null && (e = e.shared, (n & 4194240) !== 0)) { var r = e.lanes; r &= t.pendingLanes, n |= r, e.lanes = n, ja(t, n) } } function Cu(t, e) { var n = t.updateQueue, r = t.alternate; if (r !== null && (r = r.updateQueue, n === r)) { var i = null, s = null; if (n = n.firstBaseUpdate, n !== null) { do { var l = { eventTime: n.eventTime, lane: n.lane, tag: n.tag, payload: n.payload, callback: n.callback, next: null }; s === null ? i = s = l : s = s.next = l, n = n.next } while (n !== null); s === null ? i = s = e : s = s.next = e } else i = s = e; n = { baseState: r.baseState, firstBaseUpdate: i, lastBaseUpdate: s, shared: r.shared, effects: r.effects }, t.updateQueue = n; return } t = n.lastBaseUpdate, t === null ? n.firstBaseUpdate = e : t.next = e, n.lastBaseUpdate = e } function Yi(t, e, n, r) { var i = t.updateQueue; Pt = !1; var s = i.firstBaseUpdate, l = i.lastBaseUpdate, o = i.shared.pending; if (o !== null) { i.shared.pending = null; var a = o, u = a.next; a.next = null, l === null ? s = u : l.next = u, l = a; var c = t.alternate; c !== null && (c = c.updateQueue, o = c.lastBaseUpdate, o !== l && (o === null ? c.firstBaseUpdate = u : o.next = u, c.lastBaseUpdate = a)) } if (s !== null) { var d = i.baseState; l = 0, c = u = a = null, o = s; do { var f = o.lane, v = o.eventTime; if ((r & f) === f) { c !== null && (c = c.next = { eventTime: v, lane: 0, tag: o.tag, payload: o.payload, callback: o.callback, next: null }); e: { var g = t, w = o; switch (f = e, v = n, w.tag) { case 1: if (g = w.payload, typeof g == "function") { d = g.call(v, d, f); break e } d = g; break e; case 3: g.flags = g.flags & -65537 | 128; case 0: if (g = w.payload, f = typeof g == "function" ? g.call(v, d, f) : g, f == null) break e; d = ne({}, d, f); break e; case 2: Pt = !0 } } o.callback !== null && o.lane !== 0 && (t.flags |= 64, f = i.effects, f === null ? i.effects = [o] : f.push(o)) } else v = { eventTime: v, lane: f, tag: o.tag, payload: o.payload, callback: o.callback, next: null }, c === null ? (u = c = v, a = d) : c = c.next = v, l |= f; if (o = o.next, o === null) { if (o = i.shared.pending, o === null) break; f = o, o = f.next, f.next = null, i.lastBaseUpdate = f, i.shared.pending = null } } while (!0); if (c === null && (a = d), i.baseState = a, i.firstBaseUpdate = u, i.lastBaseUpdate = c, e = i.shared.interleaved, e !== null) { i = e; do l |= i.lane, i = i.next; while (i !== e) } else s === null && (i.shared.lanes = 0); on |= l, t.lanes = l, t.memoizedState = d } } function Pu(t, e, n) { if (t = e.effects, e.effects = null, t !== null) for (e = 0; e < t.length; e++) { var r = t[e], i = r.callback; if (i !== null) { if (r.callback = null, r = n, typeof i != "function") throw Error(D(191, i)); i.call(r) } } } var Hd = new jc.Component().refs; function Zl(t, e, n, r) { e = t.memoizedState, n = n(r, e), n = n == null ? e : ne({}, e, n), t.memoizedState = n, t.lanes === 0 && (t.updateQueue.baseState = n) } var gs = { isMounted: function (t) { return (t = t._reactInternals) ? fn(t) === t : !1 }, enqueueSetState: function (t, e, n) { t = t._reactInternals; var r = ke(), i = $t(t), s = vt(r, i); s.payload = e, n != null && (s.callback = n), e = Dt(t, s, i), e !== null && (it(e, t, i, r), bi(e, t, i)) }, enqueueReplaceState: function (t, e, n) { t = t._reactInternals; var r = ke(), i = $t(t), s = vt(r, i); s.tag = 1, s.payload = e, n != null && (s.callback = n), e = Dt(t, s, i), e !== null && (it(e, t, i, r), bi(e, t, i)) }, enqueueForceUpdate: function (t, e) { t = t._reactInternals; var n = ke(), r = $t(t), i = vt(n, r); i.tag = 2, e != null && (i.callback = e), e = Dt(t, i, r), e !== null && (it(e, t, r, n), bi(e, t, r)) } }; function ku(t, e, n, r, i, s, l) { return t = t.stateNode, typeof t.shouldComponentUpdate == "function" ? t.shouldComponentUpdate(r, s, l) : e.prototype && e.prototype.isPureReactComponent ? !zr(n, r) || !zr(i, s) : !0 } function Bd(t, e, n) { var r = !1, i = Ht, s = e.contextType; return typeof s == "object" && s !== null ? s = Ke(s) : (i = Ne(e) ? sn : Ce.current, r = e.contextTypes, s = (r = r != null) ? Dn(t, i) : Ht), e = new e(n, s), t.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null, e.updater = gs, t.stateNode = e, e._reactInternals = t, r && (t = t.stateNode, t.__reactInternalMemoizedUnmaskedChildContext = i, t.__reactInternalMemoizedMaskedChildContext = s), e } function Mu(t, e, n, r) { t = e.state, typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(n, r), typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(n, r), e.state !== t && gs.enqueueReplaceState(e, e.state, null) } function Jl(t, e, n, r) { var i = t.stateNode; i.props = n, i.state = t.memoizedState, i.refs = Hd, eo(t); var s = e.contextType; typeof s == "object" && s !== null ? i.context = Ke(s) : (s = Ne(e) ? sn : Ce.current, i.context = Dn(t, s)), i.state = t.memoizedState, s = e.getDerivedStateFromProps, typeof s == "function" && (Zl(t, e, s, n), i.state = t.memoizedState), typeof e.getDerivedStateFromProps == "function" || typeof i.getSnapshotBeforeUpdate == "function" || typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function" || (e = i.state, typeof i.componentWillMount == "function" && i.componentWillMount(), typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount(), e !== i.state && gs.enqueueReplaceState(i, i.state, null), Yi(t, n, i, r), i.state = t.memoizedState), typeof i.componentDidMount == "function" && (t.flags |= 4194308) } function nr(t, e, n) { if (t = n.ref, t !== null && typeof t != "function" && typeof t != "object") { if (n._owner) { if (n = n._owner, n) { if (n.tag !== 1) throw Error(D(309)); var r = n.stateNode } if (!r) throw Error(D(147, t)); var i = r, s = "" + t; return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === s ? e.ref : (e = function (l) { var o = i.refs; o === Hd && (o = i.refs = {}), l === null ? delete o[s] : o[s] = l }, e._stringRef = s, e) } if (typeof t != "string") throw Error(D(284)); if (!n._owner) throw Error(D(290, t)) } return t } function ui(t, e) { throw t = Object.prototype.toString.call(e), Error(D(31, t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t)) } function _u(t) { var e = t._init; return e(t._payload) } function Vd(t) { function e(p, m) { if (t) { var h = p.deletions; h === null ? (p.deletions = [m], p.flags |= 16) : h.push(m) } } function n(p, m) { if (!t) return null; for (; m !== null;)e(p, m), m = m.sibling; return null } function r(p, m) { for (p = new Map; m !== null;)m.key !== null ? p.set(m.key, m) : p.set(m.index, m), m = m.sibling; return p } function i(p, m) { return p = jt(p, m), p.index = 0, p.sibling = null, p } function s(p, m, h) { return p.index = h, t ? (h = p.alternate, h !== null ? (h = h.index, h < m ? (p.flags |= 2, m) : h) : (p.flags |= 2, m)) : (p.flags |= 1048576, m) } function l(p) { return t && p.alternate === null && (p.flags |= 2), p } function o(p, m, h, S) { return m === null || m.tag !== 6 ? (m = ol(h, p.mode, S), m.return = p, m) : (m = i(m, h), m.return = p, m) } function a(p, m, h, S) { var x = h.type; return x === wn ? c(p, m, h.props.children, S, h.key) : m !== null && (m.elementType === x || typeof x == "object" && x !== null && x.$$typeof === Ct && _u(x) === m.type) ? (S = i(m, h.props), S.ref = nr(p, m, h), S.return = p, S) : (S = Li(h.type, h.key, h.props, null, p.mode, S), S.ref = nr(p, m, h), S.return = p, S) } function u(p, m, h, S) { return m === null || m.tag !== 4 || m.stateNode.containerInfo !== h.containerInfo || m.stateNode.implementation !== h.implementation ? (m = ul(h, p.mode, S), m.return = p, m) : (m = i(m, h.children || []), m.return = p, m) } function c(p, m, h, S, x) { return m === null || m.tag !== 7 ? (m = nn(h, p.mode, S, x), m.return = p, m) : (m = i(m, h), m.return = p, m) } function d(p, m, h) { if (typeof m == "string" && m !== "" || typeof m == "number") return m = ol("" + m, p.mode, h), m.return = p, m; if (typeof m == "object" && m !== null) { switch (m.$$typeof) { case Zr: return h = Li(m.type, m.key, m.props, null, p.mode, h), h.ref = nr(p, null, m), h.return = p, h; case vn: return m = ul(m, p.mode, h), m.return = p, m; case Ct: var S = m._init; return d(p, S(m._payload), h) }if (lr(m) || Kn(m)) return m = nn(m, p.mode, h, null), m.return = p, m; ui(p, m) } return null } function f(p, m, h, S) { var x = m !== null ? m.key : null; if (typeof h == "string" && h !== "" || typeof h == "number") return x !== null ? null : o(p, m, "" + h, S); if (typeof h == "object" && h !== null) { switch (h.$$typeof) { case Zr: return h.key === x ? a(p, m, h, S) : null; case vn: return h.key === x ? u(p, m, h, S) : null; case Ct: return x = h._init, f(p, m, x(h._payload), S) }if (lr(h) || Kn(h)) return x !== null ? null : c(p, m, h, S, null); ui(p, h) } return null } function v(p, m, h, S, x) { if (typeof S == "string" && S !== "" || typeof S == "number") return p = p.get(h) || null, o(m, p, "" + S, x); if (typeof S == "object" && S !== null) { switch (S.$$typeof) { case Zr: return p = p.get(S.key === null ? h : S.key) || null, a(m, p, S, x); case vn: return p = p.get(S.key === null ? h : S.key) || null, u(m, p, S, x); case Ct: var T = S._init; return v(p, m, h, T(S._payload), x) }if (lr(S) || Kn(S)) return p = p.get(h) || null, c(m, p, S, x, null); ui(m, S) } return null } function g(p, m, h, S) { for (var x = null, T = null, L = m, b = m = 0, C = null; L !== null && b < h.length; b++) { L.index > b ? (C = L, L = null) : C = L.sibling; var P = f(p, L, h[b], S); if (P === null) { L === null && (L = C); break } t && L && P.alternate === null && e(p, L), m = s(P, m, b), T === null ? x = P : T.sibling = P, T = P, L = C } if (b === h.length) return n(p, L), J && Yt(p, b), x; if (L === null) { for (; b < h.length; b++)L = d(p, h[b], S), L !== null && (m = s(L, m, b), T === null ? x = L : T.sibling = L, T = L); return J && Yt(p, b), x } for (L = r(p, L); b < h.length; b++)C = v(L, p, b, h[b], S), C !== null && (t && C.alternate !== null && L.delete(C.key === null ? b : C.key), m = s(C, m, b), T === null ? x = C : T.sibling = C, T = C); return t && L.forEach(function (N) { return e(p, N) }), J && Yt(p, b), x } function w(p, m, h, S) { var x = Kn(h); if (typeof x != "function") throw Error(D(150)); if (h = x.call(h), h == null) throw Error(D(151)); for (var T = x = null, L = m, b = m = 0, C = null, P = h.next(); L !== null && !P.done; b++, P = h.next()) { L.index > b ? (C = L, L = null) : C = L.sibling; var N = f(p, L, P.value, S); if (N === null) { L === null && (L = C); break } t && L && N.alternate === null && e(p, L), m = s(N, m, b), T === null ? x = N : T.sibling = N, T = N, L = C } if (P.done) return n(p, L), J && Yt(p, b), x; if (L === null) { for (; !P.done; b++, P = h.next())P = d(p, P.value, S), P !== null && (m = s(P, m, b), T === null ? x = P : T.sibling = P, T = P); return J && Yt(p, b), x } for (L = r(p, L); !P.done; b++, P = h.next())P = v(L, p, b, P.value, S), P !== null && (t && P.alternate !== null && L.delete(P.key === null ? b : P.key), m = s(P, m, b), T === null ? x = P : T.sibling = P, T = P); return t && L.forEach(function (M) { return e(p, M) }), J && Yt(p, b), x } function y(p, m, h, S) { if (typeof h == "object" && h !== null && h.type === wn && h.key === null && (h = h.props.children), typeof h == "object" && h !== null) { switch (h.$$typeof) { case Zr: e: { for (var x = h.key, T = m; T !== null;) { if (T.key === x) { if (x = h.type, x === wn) { if (T.tag === 7) { n(p, T.sibling), m = i(T, h.props.children), m.return = p, p = m; break e } } else if (T.elementType === x || typeof x == "object" && x !== null && x.$$typeof === Ct && _u(x) === T.type) { n(p, T.sibling), m = i(T, h.props), m.ref = nr(p, T, h), m.return = p, p = m; break e } n(p, T); break } else e(p, T); T = T.sibling } h.type === wn ? (m = nn(h.props.children, p.mode, S, h.key), m.return = p, p = m) : (S = Li(h.type, h.key, h.props, null, p.mode, S), S.ref = nr(p, m, h), S.return = p, p = S) } return l(p); case vn: e: { for (T = h.key; m !== null;) { if (m.key === T) if (m.tag === 4 && m.stateNode.containerInfo === h.containerInfo && m.stateNode.implementation === h.implementation) { n(p, m.sibling), m = i(m, h.children || []), m.return = p, p = m; break e } else { n(p, m); break } else e(p, m); m = m.sibling } m = ul(h, p.mode, S), m.return = p, p = m } return l(p); case Ct: return T = h._init, y(p, m, T(h._payload), S) }if (lr(h)) return g(p, m, h, S); if (Kn(h)) return w(p, m, h, S); ui(p, h) } return typeof h == "string" && h !== "" || typeof h == "number" ? (h = "" + h, m !== null && m.tag === 6 ? (n(p, m.sibling), m = i(m, h), m.return = p, p = m) : (n(p, m), m = ol(h, p.mode, S), m.return = p, p = m), l(p)) : n(p, m) } return y } var $n = Vd(!0), Gd = Vd(!1), Xr = {}, dt = Vt(Xr), Ar = Vt(Xr), Dr = Vt(Xr); function en(t) { if (t === Xr) throw Error(D(174)); return t } function to(t, e) { switch (Q(Dr, e), Q(Ar, t), Q(dt, Xr), t = e.nodeType, t) { case 9: case 11: e = (e = e.documentElement) ? e.namespaceURI : zl(null, ""); break; default: t = t === 8 ? e.parentNode : e, e = t.namespaceURI || null, t = t.tagName, e = zl(e, t) }Z(dt), Q(dt, e) } function jn() { Z(dt), Z(Ar), Z(Dr) } function Wd(t) { en(Dr.current); var e = en(dt.current), n = zl(e, t.type); e !== n && (Q(Ar, t), Q(dt, n)) } function no(t) { Ar.current === t && (Z(dt), Z(Ar)) } var ee = Vt(0); function qi(t) { for (var e = t; e !== null;) { if (e.tag === 13) { var n = e.memoizedState; if (n !== null && (n = n.dehydrated, n === null || n.data === "$?" || n.data === "$!")) return e } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) { if (e.flags & 128) return e } else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === t) break; for (; e.sibling === null;) { if (e.return === null || e.return === t) return null; e = e.return } e.sibling.return = e.return, e = e.sibling } return null } var nl = []; function ro() { for (var t = 0; t < nl.length; t++)nl[t]._workInProgressVersionPrimary = null; nl.length = 0 } var Ci = xt.ReactCurrentDispatcher, rl = xt.ReactCurrentBatchConfig, an = 0, te = null, ce = null, pe = null, Qi = !1, vr = !1, Rr = 0, mh = 0; function Ee() { throw Error(D(321)) } function io(t, e) { if (e === null) return !1; for (var n = 0; n < e.length && n < t.length; n++)if (!st(t[n], e[n])) return !1; return !0 } function so(t, e, n, r, i, s) { if (an = s, te = e, e.memoizedState = null, e.updateQueue = null, e.lanes = 0, Ci.current = t === null || t.memoizedState === null ? wh : yh, t = n(r, i), vr) { s = 0; do { if (vr = !1, Rr = 0, 25 <= s) throw Error(D(301)); s += 1, pe = ce = null, e.updateQueue = null, Ci.current = Sh, t = n(r, i) } while (vr) } if (Ci.current = Ki, e = ce !== null && ce.next !== null, an = 0, pe = ce = te = null, Qi = !1, e) throw Error(D(300)); return t } function lo() { var t = Rr !== 0; return Rr = 0, t } function ot() { var t = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return pe === null ? te.memoizedState = pe = t : pe = pe.next = t, pe } function Ze() { if (ce === null) { var t = te.alternate; t = t !== null ? t.memoizedState : null } else t = ce.next; var e = pe === null ? te.memoizedState : pe.next; if (e !== null) pe = e, ce = t; else { if (t === null) throw Error(D(310)); ce = t, t = { memoizedState: ce.memoizedState, baseState: ce.baseState, baseQueue: ce.baseQueue, queue: ce.queue, next: null }, pe === null ? te.memoizedState = pe = t : pe = pe.next = t } return pe } function $r(t, e) { return typeof e == "function" ? e(t) : e } function il(t) { var e = Ze(), n = e.queue; if (n === null) throw Error(D(311)); n.lastRenderedReducer = t; var r = ce, i = r.baseQueue, s = n.pending; if (s !== null) { if (i !== null) { var l = i.next; i.next = s.next, s.next = l } r.baseQueue = i = s, n.pending = null } if (i !== null) { s = i.next, r = r.baseState; var o = l = null, a = null, u = s; do { var c = u.lane; if ((an & c) === c) a !== null && (a = a.next = { lane: 0, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }), r = u.hasEagerState ? u.eagerState : t(r, u.action); else { var d = { lane: c, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }; a === null ? (o = a = d, l = r) : a = a.next = d, te.lanes |= c, on |= c } u = u.next } while (u !== null && u !== s); a === null ? l = r : a.next = o, st(r, e.memoizedState) || (Ie = !0), e.memoizedState = r, e.baseState = l, e.baseQueue = a, n.lastRenderedState = r } if (t = n.interleaved, t !== null) { i = t; do s = i.lane, te.lanes |= s, on |= s, i = i.next; while (i !== t) } else i === null && (n.lanes = 0); return [e.memoizedState, n.dispatch] } function sl(t) { var e = Ze(), n = e.queue; if (n === null) throw Error(D(311)); n.lastRenderedReducer = t; var r = n.dispatch, i = n.pending, s = e.memoizedState; if (i !== null) { n.pending = null; var l = i = i.next; do s = t(s, l.action), l = l.next; while (l !== i); st(s, e.memoizedState) || (Ie = !0), e.memoizedState = s, e.baseQueue === null && (e.baseState = s), n.lastRenderedState = s } return [s, r] } function Xd() { } function Ud(t, e) { var n = te, r = Ze(), i = e(), s = !st(r.memoizedState, i); if (s && (r.memoizedState = i, Ie = !0), r = r.queue, ao(Qd.bind(null, n, r, t), [t]), r.getSnapshot !== e || s || pe !== null && pe.memoizedState.tag & 1) { if (n.flags |= 2048, jr(9, qd.bind(null, n, r, i, e), void 0, null), me === null) throw Error(D(349)); an & 30 || Yd(n, e, i) } return i } function Yd(t, e, n) { t.flags |= 16384, t = { getSnapshot: e, value: n }, e = te.updateQueue, e === null ? (e = { lastEffect: null, stores: null }, te.updateQueue = e, e.stores = [t]) : (n = e.stores, n === null ? e.stores = [t] : n.push(t)) } function qd(t, e, n, r) { e.value = n, e.getSnapshot = r, Kd(e) && Zd(t) } function Qd(t, e, n) { return n(function () { Kd(e) && Zd(t) }) } function Kd(t) { var e = t.getSnapshot; t = t.value; try { var n = e(); return !st(t, n) } catch { return !0 } } function Zd(t) { var e = St(t, 1); e !== null && it(e, t, 1, -1) } function Lu(t) { var e = ot(); return typeof t == "function" && (t = t()), e.memoizedState = e.baseState = t, t = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: $r, lastRenderedState: t }, e.queue = t, t = t.dispatch = vh.bind(null, te, t), [e.memoizedState, t] } function jr(t, e, n, r) { return t = { tag: t, create: e, destroy: n, deps: r, next: null }, e = te.updateQueue, e === null ? (e = { lastEffect: null, stores: null }, te.updateQueue = e, e.lastEffect = t.next = t) : (n = e.lastEffect, n === null ? e.lastEffect = t.next = t : (r = n.next, n.next = t, t.next = r, e.lastEffect = t)), t } function Jd() { return Ze().memoizedState } function Pi(t, e, n, r) { var i = ot(); te.flags |= t, i.memoizedState = jr(1 | e, n, void 0, r === void 0 ? null : r) } function vs(t, e, n, r) { var i = Ze(); r = r === void 0 ? null : r; var s = void 0; if (ce !== null) { var l = ce.memoizedState; if (s = l.destroy, r !== null && io(r, l.deps)) { i.memoizedState = jr(e, n, s, r); return } } te.flags |= t, i.memoizedState = jr(1 | e, n, s, r) } function zu(t, e) { return Pi(8390656, 8, t, e) } function ao(t, e) { return vs(2048, 8, t, e) } function ef(t, e) { return vs(4, 2, t, e) } function tf(t, e) { return vs(4, 4, t, e) } function nf(t, e) { if (typeof e == "function") return t = t(), e(t), function () { e(null) }; if (e != null) return t = t(), e.current = t, function () { e.current = null } } function rf(t, e, n) { return n = n != null ? n.concat([t]) : null, vs(4, 4, nf.bind(null, e, t), n) } function oo() { } function sf(t, e) { var n = Ze(); e = e === void 0 ? null : e; var r = n.memoizedState; return r !== null && e !== null && io(e, r[1]) ? r[0] : (n.memoizedState = [t, e], t) } function lf(t, e) { var n = Ze(); e = e === void 0 ? null : e; var r = n.memoizedState; return r !== null && e !== null && io(e, r[1]) ? r[0] : (t = t(), n.memoizedState = [t, e], t) } function af(t, e, n) { return an & 21 ? (st(n, e) || (n = ud(), te.lanes |= n, on |= n, t.baseState = !0), e) : (t.baseState && (t.baseState = !1, Ie = !0), t.memoizedState = n) } function hh(t, e) { var n = q; q = n !== 0 && 4 > n ? n : 4, t(!0); var r = rl.transition; rl.transition = {}; try { t(!1), e() } finally { q = n, rl.transition = r } } function of() { return Ze().memoizedState } function gh(t, e, n) { var r = $t(t); if (n = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }, uf(t)) cf(e, n); else if (n = jd(t, e, n, r), n !== null) { var i = ke(); it(n, t, r, i), df(n, e, r) } } function vh(t, e, n) { var r = $t(t), i = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }; if (uf(t)) cf(e, i); else { var s = t.alternate; if (t.lanes === 0 && (s === null || s.lanes === 0) && (s = e.lastRenderedReducer, s !== null)) try { var l = e.lastRenderedState, o = s(l, n); if (i.hasEagerState = !0, i.eagerState = o, st(o, l)) { var a = e.interleaved; a === null ? (i.next = i, Ja(e)) : (i.next = a.next, a.next = i), e.interleaved = i; return } } catch { } finally { } n = jd(t, e, i, r), n !== null && (i = ke(), it(n, t, r, i), df(n, e, r)) } } function uf(t) { var e = t.alternate; return t === te || e !== null && e === te } function cf(t, e) { vr = Qi = !0; var n = t.pending; n === null ? e.next = e : (e.next = n.next, n.next = e), t.pending = e } function df(t, e, n) { if (n & 4194240) { var r = e.lanes; r &= t.pendingLanes, n |= r, e.lanes = n, ja(t, n) } } var Ki = { readContext: Ke, useCallback: Ee, useContext: Ee, useEffect: Ee, useImperativeHandle: Ee, useInsertionEffect: Ee, useLayoutEffect: Ee, useMemo: Ee, useReducer: Ee, useRef: Ee, useState: Ee, useDebugValue: Ee, useDeferredValue: Ee, useTransition: Ee, useMutableSource: Ee, useSyncExternalStore: Ee, useId: Ee, unstable_isNewReconciler: !1 }, wh = { readContext: Ke, useCallback: function (t, e) { return ot().memoizedState = [t, e === void 0 ? null : e], t }, useContext: Ke, useEffect: zu, useImperativeHandle: function (t, e, n) { return n = n != null ? n.concat([t]) : null, Pi(4194308, 4, nf.bind(null, e, t), n) }, useLayoutEffect: function (t, e) { return Pi(4194308, 4, t, e) }, useInsertionEffect: function (t, e) { return Pi(4, 2, t, e) }, useMemo: function (t, e) { var n = ot(); return e = e === void 0 ? null : e, t = t(), n.memoizedState = [t, e], t }, useReducer: function (t, e, n) { var r = ot(); return e = n !== void 0 ? n(e) : e, r.memoizedState = r.baseState = e, t = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: t, lastRenderedState: e }, r.queue = t, t = t.dispatch = gh.bind(null, te, t), [r.memoizedState, t] }, useRef: function (t) { var e = ot(); return t = { current: t }, e.memoizedState = t }, useState: Lu, useDebugValue: oo, useDeferredValue: function (t) { return ot().memoizedState = t }, useTransition: function () { var t = Lu(!1), e = t[0]; return t = hh.bind(null, t[1]), ot().memoizedState = t, [e, t] }, useMutableSource: function () { }, useSyncExternalStore: function (t, e, n) { var r = te, i = ot(); if (J) { if (n === void 0) throw Error(D(407)); n = n() } else { if (n = e(), me === null) throw Error(D(349)); an & 30 || Yd(r, e, n) } i.memoizedState = n; var s = { value: n, getSnapshot: e }; return i.queue = s, zu(Qd.bind(null, r, s, t), [t]), r.flags |= 2048, jr(9, qd.bind(null, r, s, n, e), void 0, null), n }, useId: function () { var t = ot(), e = me.identifierPrefix; if (J) { var n = gt, r = ht; n = (r & ~(1 << 32 - rt(r) - 1)).toString(32) + n, e = ":" + e + "R" + n, n = Rr++, 0 < n && (e += "H" + n.toString(32)), e += ":" } else n = mh++, e = ":" + e + "r" + n.toString(32) + ":"; return t.memoizedState = e }, unstable_isNewReconciler: !1 }, yh = { readContext: Ke, useCallback: sf, useContext: Ke, useEffect: ao, useImperativeHandle: rf, useInsertionEffect: ef, useLayoutEffect: tf, useMemo: lf, useReducer: il, useRef: Jd, useState: function () { return il($r) }, useDebugValue: oo, useDeferredValue: function (t) { var e = Ze(); return af(e, ce.memoizedState, t) }, useTransition: function () { var t = il($r)[0], e = Ze().memoizedState; return [t, e] }, useMutableSource: Xd, useSyncExternalStore: Ud, useId: of, unstable_isNewReconciler: !1 }, Sh = { readContext: Ke, useCallback: sf, useContext: Ke, useEffect: ao, useImperativeHandle: rf, useInsertionEffect: ef, useLayoutEffect: tf, useMemo: lf, useReducer: sl, useRef: Jd, useState: function () { return sl($r) }, useDebugValue: oo, useDeferredValue: function (t) { var e = Ze(); return ce === null ? e.memoizedState = t : af(e, ce.memoizedState, t) }, useTransition: function () { var t = sl($r)[0], e = Ze().memoizedState; return [t, e] }, useMutableSource: Xd, useSyncExternalStore: Ud, useId: of, unstable_isNewReconciler: !1 }; function Fn(t, e) {
  try { var n = "", r = e; do n += Yp(r), r = r.return; while (r); var i = n } catch (s) {
    i = `
Error generating stack: `+ s.message + `
`+ s.stack
  } return { value: t, source: e, stack: i, digest: null }
} function ll(t, e, n) { return { value: t, source: null, stack: n ?? null, digest: e ?? null } } function ea(t, e) { try { console.error(e.value) } catch (n) { setTimeout(function () { throw n }) } } var Eh = typeof WeakMap == "function" ? WeakMap : Map; function ff(t, e, n) { n = vt(-1, n), n.tag = 3, n.payload = { element: null }; var r = e.value; return n.callback = function () { Ji || (Ji = !0, ca = r), ea(t, e) }, n } function pf(t, e, n) { n = vt(-1, n), n.tag = 3; var r = t.type.getDerivedStateFromError; if (typeof r == "function") { var i = e.value; n.payload = function () { return r(i) }, n.callback = function () { ea(t, e) } } var s = t.stateNode; return s !== null && typeof s.componentDidCatch == "function" && (n.callback = function () { ea(t, e), typeof r != "function" && (Rt === null ? Rt = new Set([this]) : Rt.add(this)); var l = e.stack; this.componentDidCatch(e.value, { componentStack: l !== null ? l : "" }) }), n } function Iu(t, e, n) { var r = t.pingCache; if (r === null) { r = t.pingCache = new Eh; var i = new Set; r.set(e, i) } else i = r.get(e), i === void 0 && (i = new Set, r.set(e, i)); i.has(n) || (i.add(n), t = Ah.bind(null, t, e, n), e.then(t, t)) } function Ou(t) { do { var e; if ((e = t.tag === 13) && (e = t.memoizedState, e = e !== null ? e.dehydrated !== null : !0), e) return t; t = t.return } while (t !== null); return null } function Nu(t, e, n, r, i) { return t.mode & 1 ? (t.flags |= 65536, t.lanes = i, t) : (t === e ? t.flags |= 65536 : (t.flags |= 128, n.flags |= 131072, n.flags &= -52805, n.tag === 1 && (n.alternate === null ? n.tag = 17 : (e = vt(-1, 1), e.tag = 2, Dt(n, e, 1))), n.lanes |= 1), t) } var xh = xt.ReactCurrentOwner, Ie = !1; function Pe(t, e, n, r) { e.child = t === null ? Gd(e, null, n, r) : $n(e, t.child, n, r) } function Au(t, e, n, r, i) { n = n.render; var s = e.ref; return On(e, i), r = so(t, e, n, r, s, i), n = lo(), t !== null && !Ie ? (e.updateQueue = t.updateQueue, e.flags &= -2053, t.lanes &= ~i, Et(t, e, i)) : (J && n && Ua(e), e.flags |= 1, Pe(t, e, r, i), e.child) } function Du(t, e, n, r, i) { if (t === null) { var s = n.type; return typeof s == "function" && !vo(s) && s.defaultProps === void 0 && n.compare === null && n.defaultProps === void 0 ? (e.tag = 15, e.type = s, mf(t, e, s, r, i)) : (t = Li(n.type, null, r, e, e.mode, i), t.ref = e.ref, t.return = e, e.child = t) } if (s = t.child, !(t.lanes & i)) { var l = s.memoizedProps; if (n = n.compare, n = n !== null ? n : zr, n(l, r) && t.ref === e.ref) return Et(t, e, i) } return e.flags |= 1, t = jt(s, r), t.ref = e.ref, t.return = e, e.child = t } function mf(t, e, n, r, i) { if (t !== null) { var s = t.memoizedProps; if (zr(s, r) && t.ref === e.ref) if (Ie = !1, e.pendingProps = r = s, (t.lanes & i) !== 0) t.flags & 131072 && (Ie = !0); else return e.lanes = t.lanes, Et(t, e, i) } return ta(t, e, n, r, i) } function hf(t, e, n) { var r = e.pendingProps, i = r.children, s = t !== null ? t.memoizedState : null; if (r.mode === "hidden") if (!(e.mode & 1)) e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Q(Mn, Re), Re |= n; else { if (!(n & 1073741824)) return t = s !== null ? s.baseLanes | n : n, e.lanes = e.childLanes = 1073741824, e.memoizedState = { baseLanes: t, cachePool: null, transitions: null }, e.updateQueue = null, Q(Mn, Re), Re |= t, null; e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, r = s !== null ? s.baseLanes : n, Q(Mn, Re), Re |= r } else s !== null ? (r = s.baseLanes | n, e.memoizedState = null) : r = n, Q(Mn, Re), Re |= r; return Pe(t, e, i, n), e.child } function gf(t, e) { var n = e.ref; (t === null && n !== null || t !== null && t.ref !== n) && (e.flags |= 512, e.flags |= 2097152) } function ta(t, e, n, r, i) { var s = Ne(n) ? sn : Ce.current; return s = Dn(e, s), On(e, i), n = so(t, e, n, r, s, i), r = lo(), t !== null && !Ie ? (e.updateQueue = t.updateQueue, e.flags &= -2053, t.lanes &= ~i, Et(t, e, i)) : (J && r && Ua(e), e.flags |= 1, Pe(t, e, n, i), e.child) } function Ru(t, e, n, r, i) { if (Ne(n)) { var s = !0; Vi(e) } else s = !1; if (On(e, i), e.stateNode === null) ki(t, e), Bd(e, n, r), Jl(e, n, r, i), r = !0; else if (t === null) { var l = e.stateNode, o = e.memoizedProps; l.props = o; var a = l.context, u = n.contextType; typeof u == "object" && u !== null ? u = Ke(u) : (u = Ne(n) ? sn : Ce.current, u = Dn(e, u)); var c = n.getDerivedStateFromProps, d = typeof c == "function" || typeof l.getSnapshotBeforeUpdate == "function"; d || typeof l.UNSAFE_componentWillReceiveProps != "function" && typeof l.componentWillReceiveProps != "function" || (o !== r || a !== u) && Mu(e, l, r, u), Pt = !1; var f = e.memoizedState; l.state = f, Yi(e, r, l, i), a = e.memoizedState, o !== r || f !== a || Oe.current || Pt ? (typeof c == "function" && (Zl(e, n, c, r), a = e.memoizedState), (o = Pt || ku(e, n, o, r, f, a, u)) ? (d || typeof l.UNSAFE_componentWillMount != "function" && typeof l.componentWillMount != "function" || (typeof l.componentWillMount == "function" && l.componentWillMount(), typeof l.UNSAFE_componentWillMount == "function" && l.UNSAFE_componentWillMount()), typeof l.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof l.componentDidMount == "function" && (e.flags |= 4194308), e.memoizedProps = r, e.memoizedState = a), l.props = r, l.state = a, l.context = u, r = o) : (typeof l.componentDidMount == "function" && (e.flags |= 4194308), r = !1) } else { l = e.stateNode, Fd(t, e), o = e.memoizedProps, u = e.type === e.elementType ? o : et(e.type, o), l.props = u, d = e.pendingProps, f = l.context, a = n.contextType, typeof a == "object" && a !== null ? a = Ke(a) : (a = Ne(n) ? sn : Ce.current, a = Dn(e, a)); var v = n.getDerivedStateFromProps; (c = typeof v == "function" || typeof l.getSnapshotBeforeUpdate == "function") || typeof l.UNSAFE_componentWillReceiveProps != "function" && typeof l.componentWillReceiveProps != "function" || (o !== d || f !== a) && Mu(e, l, r, a), Pt = !1, f = e.memoizedState, l.state = f, Yi(e, r, l, i); var g = e.memoizedState; o !== d || f !== g || Oe.current || Pt ? (typeof v == "function" && (Zl(e, n, v, r), g = e.memoizedState), (u = Pt || ku(e, n, u, r, f, g, a) || !1) ? (c || typeof l.UNSAFE_componentWillUpdate != "function" && typeof l.componentWillUpdate != "function" || (typeof l.componentWillUpdate == "function" && l.componentWillUpdate(r, g, a), typeof l.UNSAFE_componentWillUpdate == "function" && l.UNSAFE_componentWillUpdate(r, g, a)), typeof l.componentDidUpdate == "function" && (e.flags |= 4), typeof l.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof l.componentDidUpdate != "function" || o === t.memoizedProps && f === t.memoizedState || (e.flags |= 4), typeof l.getSnapshotBeforeUpdate != "function" || o === t.memoizedProps && f === t.memoizedState || (e.flags |= 1024), e.memoizedProps = r, e.memoizedState = g), l.props = r, l.state = g, l.context = a, r = u) : (typeof l.componentDidUpdate != "function" || o === t.memoizedProps && f === t.memoizedState || (e.flags |= 4), typeof l.getSnapshotBeforeUpdate != "function" || o === t.memoizedProps && f === t.memoizedState || (e.flags |= 1024), r = !1) } return na(t, e, n, r, s, i) } function na(t, e, n, r, i, s) { gf(t, e); var l = (e.flags & 128) !== 0; if (!r && !l) return i && xu(e, n, !1), Et(t, e, s); r = e.stateNode, xh.current = e; var o = l && typeof n.getDerivedStateFromError != "function" ? null : r.render(); return e.flags |= 1, t !== null && l ? (e.child = $n(e, t.child, null, s), e.child = $n(e, null, o, s)) : Pe(t, e, o, s), e.memoizedState = r.state, i && xu(e, n, !0), e.child } function vf(t) { var e = t.stateNode; e.pendingContext ? Eu(t, e.pendingContext, e.pendingContext !== e.context) : e.context && Eu(t, e.context, !1), to(t, e.containerInfo) } function $u(t, e, n, r, i) { return Rn(), qa(i), e.flags |= 256, Pe(t, e, n, r), e.child } var ra = { dehydrated: null, treeContext: null, retryLane: 0 }; function ia(t) { return { baseLanes: t, cachePool: null, transitions: null } } function wf(t, e, n) { var r = e.pendingProps, i = ee.current, s = !1, l = (e.flags & 128) !== 0, o; if ((o = l) || (o = t !== null && t.memoizedState === null ? !1 : (i & 2) !== 0), o ? (s = !0, e.flags &= -129) : (t === null || t.memoizedState !== null) && (i |= 1), Q(ee, i & 1), t === null) return Ql(e), t = e.memoizedState, t !== null && (t = t.dehydrated, t !== null) ? (e.mode & 1 ? t.data === "$!" ? e.lanes = 8 : e.lanes = 1073741824 : e.lanes = 1, null) : (l = r.children, t = r.fallback, s ? (r = e.mode, s = e.child, l = { mode: "hidden", children: l }, !(r & 1) && s !== null ? (s.childLanes = 0, s.pendingProps = l) : s = Ss(l, r, 0, null), t = nn(t, r, n, null), s.return = e, t.return = e, s.sibling = t, e.child = s, e.child.memoizedState = ia(n), e.memoizedState = ra, t) : uo(e, l)); if (i = t.memoizedState, i !== null && (o = i.dehydrated, o !== null)) return Th(t, e, l, r, o, i, n); if (s) { s = r.fallback, l = e.mode, i = t.child, o = i.sibling; var a = { mode: "hidden", children: r.children }; return !(l & 1) && e.child !== i ? (r = e.child, r.childLanes = 0, r.pendingProps = a, e.deletions = null) : (r = jt(i, a), r.subtreeFlags = i.subtreeFlags & 14680064), o !== null ? s = jt(o, s) : (s = nn(s, l, n, null), s.flags |= 2), s.return = e, r.return = e, r.sibling = s, e.child = r, r = s, s = e.child, l = t.child.memoizedState, l = l === null ? ia(n) : { baseLanes: l.baseLanes | n, cachePool: null, transitions: l.transitions }, s.memoizedState = l, s.childLanes = t.childLanes & ~n, e.memoizedState = ra, r } return s = t.child, t = s.sibling, r = jt(s, { mode: "visible", children: r.children }), !(e.mode & 1) && (r.lanes = n), r.return = e, r.sibling = null, t !== null && (n = e.deletions, n === null ? (e.deletions = [t], e.flags |= 16) : n.push(t)), e.child = r, e.memoizedState = null, r } function uo(t, e) { return e = Ss({ mode: "visible", children: e }, t.mode, 0, null), e.return = t, t.child = e } function ci(t, e, n, r) { return r !== null && qa(r), $n(e, t.child, null, n), t = uo(e, e.pendingProps.children), t.flags |= 2, e.memoizedState = null, t } function Th(t, e, n, r, i, s, l) { if (n) return e.flags & 256 ? (e.flags &= -257, r = ll(Error(D(422))), ci(t, e, l, r)) : e.memoizedState !== null ? (e.child = t.child, e.flags |= 128, null) : (s = r.fallback, i = e.mode, r = Ss({ mode: "visible", children: r.children }, i, 0, null), s = nn(s, i, l, null), s.flags |= 2, r.return = e, s.return = e, r.sibling = s, e.child = r, e.mode & 1 && $n(e, t.child, null, l), e.child.memoizedState = ia(l), e.memoizedState = ra, s); if (!(e.mode & 1)) return ci(t, e, l, null); if (i.data === "$!") { if (r = i.nextSibling && i.nextSibling.dataset, r) var o = r.dgst; return r = o, s = Error(D(419)), r = ll(s, r, void 0), ci(t, e, l, r) } if (o = (l & t.childLanes) !== 0, Ie || o) { if (r = me, r !== null) { switch (l & -l) { case 4: i = 2; break; case 16: i = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: i = 32; break; case 536870912: i = 268435456; break; default: i = 0 }i = i & (r.suspendedLanes | l) ? 0 : i, i !== 0 && i !== s.retryLane && (s.retryLane = i, St(t, i), it(r, t, i, -1)) } return go(), r = ll(Error(D(421))), ci(t, e, l, r) } return i.data === "$?" ? (e.flags |= 128, e.child = t.child, e = Dh.bind(null, t), i._reactRetry = e, null) : (t = s.treeContext, Fe = At(i.nextSibling), Be = e, J = !0, nt = null, t !== null && (Xe[Ue++] = ht, Xe[Ue++] = gt, Xe[Ue++] = ln, ht = t.id, gt = t.overflow, ln = e), e = uo(e, r.children), e.flags |= 4096, e) } function ju(t, e, n) { t.lanes |= e; var r = t.alternate; r !== null && (r.lanes |= e), Kl(t.return, e, n) } function al(t, e, n, r, i) { var s = t.memoizedState; s === null ? t.memoizedState = { isBackwards: e, rendering: null, renderingStartTime: 0, last: r, tail: n, tailMode: i } : (s.isBackwards = e, s.rendering = null, s.renderingStartTime = 0, s.last = r, s.tail = n, s.tailMode = i) } function yf(t, e, n) { var r = e.pendingProps, i = r.revealOrder, s = r.tail; if (Pe(t, e, r.children, n), r = ee.current, r & 2) r = r & 1 | 2, e.flags |= 128; else { if (t !== null && t.flags & 128) e: for (t = e.child; t !== null;) { if (t.tag === 13) t.memoizedState !== null && ju(t, n, e); else if (t.tag === 19) ju(t, n, e); else if (t.child !== null) { t.child.return = t, t = t.child; continue } if (t === e) break e; for (; t.sibling === null;) { if (t.return === null || t.return === e) break e; t = t.return } t.sibling.return = t.return, t = t.sibling } r &= 1 } if (Q(ee, r), !(e.mode & 1)) e.memoizedState = null; else switch (i) { case "forwards": for (n = e.child, i = null; n !== null;)t = n.alternate, t !== null && qi(t) === null && (i = n), n = n.sibling; n = i, n === null ? (i = e.child, e.child = null) : (i = n.sibling, n.sibling = null), al(e, !1, i, n, s); break; case "backwards": for (n = null, i = e.child, e.child = null; i !== null;) { if (t = i.alternate, t !== null && qi(t) === null) { e.child = i; break } t = i.sibling, i.sibling = n, n = i, i = t } al(e, !0, n, null, s); break; case "together": al(e, !1, null, null, void 0); break; default: e.memoizedState = null }return e.child } function ki(t, e) { !(e.mode & 1) && t !== null && (t.alternate = null, e.alternate = null, e.flags |= 2) } function Et(t, e, n) { if (t !== null && (e.dependencies = t.dependencies), on |= e.lanes, !(n & e.childLanes)) return null; if (t !== null && e.child !== t.child) throw Error(D(153)); if (e.child !== null) { for (t = e.child, n = jt(t, t.pendingProps), e.child = n, n.return = e; t.sibling !== null;)t = t.sibling, n = n.sibling = jt(t, t.pendingProps), n.return = e; n.sibling = null } return e.child } function bh(t, e, n) { switch (e.tag) { case 3: vf(e), Rn(); break; case 5: Wd(e); break; case 1: Ne(e.type) && Vi(e); break; case 4: to(e, e.stateNode.containerInfo); break; case 10: var r = e.type._context, i = e.memoizedProps.value; Q(Xi, r._currentValue), r._currentValue = i; break; case 13: if (r = e.memoizedState, r !== null) return r.dehydrated !== null ? (Q(ee, ee.current & 1), e.flags |= 128, null) : n & e.child.childLanes ? wf(t, e, n) : (Q(ee, ee.current & 1), t = Et(t, e, n), t !== null ? t.sibling : null); Q(ee, ee.current & 1); break; case 19: if (r = (n & e.childLanes) !== 0, t.flags & 128) { if (r) return yf(t, e, n); e.flags |= 128 } if (i = e.memoizedState, i !== null && (i.rendering = null, i.tail = null, i.lastEffect = null), Q(ee, ee.current), r) break; return null; case 22: case 23: return e.lanes = 0, hf(t, e, n) }return Et(t, e, n) } var Sf, sa, Ef, xf; Sf = function (t, e) { for (var n = e.child; n !== null;) { if (n.tag === 5 || n.tag === 6) t.appendChild(n.stateNode); else if (n.tag !== 4 && n.child !== null) { n.child.return = n, n = n.child; continue } if (n === e) break; for (; n.sibling === null;) { if (n.return === null || n.return === e) return; n = n.return } n.sibling.return = n.return, n = n.sibling } }; sa = function () { }; Ef = function (t, e, n, r) { var i = t.memoizedProps; if (i !== r) { t = e.stateNode, en(dt.current); var s = null; switch (n) { case "input": i = kl(t, i), r = kl(t, r), s = []; break; case "select": i = ne({}, i, { value: void 0 }), r = ne({}, r, { value: void 0 }), s = []; break; case "textarea": i = Ll(t, i), r = Ll(t, r), s = []; break; default: typeof i.onClick != "function" && typeof r.onClick == "function" && (t.onclick = Hi) }Il(n, r); var l; n = null; for (u in i) if (!r.hasOwnProperty(u) && i.hasOwnProperty(u) && i[u] != null) if (u === "style") { var o = i[u]; for (l in o) o.hasOwnProperty(l) && (n || (n = {}), n[l] = "") } else u !== "dangerouslySetInnerHTML" && u !== "children" && u !== "suppressContentEditableWarning" && u !== "suppressHydrationWarning" && u !== "autoFocus" && (br.hasOwnProperty(u) ? s || (s = []) : (s = s || []).push(u, null)); for (u in r) { var a = r[u]; if (o = i != null ? i[u] : void 0, r.hasOwnProperty(u) && a !== o && (a != null || o != null)) if (u === "style") if (o) { for (l in o) !o.hasOwnProperty(l) || a && a.hasOwnProperty(l) || (n || (n = {}), n[l] = ""); for (l in a) a.hasOwnProperty(l) && o[l] !== a[l] && (n || (n = {}), n[l] = a[l]) } else n || (s || (s = []), s.push(u, n)), n = a; else u === "dangerouslySetInnerHTML" ? (a = a ? a.__html : void 0, o = o ? o.__html : void 0, a != null && o !== a && (s = s || []).push(u, a)) : u === "children" ? typeof a != "string" && typeof a != "number" || (s = s || []).push(u, "" + a) : u !== "suppressContentEditableWarning" && u !== "suppressHydrationWarning" && (br.hasOwnProperty(u) ? (a != null && u === "onScroll" && K("scroll", t), s || o === a || (s = [])) : (s = s || []).push(u, a)) } n && (s = s || []).push("style", n); var u = s; (e.updateQueue = u) && (e.flags |= 4) } }; xf = function (t, e, n, r) { n !== r && (e.flags |= 4) }; function rr(t, e) { if (!J) switch (t.tailMode) { case "hidden": e = t.tail; for (var n = null; e !== null;)e.alternate !== null && (n = e), e = e.sibling; n === null ? t.tail = null : n.sibling = null; break; case "collapsed": n = t.tail; for (var r = null; n !== null;)n.alternate !== null && (r = n), n = n.sibling; r === null ? e || t.tail === null ? t.tail = null : t.tail.sibling = null : r.sibling = null } } function xe(t) { var e = t.alternate !== null && t.alternate.child === t.child, n = 0, r = 0; if (e) for (var i = t.child; i !== null;)n |= i.lanes | i.childLanes, r |= i.subtreeFlags & 14680064, r |= i.flags & 14680064, i.return = t, i = i.sibling; else for (i = t.child; i !== null;)n |= i.lanes | i.childLanes, r |= i.subtreeFlags, r |= i.flags, i.return = t, i = i.sibling; return t.subtreeFlags |= r, t.childLanes = n, e } function Ch(t, e, n) { var r = e.pendingProps; switch (Ya(e), e.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return xe(e), null; case 1: return Ne(e.type) && Bi(), xe(e), null; case 3: return r = e.stateNode, jn(), Z(Oe), Z(Ce), ro(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), (t === null || t.child === null) && (oi(e) ? e.flags |= 4 : t === null || t.memoizedState.isDehydrated && !(e.flags & 256) || (e.flags |= 1024, nt !== null && (pa(nt), nt = null))), sa(t, e), xe(e), null; case 5: no(e); var i = en(Dr.current); if (n = e.type, t !== null && e.stateNode != null) Ef(t, e, n, r, i), t.ref !== e.ref && (e.flags |= 512, e.flags |= 2097152); else { if (!r) { if (e.stateNode === null) throw Error(D(166)); return xe(e), null } if (t = en(dt.current), oi(e)) { r = e.stateNode, n = e.type; var s = e.memoizedProps; switch (r[ut] = e, r[Nr] = s, t = (e.mode & 1) !== 0, n) { case "dialog": K("cancel", r), K("close", r); break; case "iframe": case "object": case "embed": K("load", r); break; case "video": case "audio": for (i = 0; i < or.length; i++)K(or[i], r); break; case "source": K("error", r); break; case "img": case "image": case "link": K("error", r), K("load", r); break; case "details": K("toggle", r); break; case "input": Yo(r, s), K("invalid", r); break; case "select": r._wrapperState = { wasMultiple: !!s.multiple }, K("invalid", r); break; case "textarea": Qo(r, s), K("invalid", r) }Il(n, s), i = null; for (var l in s) if (s.hasOwnProperty(l)) { var o = s[l]; l === "children" ? typeof o == "string" ? r.textContent !== o && (s.suppressHydrationWarning !== !0 && ai(r.textContent, o, t), i = ["children", o]) : typeof o == "number" && r.textContent !== "" + o && (s.suppressHydrationWarning !== !0 && ai(r.textContent, o, t), i = ["children", "" + o]) : br.hasOwnProperty(l) && o != null && l === "onScroll" && K("scroll", r) } switch (n) { case "input": Jr(r), qo(r, s, !0); break; case "textarea": Jr(r), Ko(r); break; case "select": case "option": break; default: typeof s.onClick == "function" && (r.onclick = Hi) }r = i, e.updateQueue = r, r !== null && (e.flags |= 4) } else { l = i.nodeType === 9 ? i : i.ownerDocument, t === "http://www.w3.org/1999/xhtml" && (t = Yc(n)), t === "http://www.w3.org/1999/xhtml" ? n === "script" ? (t = l.createElement("div"), t.innerHTML = "<script><\/script>", t = t.removeChild(t.firstChild)) : typeof r.is == "string" ? t = l.createElement(n, { is: r.is }) : (t = l.createElement(n), n === "select" && (l = t, r.multiple ? l.multiple = !0 : r.size && (l.size = r.size))) : t = l.createElementNS(t, n), t[ut] = e, t[Nr] = r, Sf(t, e, !1, !1), e.stateNode = t; e: { switch (l = Ol(n, r), n) { case "dialog": K("cancel", t), K("close", t), i = r; break; case "iframe": case "object": case "embed": K("load", t), i = r; break; case "video": case "audio": for (i = 0; i < or.length; i++)K(or[i], t); i = r; break; case "source": K("error", t), i = r; break; case "img": case "image": case "link": K("error", t), K("load", t), i = r; break; case "details": K("toggle", t), i = r; break; case "input": Yo(t, r), i = kl(t, r), K("invalid", t); break; case "option": i = r; break; case "select": t._wrapperState = { wasMultiple: !!r.multiple }, i = ne({}, r, { value: void 0 }), K("invalid", t); break; case "textarea": Qo(t, r), i = Ll(t, r), K("invalid", t); break; default: i = r }Il(n, i), o = i; for (s in o) if (o.hasOwnProperty(s)) { var a = o[s]; s === "style" ? Kc(t, a) : s === "dangerouslySetInnerHTML" ? (a = a ? a.__html : void 0, a != null && qc(t, a)) : s === "children" ? typeof a == "string" ? (n !== "textarea" || a !== "") && Cr(t, a) : typeof a == "number" && Cr(t, "" + a) : s !== "suppressContentEditableWarning" && s !== "suppressHydrationWarning" && s !== "autoFocus" && (br.hasOwnProperty(s) ? a != null && s === "onScroll" && K("scroll", t) : a != null && Oa(t, s, a, l)) } switch (n) { case "input": Jr(t), qo(t, r, !1); break; case "textarea": Jr(t), Ko(t); break; case "option": r.value != null && t.setAttribute("value", "" + Ft(r.value)); break; case "select": t.multiple = !!r.multiple, s = r.value, s != null ? _n(t, !!r.multiple, s, !1) : r.defaultValue != null && _n(t, !!r.multiple, r.defaultValue, !0); break; default: typeof i.onClick == "function" && (t.onclick = Hi) }switch (n) { case "button": case "input": case "select": case "textarea": r = !!r.autoFocus; break e; case "img": r = !0; break e; default: r = !1 } } r && (e.flags |= 4) } e.ref !== null && (e.flags |= 512, e.flags |= 2097152) } return xe(e), null; case 6: if (t && e.stateNode != null) xf(t, e, t.memoizedProps, r); else { if (typeof r != "string" && e.stateNode === null) throw Error(D(166)); if (n = en(Dr.current), en(dt.current), oi(e)) { if (r = e.stateNode, n = e.memoizedProps, r[ut] = e, (s = r.nodeValue !== n) && (t = Be, t !== null)) switch (t.tag) { case 3: ai(r.nodeValue, n, (t.mode & 1) !== 0); break; case 5: t.memoizedProps.suppressHydrationWarning !== !0 && ai(r.nodeValue, n, (t.mode & 1) !== 0) }s && (e.flags |= 4) } else r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r), r[ut] = e, e.stateNode = r } return xe(e), null; case 13: if (Z(ee), r = e.memoizedState, t === null || t.memoizedState !== null && t.memoizedState.dehydrated !== null) { if (J && Fe !== null && e.mode & 1 && !(e.flags & 128)) $d(), Rn(), e.flags |= 98560, s = !1; else if (s = oi(e), r !== null && r.dehydrated !== null) { if (t === null) { if (!s) throw Error(D(318)); if (s = e.memoizedState, s = s !== null ? s.dehydrated : null, !s) throw Error(D(317)); s[ut] = e } else Rn(), !(e.flags & 128) && (e.memoizedState = null), e.flags |= 4; xe(e), s = !1 } else nt !== null && (pa(nt), nt = null), s = !0; if (!s) return e.flags & 65536 ? e : null } return e.flags & 128 ? (e.lanes = n, e) : (r = r !== null, r !== (t !== null && t.memoizedState !== null) && r && (e.child.flags |= 8192, e.mode & 1 && (t === null || ee.current & 1 ? de === 0 && (de = 3) : go())), e.updateQueue !== null && (e.flags |= 4), xe(e), null); case 4: return jn(), sa(t, e), t === null && Ir(e.stateNode.containerInfo), xe(e), null; case 10: return Za(e.type._context), xe(e), null; case 17: return Ne(e.type) && Bi(), xe(e), null; case 19: if (Z(ee), s = e.memoizedState, s === null) return xe(e), null; if (r = (e.flags & 128) !== 0, l = s.rendering, l === null) if (r) rr(s, !1); else { if (de !== 0 || t !== null && t.flags & 128) for (t = e.child; t !== null;) { if (l = qi(t), l !== null) { for (e.flags |= 128, rr(s, !1), r = l.updateQueue, r !== null && (e.updateQueue = r, e.flags |= 4), e.subtreeFlags = 0, r = n, n = e.child; n !== null;)s = n, t = r, s.flags &= 14680066, l = s.alternate, l === null ? (s.childLanes = 0, s.lanes = t, s.child = null, s.subtreeFlags = 0, s.memoizedProps = null, s.memoizedState = null, s.updateQueue = null, s.dependencies = null, s.stateNode = null) : (s.childLanes = l.childLanes, s.lanes = l.lanes, s.child = l.child, s.subtreeFlags = 0, s.deletions = null, s.memoizedProps = l.memoizedProps, s.memoizedState = l.memoizedState, s.updateQueue = l.updateQueue, s.type = l.type, t = l.dependencies, s.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }), n = n.sibling; return Q(ee, ee.current & 1 | 2), e.child } t = t.sibling } s.tail !== null && le() > Hn && (e.flags |= 128, r = !0, rr(s, !1), e.lanes = 4194304) } else { if (!r) if (t = qi(l), t !== null) { if (e.flags |= 128, r = !0, n = t.updateQueue, n !== null && (e.updateQueue = n, e.flags |= 4), rr(s, !0), s.tail === null && s.tailMode === "hidden" && !l.alternate && !J) return xe(e), null } else 2 * le() - s.renderingStartTime > Hn && n !== 1073741824 && (e.flags |= 128, r = !0, rr(s, !1), e.lanes = 4194304); s.isBackwards ? (l.sibling = e.child, e.child = l) : (n = s.last, n !== null ? n.sibling = l : e.child = l, s.last = l) } return s.tail !== null ? (e = s.tail, s.rendering = e, s.tail = e.sibling, s.renderingStartTime = le(), e.sibling = null, n = ee.current, Q(ee, r ? n & 1 | 2 : n & 1), e) : (xe(e), null); case 22: case 23: return ho(), r = e.memoizedState !== null, t !== null && t.memoizedState !== null !== r && (e.flags |= 8192), r && e.mode & 1 ? Re & 1073741824 && (xe(e), e.subtreeFlags & 6 && (e.flags |= 8192)) : xe(e), null; case 24: return null; case 25: return null }throw Error(D(156, e.tag)) } function Ph(t, e) { switch (Ya(e), e.tag) { case 1: return Ne(e.type) && Bi(), t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, e) : null; case 3: return jn(), Z(Oe), Z(Ce), ro(), t = e.flags, t & 65536 && !(t & 128) ? (e.flags = t & -65537 | 128, e) : null; case 5: return no(e), null; case 13: if (Z(ee), t = e.memoizedState, t !== null && t.dehydrated !== null) { if (e.alternate === null) throw Error(D(340)); Rn() } return t = e.flags, t & 65536 ? (e.flags = t & -65537 | 128, e) : null; case 19: return Z(ee), null; case 4: return jn(), null; case 10: return Za(e.type._context), null; case 22: case 23: return ho(), null; case 24: return null; default: return null } } var di = !1, be = !1, kh = typeof WeakSet == "function" ? WeakSet : Set, $ = null; function kn(t, e) { var n = t.ref; if (n !== null) if (typeof n == "function") try { n(null) } catch (r) { ie(t, e, r) } else n.current = null } function la(t, e, n) { try { n() } catch (r) { ie(t, e, r) } } var Fu = !1; function Mh(t, e) { if (Vl = $i, t = Cd(), Xa(t)) { if ("selectionStart" in t) var n = { start: t.selectionStart, end: t.selectionEnd }; else e: { n = (n = t.ownerDocument) && n.defaultView || window; var r = n.getSelection && n.getSelection(); if (r && r.rangeCount !== 0) { n = r.anchorNode; var i = r.anchorOffset, s = r.focusNode; r = r.focusOffset; try { n.nodeType, s.nodeType } catch { n = null; break e } var l = 0, o = -1, a = -1, u = 0, c = 0, d = t, f = null; t: for (; ;) { for (var v; d !== n || i !== 0 && d.nodeType !== 3 || (o = l + i), d !== s || r !== 0 && d.nodeType !== 3 || (a = l + r), d.nodeType === 3 && (l += d.nodeValue.length), (v = d.firstChild) !== null;)f = d, d = v; for (; ;) { if (d === t) break t; if (f === n && ++u === i && (o = l), f === s && ++c === r && (a = l), (v = d.nextSibling) !== null) break; d = f, f = d.parentNode } d = v } n = o === -1 || a === -1 ? null : { start: o, end: a } } else n = null } n = n || { start: 0, end: 0 } } else n = null; for (Gl = { focusedElem: t, selectionRange: n }, $i = !1, $ = e; $ !== null;)if (e = $, t = e.child, (e.subtreeFlags & 1028) !== 0 && t !== null) t.return = e, $ = t; else for (; $ !== null;) { e = $; try { var g = e.alternate; if (e.flags & 1024) switch (e.tag) { case 0: case 11: case 15: break; case 1: if (g !== null) { var w = g.memoizedProps, y = g.memoizedState, p = e.stateNode, m = p.getSnapshotBeforeUpdate(e.elementType === e.type ? w : et(e.type, w), y); p.__reactInternalSnapshotBeforeUpdate = m } break; case 3: var h = e.stateNode.containerInfo; h.nodeType === 1 ? h.textContent = "" : h.nodeType === 9 && h.documentElement && h.removeChild(h.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(D(163)) } } catch (S) { ie(e, e.return, S) } if (t = e.sibling, t !== null) { t.return = e.return, $ = t; break } $ = e.return } return g = Fu, Fu = !1, g } function wr(t, e, n) { var r = e.updateQueue; if (r = r !== null ? r.lastEffect : null, r !== null) { var i = r = r.next; do { if ((i.tag & t) === t) { var s = i.destroy; i.destroy = void 0, s !== void 0 && la(e, n, s) } i = i.next } while (i !== r) } } function ws(t, e) { if (e = e.updateQueue, e = e !== null ? e.lastEffect : null, e !== null) { var n = e = e.next; do { if ((n.tag & t) === t) { var r = n.create; n.destroy = r() } n = n.next } while (n !== e) } } function aa(t) { var e = t.ref; if (e !== null) { var n = t.stateNode; switch (t.tag) { case 5: t = n; break; default: t = n }typeof e == "function" ? e(t) : e.current = t } } function Tf(t) { var e = t.alternate; e !== null && (t.alternate = null, Tf(e)), t.child = null, t.deletions = null, t.sibling = null, t.tag === 5 && (e = t.stateNode, e !== null && (delete e[ut], delete e[Nr], delete e[Ul], delete e[ch], delete e[dh])), t.stateNode = null, t.return = null, t.dependencies = null, t.memoizedProps = null, t.memoizedState = null, t.pendingProps = null, t.stateNode = null, t.updateQueue = null } function bf(t) { return t.tag === 5 || t.tag === 3 || t.tag === 4 } function Hu(t) { e: for (; ;) { for (; t.sibling === null;) { if (t.return === null || bf(t.return)) return null; t = t.return } for (t.sibling.return = t.return, t = t.sibling; t.tag !== 5 && t.tag !== 6 && t.tag !== 18;) { if (t.flags & 2 || t.child === null || t.tag === 4) continue e; t.child.return = t, t = t.child } if (!(t.flags & 2)) return t.stateNode } } function oa(t, e, n) { var r = t.tag; if (r === 5 || r === 6) t = t.stateNode, e ? n.nodeType === 8 ? n.parentNode.insertBefore(t, e) : n.insertBefore(t, e) : (n.nodeType === 8 ? (e = n.parentNode, e.insertBefore(t, n)) : (e = n, e.appendChild(t)), n = n._reactRootContainer, n != null || e.onclick !== null || (e.onclick = Hi)); else if (r !== 4 && (t = t.child, t !== null)) for (oa(t, e, n), t = t.sibling; t !== null;)oa(t, e, n), t = t.sibling } function ua(t, e, n) { var r = t.tag; if (r === 5 || r === 6) t = t.stateNode, e ? n.insertBefore(t, e) : n.appendChild(t); else if (r !== 4 && (t = t.child, t !== null)) for (ua(t, e, n), t = t.sibling; t !== null;)ua(t, e, n), t = t.sibling } var he = null, tt = !1; function Tt(t, e, n) { for (n = n.child; n !== null;)Cf(t, e, n), n = n.sibling } function Cf(t, e, n) { if (ct && typeof ct.onCommitFiberUnmount == "function") try { ct.onCommitFiberUnmount(cs, n) } catch { } switch (n.tag) { case 5: be || kn(n, e); case 6: var r = he, i = tt; he = null, Tt(t, e, n), he = r, tt = i, he !== null && (tt ? (t = he, n = n.stateNode, t.nodeType === 8 ? t.parentNode.removeChild(n) : t.removeChild(n)) : he.removeChild(n.stateNode)); break; case 18: he !== null && (tt ? (t = he, n = n.stateNode, t.nodeType === 8 ? el(t.parentNode, n) : t.nodeType === 1 && el(t, n), _r(t)) : el(he, n.stateNode)); break; case 4: r = he, i = tt, he = n.stateNode.containerInfo, tt = !0, Tt(t, e, n), he = r, tt = i; break; case 0: case 11: case 14: case 15: if (!be && (r = n.updateQueue, r !== null && (r = r.lastEffect, r !== null))) { i = r = r.next; do { var s = i, l = s.destroy; s = s.tag, l !== void 0 && (s & 2 || s & 4) && la(n, e, l), i = i.next } while (i !== r) } Tt(t, e, n); break; case 1: if (!be && (kn(n, e), r = n.stateNode, typeof r.componentWillUnmount == "function")) try { r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount() } catch (o) { ie(n, e, o) } Tt(t, e, n); break; case 21: Tt(t, e, n); break; case 22: n.mode & 1 ? (be = (r = be) || n.memoizedState !== null, Tt(t, e, n), be = r) : Tt(t, e, n); break; default: Tt(t, e, n) } } function Bu(t) { var e = t.updateQueue; if (e !== null) { t.updateQueue = null; var n = t.stateNode; n === null && (n = t.stateNode = new kh), e.forEach(function (r) { var i = Rh.bind(null, t, r); n.has(r) || (n.add(r), r.then(i, i)) }) } } function Je(t, e) { var n = e.deletions; if (n !== null) for (var r = 0; r < n.length; r++) { var i = n[r]; try { var s = t, l = e, o = l; e: for (; o !== null;) { switch (o.tag) { case 5: he = o.stateNode, tt = !1; break e; case 3: he = o.stateNode.containerInfo, tt = !0; break e; case 4: he = o.stateNode.containerInfo, tt = !0; break e }o = o.return } if (he === null) throw Error(D(160)); Cf(s, l, i), he = null, tt = !1; var a = i.alternate; a !== null && (a.return = null), i.return = null } catch (u) { ie(i, e, u) } } if (e.subtreeFlags & 12854) for (e = e.child; e !== null;)Pf(e, t), e = e.sibling } function Pf(t, e) { var n = t.alternate, r = t.flags; switch (t.tag) { case 0: case 11: case 14: case 15: if (Je(e, t), at(t), r & 4) { try { wr(3, t, t.return), ws(3, t) } catch (w) { ie(t, t.return, w) } try { wr(5, t, t.return) } catch (w) { ie(t, t.return, w) } } break; case 1: Je(e, t), at(t), r & 512 && n !== null && kn(n, n.return); break; case 5: if (Je(e, t), at(t), r & 512 && n !== null && kn(n, n.return), t.flags & 32) { var i = t.stateNode; try { Cr(i, "") } catch (w) { ie(t, t.return, w) } } if (r & 4 && (i = t.stateNode, i != null)) { var s = t.memoizedProps, l = n !== null ? n.memoizedProps : s, o = t.type, a = t.updateQueue; if (t.updateQueue = null, a !== null) try { o === "input" && s.type === "radio" && s.name != null && Xc(i, s), Ol(o, l); var u = Ol(o, s); for (l = 0; l < a.length; l += 2) { var c = a[l], d = a[l + 1]; c === "style" ? Kc(i, d) : c === "dangerouslySetInnerHTML" ? qc(i, d) : c === "children" ? Cr(i, d) : Oa(i, c, d, u) } switch (o) { case "input": Ml(i, s); break; case "textarea": Uc(i, s); break; case "select": var f = i._wrapperState.wasMultiple; i._wrapperState.wasMultiple = !!s.multiple; var v = s.value; v != null ? _n(i, !!s.multiple, v, !1) : f !== !!s.multiple && (s.defaultValue != null ? _n(i, !!s.multiple, s.defaultValue, !0) : _n(i, !!s.multiple, s.multiple ? [] : "", !1)) }i[Nr] = s } catch (w) { ie(t, t.return, w) } } break; case 6: if (Je(e, t), at(t), r & 4) { if (t.stateNode === null) throw Error(D(162)); i = t.stateNode, s = t.memoizedProps; try { i.nodeValue = s } catch (w) { ie(t, t.return, w) } } break; case 3: if (Je(e, t), at(t), r & 4 && n !== null && n.memoizedState.isDehydrated) try { _r(e.containerInfo) } catch (w) { ie(t, t.return, w) } break; case 4: Je(e, t), at(t); break; case 13: Je(e, t), at(t), i = t.child, i.flags & 8192 && (s = i.memoizedState !== null, i.stateNode.isHidden = s, !s || i.alternate !== null && i.alternate.memoizedState !== null || (po = le())), r & 4 && Bu(t); break; case 22: if (c = n !== null && n.memoizedState !== null, t.mode & 1 ? (be = (u = be) || c, Je(e, t), be = u) : Je(e, t), at(t), r & 8192) { if (u = t.memoizedState !== null, (t.stateNode.isHidden = u) && !c && t.mode & 1) for ($ = t, c = t.child; c !== null;) { for (d = $ = c; $ !== null;) { switch (f = $, v = f.child, f.tag) { case 0: case 11: case 14: case 15: wr(4, f, f.return); break; case 1: kn(f, f.return); var g = f.stateNode; if (typeof g.componentWillUnmount == "function") { r = f, n = f.return; try { e = r, g.props = e.memoizedProps, g.state = e.memoizedState, g.componentWillUnmount() } catch (w) { ie(r, n, w) } } break; case 5: kn(f, f.return); break; case 22: if (f.memoizedState !== null) { Gu(d); continue } }v !== null ? (v.return = f, $ = v) : Gu(d) } c = c.sibling } e: for (c = null, d = t; ;) { if (d.tag === 5) { if (c === null) { c = d; try { i = d.stateNode, u ? (s = i.style, typeof s.setProperty == "function" ? s.setProperty("display", "none", "important") : s.display = "none") : (o = d.stateNode, a = d.memoizedProps.style, l = a != null && a.hasOwnProperty("display") ? a.display : null, o.style.display = Qc("display", l)) } catch (w) { ie(t, t.return, w) } } } else if (d.tag === 6) { if (c === null) try { d.stateNode.nodeValue = u ? "" : d.memoizedProps } catch (w) { ie(t, t.return, w) } } else if ((d.tag !== 22 && d.tag !== 23 || d.memoizedState === null || d === t) && d.child !== null) { d.child.return = d, d = d.child; continue } if (d === t) break e; for (; d.sibling === null;) { if (d.return === null || d.return === t) break e; c === d && (c = null), d = d.return } c === d && (c = null), d.sibling.return = d.return, d = d.sibling } } break; case 19: Je(e, t), at(t), r & 4 && Bu(t); break; case 21: break; default: Je(e, t), at(t) } } function at(t) { var e = t.flags; if (e & 2) { try { e: { for (var n = t.return; n !== null;) { if (bf(n)) { var r = n; break e } n = n.return } throw Error(D(160)) } switch (r.tag) { case 5: var i = r.stateNode; r.flags & 32 && (Cr(i, ""), r.flags &= -33); var s = Hu(t); ua(t, s, i); break; case 3: case 4: var l = r.stateNode.containerInfo, o = Hu(t); oa(t, o, l); break; default: throw Error(D(161)) } } catch (a) { ie(t, t.return, a) } t.flags &= -3 } e & 4096 && (t.flags &= -4097) } function _h(t, e, n) { $ = t, kf(t) } function kf(t, e, n) { for (var r = (t.mode & 1) !== 0; $ !== null;) { var i = $, s = i.child; if (i.tag === 22 && r) { var l = i.memoizedState !== null || di; if (!l) { var o = i.alternate, a = o !== null && o.memoizedState !== null || be; o = di; var u = be; if (di = l, (be = a) && !u) for ($ = i; $ !== null;)l = $, a = l.child, l.tag === 22 && l.memoizedState !== null ? Wu(i) : a !== null ? (a.return = l, $ = a) : Wu(i); for (; s !== null;)$ = s, kf(s), s = s.sibling; $ = i, di = o, be = u } Vu(t) } else i.subtreeFlags & 8772 && s !== null ? (s.return = i, $ = s) : Vu(t) } } function Vu(t) { for (; $ !== null;) { var e = $; if (e.flags & 8772) { var n = e.alternate; try { if (e.flags & 8772) switch (e.tag) { case 0: case 11: case 15: be || ws(5, e); break; case 1: var r = e.stateNode; if (e.flags & 4 && !be) if (n === null) r.componentDidMount(); else { var i = e.elementType === e.type ? n.memoizedProps : et(e.type, n.memoizedProps); r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate) } var s = e.updateQueue; s !== null && Pu(e, s, r); break; case 3: var l = e.updateQueue; if (l !== null) { if (n = null, e.child !== null) switch (e.child.tag) { case 5: n = e.child.stateNode; break; case 1: n = e.child.stateNode }Pu(e, l, n) } break; case 5: var o = e.stateNode; if (n === null && e.flags & 4) { n = o; var a = e.memoizedProps; switch (e.type) { case "button": case "input": case "select": case "textarea": a.autoFocus && n.focus(); break; case "img": a.src && (n.src = a.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (e.memoizedState === null) { var u = e.alternate; if (u !== null) { var c = u.memoizedState; if (c !== null) { var d = c.dehydrated; d !== null && _r(d) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(D(163)) }be || e.flags & 512 && aa(e) } catch (f) { ie(e, e.return, f) } } if (e === t) { $ = null; break } if (n = e.sibling, n !== null) { n.return = e.return, $ = n; break } $ = e.return } } function Gu(t) { for (; $ !== null;) { var e = $; if (e === t) { $ = null; break } var n = e.sibling; if (n !== null) { n.return = e.return, $ = n; break } $ = e.return } } function Wu(t) { for (; $ !== null;) { var e = $; try { switch (e.tag) { case 0: case 11: case 15: var n = e.return; try { ws(4, e) } catch (a) { ie(e, n, a) } break; case 1: var r = e.stateNode; if (typeof r.componentDidMount == "function") { var i = e.return; try { r.componentDidMount() } catch (a) { ie(e, i, a) } } var s = e.return; try { aa(e) } catch (a) { ie(e, s, a) } break; case 5: var l = e.return; try { aa(e) } catch (a) { ie(e, l, a) } } } catch (a) { ie(e, e.return, a) } if (e === t) { $ = null; break } var o = e.sibling; if (o !== null) { o.return = e.return, $ = o; break } $ = e.return } } var Lh = Math.ceil, Zi = xt.ReactCurrentDispatcher, co = xt.ReactCurrentOwner, Qe = xt.ReactCurrentBatchConfig, U = 0, me = null, ae = null, ve = 0, Re = 0, Mn = Vt(0), de = 0, Fr = null, on = 0, ys = 0, fo = 0, yr = null, ze = null, po = 0, Hn = 1 / 0, ft = null, Ji = !1, ca = null, Rt = null, fi = !1, Lt = null, es = 0, Sr = 0, da = null, Mi = -1, _i = 0; function ke() { return U & 6 ? le() : Mi !== -1 ? Mi : Mi = le() } function $t(t) { return t.mode & 1 ? U & 2 && ve !== 0 ? ve & -ve : ph.transition !== null ? (_i === 0 && (_i = ud()), _i) : (t = q, t !== 0 || (t = window.event, t = t === void 0 ? 16 : gd(t.type)), t) : 1 } function it(t, e, n, r) { if (50 < Sr) throw Sr = 0, da = null, Error(D(185)); Vr(t, n, r), (!(U & 2) || t !== me) && (t === me && (!(U & 2) && (ys |= n), de === 4 && Mt(t, ve)), Ae(t, r), n === 1 && U === 0 && !(e.mode & 1) && (Hn = le() + 500, hs && Gt())) } function Ae(t, e) { var n = t.callbackNode; pm(t, e); var r = Ri(t, t === me ? ve : 0); if (r === 0) n !== null && eu(n), t.callbackNode = null, t.callbackPriority = 0; else if (e = r & -r, t.callbackPriority !== e) { if (n != null && eu(n), e === 1) t.tag === 0 ? fh(Xu.bind(null, t)) : Ad(Xu.bind(null, t)), oh(function () { !(U & 6) && Gt() }), n = null; else { switch (cd(r)) { case 1: n = $a; break; case 4: n = ad; break; case 16: n = Di; break; case 536870912: n = od; break; default: n = Di }n = Af(n, Mf.bind(null, t)) } t.callbackPriority = e, t.callbackNode = n } } function Mf(t, e) { if (Mi = -1, _i = 0, U & 6) throw Error(D(327)); var n = t.callbackNode; if (Nn() && t.callbackNode !== n) return null; var r = Ri(t, t === me ? ve : 0); if (r === 0) return null; if (r & 30 || r & t.expiredLanes || e) e = ts(t, r); else { e = r; var i = U; U |= 2; var s = Lf(); (me !== t || ve !== e) && (ft = null, Hn = le() + 500, tn(t, e)); do try { Oh(); break } catch (o) { _f(t, o) } while (!0); Ka(), Zi.current = s, U = i, ae !== null ? e = 0 : (me = null, ve = 0, e = de) } if (e !== 0) { if (e === 2 && (i = $l(t), i !== 0 && (r = i, e = fa(t, i))), e === 1) throw n = Fr, tn(t, 0), Mt(t, r), Ae(t, le()), n; if (e === 6) Mt(t, r); else { if (i = t.current.alternate, !(r & 30) && !zh(i) && (e = ts(t, r), e === 2 && (s = $l(t), s !== 0 && (r = s, e = fa(t, s))), e === 1)) throw n = Fr, tn(t, 0), Mt(t, r), Ae(t, le()), n; switch (t.finishedWork = i, t.finishedLanes = r, e) { case 0: case 1: throw Error(D(345)); case 2: qt(t, ze, ft); break; case 3: if (Mt(t, r), (r & 130023424) === r && (e = po + 500 - le(), 10 < e)) { if (Ri(t, 0) !== 0) break; if (i = t.suspendedLanes, (i & r) !== r) { ke(), t.pingedLanes |= t.suspendedLanes & i; break } t.timeoutHandle = Xl(qt.bind(null, t, ze, ft), e); break } qt(t, ze, ft); break; case 4: if (Mt(t, r), (r & 4194240) === r) break; for (e = t.eventTimes, i = -1; 0 < r;) { var l = 31 - rt(r); s = 1 << l, l = e[l], l > i && (i = l), r &= ~s } if (r = i, r = le() - r, r = (120 > r ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * Lh(r / 1960)) - r, 10 < r) { t.timeoutHandle = Xl(qt.bind(null, t, ze, ft), r); break } qt(t, ze, ft); break; case 5: qt(t, ze, ft); break; default: throw Error(D(329)) } } } return Ae(t, le()), t.callbackNode === n ? Mf.bind(null, t) : null } function fa(t, e) { var n = yr; return t.current.memoizedState.isDehydrated && (tn(t, e).flags |= 256), t = ts(t, e), t !== 2 && (e = ze, ze = n, e !== null && pa(e)), t } function pa(t) { ze === null ? ze = t : ze.push.apply(ze, t) } function zh(t) { for (var e = t; ;) { if (e.flags & 16384) { var n = e.updateQueue; if (n !== null && (n = n.stores, n !== null)) for (var r = 0; r < n.length; r++) { var i = n[r], s = i.getSnapshot; i = i.value; try { if (!st(s(), i)) return !1 } catch { return !1 } } } if (n = e.child, e.subtreeFlags & 16384 && n !== null) n.return = e, e = n; else { if (e === t) break; for (; e.sibling === null;) { if (e.return === null || e.return === t) return !0; e = e.return } e.sibling.return = e.return, e = e.sibling } } return !0 } function Mt(t, e) { for (e &= ~fo, e &= ~ys, t.suspendedLanes |= e, t.pingedLanes &= ~e, t = t.expirationTimes; 0 < e;) { var n = 31 - rt(e), r = 1 << n; t[n] = -1, e &= ~r } } function Xu(t) { if (U & 6) throw Error(D(327)); Nn(); var e = Ri(t, 0); if (!(e & 1)) return Ae(t, le()), null; var n = ts(t, e); if (t.tag !== 0 && n === 2) { var r = $l(t); r !== 0 && (e = r, n = fa(t, r)) } if (n === 1) throw n = Fr, tn(t, 0), Mt(t, e), Ae(t, le()), n; if (n === 6) throw Error(D(345)); return t.finishedWork = t.current.alternate, t.finishedLanes = e, qt(t, ze, ft), Ae(t, le()), null } function mo(t, e) { var n = U; U |= 1; try { return t(e) } finally { U = n, U === 0 && (Hn = le() + 500, hs && Gt()) } } function un(t) { Lt !== null && Lt.tag === 0 && !(U & 6) && Nn(); var e = U; U |= 1; var n = Qe.transition, r = q; try { if (Qe.transition = null, q = 1, t) return t() } finally { q = r, Qe.transition = n, U = e, !(U & 6) && Gt() } } function ho() { Re = Mn.current, Z(Mn) } function tn(t, e) { t.finishedWork = null, t.finishedLanes = 0; var n = t.timeoutHandle; if (n !== -1 && (t.timeoutHandle = -1, ah(n)), ae !== null) for (n = ae.return; n !== null;) { var r = n; switch (Ya(r), r.tag) { case 1: r = r.type.childContextTypes, r != null && Bi(); break; case 3: jn(), Z(Oe), Z(Ce), ro(); break; case 5: no(r); break; case 4: jn(); break; case 13: Z(ee); break; case 19: Z(ee); break; case 10: Za(r.type._context); break; case 22: case 23: ho() }n = n.return } if (me = t, ae = t = jt(t.current, null), ve = Re = e, de = 0, Fr = null, fo = ys = on = 0, ze = yr = null, Jt !== null) { for (e = 0; e < Jt.length; e++)if (n = Jt[e], r = n.interleaved, r !== null) { n.interleaved = null; var i = r.next, s = n.pending; if (s !== null) { var l = s.next; s.next = i, r.next = l } n.pending = r } Jt = null } return t } function _f(t, e) { do { var n = ae; try { if (Ka(), Ci.current = Ki, Qi) { for (var r = te.memoizedState; r !== null;) { var i = r.queue; i !== null && (i.pending = null), r = r.next } Qi = !1 } if (an = 0, pe = ce = te = null, vr = !1, Rr = 0, co.current = null, n === null || n.return === null) { de = 1, Fr = e, ae = null; break } e: { var s = t, l = n.return, o = n, a = e; if (e = ve, o.flags |= 32768, a !== null && typeof a == "object" && typeof a.then == "function") { var u = a, c = o, d = c.tag; if (!(c.mode & 1) && (d === 0 || d === 11 || d === 15)) { var f = c.alternate; f ? (c.updateQueue = f.updateQueue, c.memoizedState = f.memoizedState, c.lanes = f.lanes) : (c.updateQueue = null, c.memoizedState = null) } var v = Ou(l); if (v !== null) { v.flags &= -257, Nu(v, l, o, s, e), v.mode & 1 && Iu(s, u, e), e = v, a = u; var g = e.updateQueue; if (g === null) { var w = new Set; w.add(a), e.updateQueue = w } else g.add(a); break e } else { if (!(e & 1)) { Iu(s, u, e), go(); break e } a = Error(D(426)) } } else if (J && o.mode & 1) { var y = Ou(l); if (y !== null) { !(y.flags & 65536) && (y.flags |= 256), Nu(y, l, o, s, e), qa(Fn(a, o)); break e } } s = a = Fn(a, o), de !== 4 && (de = 2), yr === null ? yr = [s] : yr.push(s), s = l; do { switch (s.tag) { case 3: s.flags |= 65536, e &= -e, s.lanes |= e; var p = ff(s, a, e); Cu(s, p); break e; case 1: o = a; var m = s.type, h = s.stateNode; if (!(s.flags & 128) && (typeof m.getDerivedStateFromError == "function" || h !== null && typeof h.componentDidCatch == "function" && (Rt === null || !Rt.has(h)))) { s.flags |= 65536, e &= -e, s.lanes |= e; var S = pf(s, o, e); Cu(s, S); break e } }s = s.return } while (s !== null) } If(n) } catch (x) { e = x, ae === n && n !== null && (ae = n = n.return); continue } break } while (!0) } function Lf() { var t = Zi.current; return Zi.current = Ki, t === null ? Ki : t } function go() { (de === 0 || de === 3 || de === 2) && (de = 4), me === null || !(on & 268435455) && !(ys & 268435455) || Mt(me, ve) } function ts(t, e) { var n = U; U |= 2; var r = Lf(); (me !== t || ve !== e) && (ft = null, tn(t, e)); do try { Ih(); break } catch (i) { _f(t, i) } while (!0); if (Ka(), U = n, Zi.current = r, ae !== null) throw Error(D(261)); return me = null, ve = 0, de } function Ih() { for (; ae !== null;)zf(ae) } function Oh() { for (; ae !== null && !im();)zf(ae) } function zf(t) { var e = Nf(t.alternate, t, Re); t.memoizedProps = t.pendingProps, e === null ? If(t) : ae = e, co.current = null } function If(t) { var e = t; do { var n = e.alternate; if (t = e.return, e.flags & 32768) { if (n = Ph(n, e), n !== null) { n.flags &= 32767, ae = n; return } if (t !== null) t.flags |= 32768, t.subtreeFlags = 0, t.deletions = null; else { de = 6, ae = null; return } } else if (n = Ch(n, e, Re), n !== null) { ae = n; return } if (e = e.sibling, e !== null) { ae = e; return } ae = e = t } while (e !== null); de === 0 && (de = 5) } function qt(t, e, n) { var r = q, i = Qe.transition; try { Qe.transition = null, q = 1, Nh(t, e, n, r) } finally { Qe.transition = i, q = r } return null } function Nh(t, e, n, r) { do Nn(); while (Lt !== null); if (U & 6) throw Error(D(327)); n = t.finishedWork; var i = t.finishedLanes; if (n === null) return null; if (t.finishedWork = null, t.finishedLanes = 0, n === t.current) throw Error(D(177)); t.callbackNode = null, t.callbackPriority = 0; var s = n.lanes | n.childLanes; if (mm(t, s), t === me && (ae = me = null, ve = 0), !(n.subtreeFlags & 2064) && !(n.flags & 2064) || fi || (fi = !0, Af(Di, function () { return Nn(), null })), s = (n.flags & 15990) !== 0, n.subtreeFlags & 15990 || s) { s = Qe.transition, Qe.transition = null; var l = q; q = 1; var o = U; U |= 4, co.current = null, Mh(t, n), Pf(n, t), eh(Gl), $i = !!Vl, Gl = Vl = null, t.current = n, _h(n), sm(), U = o, q = l, Qe.transition = s } else t.current = n; if (fi && (fi = !1, Lt = t, es = i), s = t.pendingLanes, s === 0 && (Rt = null), om(n.stateNode), Ae(t, le()), e !== null) for (r = t.onRecoverableError, n = 0; n < e.length; n++)i = e[n], r(i.value, { componentStack: i.stack, digest: i.digest }); if (Ji) throw Ji = !1, t = ca, ca = null, t; return es & 1 && t.tag !== 0 && Nn(), s = t.pendingLanes, s & 1 ? t === da ? Sr++ : (Sr = 0, da = t) : Sr = 0, Gt(), null } function Nn() { if (Lt !== null) { var t = cd(es), e = Qe.transition, n = q; try { if (Qe.transition = null, q = 16 > t ? 16 : t, Lt === null) var r = !1; else { if (t = Lt, Lt = null, es = 0, U & 6) throw Error(D(331)); var i = U; for (U |= 4, $ = t.current; $ !== null;) { var s = $, l = s.child; if ($.flags & 16) { var o = s.deletions; if (o !== null) { for (var a = 0; a < o.length; a++) { var u = o[a]; for ($ = u; $ !== null;) { var c = $; switch (c.tag) { case 0: case 11: case 15: wr(8, c, s) }var d = c.child; if (d !== null) d.return = c, $ = d; else for (; $ !== null;) { c = $; var f = c.sibling, v = c.return; if (Tf(c), c === u) { $ = null; break } if (f !== null) { f.return = v, $ = f; break } $ = v } } } var g = s.alternate; if (g !== null) { var w = g.child; if (w !== null) { g.child = null; do { var y = w.sibling; w.sibling = null, w = y } while (w !== null) } } $ = s } } if (s.subtreeFlags & 2064 && l !== null) l.return = s, $ = l; else e: for (; $ !== null;) { if (s = $, s.flags & 2048) switch (s.tag) { case 0: case 11: case 15: wr(9, s, s.return) }var p = s.sibling; if (p !== null) { p.return = s.return, $ = p; break e } $ = s.return } } var m = t.current; for ($ = m; $ !== null;) { l = $; var h = l.child; if (l.subtreeFlags & 2064 && h !== null) h.return = l, $ = h; else e: for (l = m; $ !== null;) { if (o = $, o.flags & 2048) try { switch (o.tag) { case 0: case 11: case 15: ws(9, o) } } catch (x) { ie(o, o.return, x) } if (o === l) { $ = null; break e } var S = o.sibling; if (S !== null) { S.return = o.return, $ = S; break e } $ = o.return } } if (U = i, Gt(), ct && typeof ct.onPostCommitFiberRoot == "function") try { ct.onPostCommitFiberRoot(cs, t) } catch { } r = !0 } return r } finally { q = n, Qe.transition = e } } return !1 } function Uu(t, e, n) { e = Fn(n, e), e = ff(t, e, 1), t = Dt(t, e, 1), e = ke(), t !== null && (Vr(t, 1, e), Ae(t, e)) } function ie(t, e, n) { if (t.tag === 3) Uu(t, t, n); else for (; e !== null;) { if (e.tag === 3) { Uu(e, t, n); break } else if (e.tag === 1) { var r = e.stateNode; if (typeof e.type.getDerivedStateFromError == "function" || typeof r.componentDidCatch == "function" && (Rt === null || !Rt.has(r))) { t = Fn(n, t), t = pf(e, t, 1), e = Dt(e, t, 1), t = ke(), e !== null && (Vr(e, 1, t), Ae(e, t)); break } } e = e.return } } function Ah(t, e, n) { var r = t.pingCache; r !== null && r.delete(e), e = ke(), t.pingedLanes |= t.suspendedLanes & n, me === t && (ve & n) === n && (de === 4 || de === 3 && (ve & 130023424) === ve && 500 > le() - po ? tn(t, 0) : fo |= n), Ae(t, e) } function Of(t, e) { e === 0 && (t.mode & 1 ? (e = ni, ni <<= 1, !(ni & 130023424) && (ni = 4194304)) : e = 1); var n = ke(); t = St(t, e), t !== null && (Vr(t, e, n), Ae(t, n)) } function Dh(t) { var e = t.memoizedState, n = 0; e !== null && (n = e.retryLane), Of(t, n) } function Rh(t, e) { var n = 0; switch (t.tag) { case 13: var r = t.stateNode, i = t.memoizedState; i !== null && (n = i.retryLane); break; case 19: r = t.stateNode; break; default: throw Error(D(314)) }r !== null && r.delete(e), Of(t, n) } var Nf; Nf = function (t, e, n) { if (t !== null) if (t.memoizedProps !== e.pendingProps || Oe.current) Ie = !0; else { if (!(t.lanes & n) && !(e.flags & 128)) return Ie = !1, bh(t, e, n); Ie = !!(t.flags & 131072) } else Ie = !1, J && e.flags & 1048576 && Dd(e, Wi, e.index); switch (e.lanes = 0, e.tag) { case 2: var r = e.type; ki(t, e), t = e.pendingProps; var i = Dn(e, Ce.current); On(e, n), i = so(null, e, r, t, i, n); var s = lo(); return e.flags |= 1, typeof i == "object" && i !== null && typeof i.render == "function" && i.$$typeof === void 0 ? (e.tag = 1, e.memoizedState = null, e.updateQueue = null, Ne(r) ? (s = !0, Vi(e)) : s = !1, e.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null, eo(e), i.updater = gs, e.stateNode = i, i._reactInternals = e, Jl(e, r, t, n), e = na(null, e, r, !0, s, n)) : (e.tag = 0, J && s && Ua(e), Pe(null, e, i, n), e = e.child), e; case 16: r = e.elementType; e: { switch (ki(t, e), t = e.pendingProps, i = r._init, r = i(r._payload), e.type = r, i = e.tag = jh(r), t = et(r, t), i) { case 0: e = ta(null, e, r, t, n); break e; case 1: e = Ru(null, e, r, t, n); break e; case 11: e = Au(null, e, r, t, n); break e; case 14: e = Du(null, e, r, et(r.type, t), n); break e }throw Error(D(306, r, "")) } return e; case 0: return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : et(r, i), ta(t, e, r, i, n); case 1: return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : et(r, i), Ru(t, e, r, i, n); case 3: e: { if (vf(e), t === null) throw Error(D(387)); r = e.pendingProps, s = e.memoizedState, i = s.element, Fd(t, e), Yi(e, r, null, n); var l = e.memoizedState; if (r = l.element, s.isDehydrated) if (s = { element: r, isDehydrated: !1, cache: l.cache, pendingSuspenseBoundaries: l.pendingSuspenseBoundaries, transitions: l.transitions }, e.updateQueue.baseState = s, e.memoizedState = s, e.flags & 256) { i = Fn(Error(D(423)), e), e = $u(t, e, r, n, i); break e } else if (r !== i) { i = Fn(Error(D(424)), e), e = $u(t, e, r, n, i); break e } else for (Fe = At(e.stateNode.containerInfo.firstChild), Be = e, J = !0, nt = null, n = Gd(e, null, r, n), e.child = n; n;)n.flags = n.flags & -3 | 4096, n = n.sibling; else { if (Rn(), r === i) { e = Et(t, e, n); break e } Pe(t, e, r, n) } e = e.child } return e; case 5: return Wd(e), t === null && Ql(e), r = e.type, i = e.pendingProps, s = t !== null ? t.memoizedProps : null, l = i.children, Wl(r, i) ? l = null : s !== null && Wl(r, s) && (e.flags |= 32), gf(t, e), Pe(t, e, l, n), e.child; case 6: return t === null && Ql(e), null; case 13: return wf(t, e, n); case 4: return to(e, e.stateNode.containerInfo), r = e.pendingProps, t === null ? e.child = $n(e, null, r, n) : Pe(t, e, r, n), e.child; case 11: return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : et(r, i), Au(t, e, r, i, n); case 7: return Pe(t, e, e.pendingProps, n), e.child; case 8: return Pe(t, e, e.pendingProps.children, n), e.child; case 12: return Pe(t, e, e.pendingProps.children, n), e.child; case 10: e: { if (r = e.type._context, i = e.pendingProps, s = e.memoizedProps, l = i.value, Q(Xi, r._currentValue), r._currentValue = l, s !== null) if (st(s.value, l)) { if (s.children === i.children && !Oe.current) { e = Et(t, e, n); break e } } else for (s = e.child, s !== null && (s.return = e); s !== null;) { var o = s.dependencies; if (o !== null) { l = s.child; for (var a = o.firstContext; a !== null;) { if (a.context === r) { if (s.tag === 1) { a = vt(-1, n & -n), a.tag = 2; var u = s.updateQueue; if (u !== null) { u = u.shared; var c = u.pending; c === null ? a.next = a : (a.next = c.next, c.next = a), u.pending = a } } s.lanes |= n, a = s.alternate, a !== null && (a.lanes |= n), Kl(s.return, n, e), o.lanes |= n; break } a = a.next } } else if (s.tag === 10) l = s.type === e.type ? null : s.child; else if (s.tag === 18) { if (l = s.return, l === null) throw Error(D(341)); l.lanes |= n, o = l.alternate, o !== null && (o.lanes |= n), Kl(l, n, e), l = s.sibling } else l = s.child; if (l !== null) l.return = s; else for (l = s; l !== null;) { if (l === e) { l = null; break } if (s = l.sibling, s !== null) { s.return = l.return, l = s; break } l = l.return } s = l } Pe(t, e, i.children, n), e = e.child } return e; case 9: return i = e.type, r = e.pendingProps.children, On(e, n), i = Ke(i), r = r(i), e.flags |= 1, Pe(t, e, r, n), e.child; case 14: return r = e.type, i = et(r, e.pendingProps), i = et(r.type, i), Du(t, e, r, i, n); case 15: return mf(t, e, e.type, e.pendingProps, n); case 17: return r = e.type, i = e.pendingProps, i = e.elementType === r ? i : et(r, i), ki(t, e), e.tag = 1, Ne(r) ? (t = !0, Vi(e)) : t = !1, On(e, n), Bd(e, r, i), Jl(e, r, i, n), na(null, e, r, !0, t, n); case 19: return yf(t, e, n); case 22: return hf(t, e, n) }throw Error(D(156, e.tag)) }; function Af(t, e) { return ld(t, e) } function $h(t, e, n, r) { this.tag = t, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = e, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function qe(t, e, n, r) { return new $h(t, e, n, r) } function vo(t) { return t = t.prototype, !(!t || !t.isReactComponent) } function jh(t) { if (typeof t == "function") return vo(t) ? 1 : 0; if (t != null) { if (t = t.$$typeof, t === Aa) return 11; if (t === Da) return 14 } return 2 } function jt(t, e) { var n = t.alternate; return n === null ? (n = qe(t.tag, e, t.key, t.mode), n.elementType = t.elementType, n.type = t.type, n.stateNode = t.stateNode, n.alternate = t, t.alternate = n) : (n.pendingProps = e, n.type = t.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = t.flags & 14680064, n.childLanes = t.childLanes, n.lanes = t.lanes, n.child = t.child, n.memoizedProps = t.memoizedProps, n.memoizedState = t.memoizedState, n.updateQueue = t.updateQueue, e = t.dependencies, n.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }, n.sibling = t.sibling, n.index = t.index, n.ref = t.ref, n } function Li(t, e, n, r, i, s) { var l = 2; if (r = t, typeof t == "function") vo(t) && (l = 1); else if (typeof t == "string") l = 5; else e: switch (t) { case wn: return nn(n.children, i, s, e); case Na: l = 8, i |= 8; break; case Tl: return t = qe(12, n, e, i | 2), t.elementType = Tl, t.lanes = s, t; case bl: return t = qe(13, n, e, i), t.elementType = bl, t.lanes = s, t; case Cl: return t = qe(19, n, e, i), t.elementType = Cl, t.lanes = s, t; case Vc: return Ss(n, i, s, e); default: if (typeof t == "object" && t !== null) switch (t.$$typeof) { case Hc: l = 10; break e; case Bc: l = 9; break e; case Aa: l = 11; break e; case Da: l = 14; break e; case Ct: l = 16, r = null; break e }throw Error(D(130, t == null ? t : typeof t, "")) }return e = qe(l, n, e, i), e.elementType = t, e.type = r, e.lanes = s, e } function nn(t, e, n, r) { return t = qe(7, t, r, e), t.lanes = n, t } function Ss(t, e, n, r) { return t = qe(22, t, r, e), t.elementType = Vc, t.lanes = n, t.stateNode = { isHidden: !1 }, t } function ol(t, e, n) { return t = qe(6, t, null, e), t.lanes = n, t } function ul(t, e, n) { return e = qe(4, t.children !== null ? t.children : [], t.key, e), e.lanes = n, e.stateNode = { containerInfo: t.containerInfo, pendingChildren: null, implementation: t.implementation }, e } function Fh(t, e, n, r, i) { this.tag = e, this.containerInfo = t, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Vs(0), this.expirationTimes = Vs(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Vs(0), this.identifierPrefix = r, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null } function wo(t, e, n, r, i, s, l, o, a) { return t = new Fh(t, e, n, o, a), e === 1 ? (e = 1, s === !0 && (e |= 8)) : e = 0, s = qe(3, null, null, e), t.current = s, s.stateNode = t, s.memoizedState = { element: r, isDehydrated: n, cache: null, transitions: null, pendingSuspenseBoundaries: null }, eo(s), t } function Hh(t, e, n) { var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: vn, key: r == null ? null : "" + r, children: t, containerInfo: e, implementation: n } } function Df(t) { if (!t) return Ht; t = t._reactInternals; e: { if (fn(t) !== t || t.tag !== 1) throw Error(D(170)); var e = t; do { switch (e.tag) { case 3: e = e.stateNode.context; break e; case 1: if (Ne(e.type)) { e = e.stateNode.__reactInternalMemoizedMergedChildContext; break e } }e = e.return } while (e !== null); throw Error(D(171)) } if (t.tag === 1) { var n = t.type; if (Ne(n)) return Nd(t, n, e) } return e } function Rf(t, e, n, r, i, s, l, o, a) { return t = wo(n, r, !0, t, i, s, l, o, a), t.context = Df(null), n = t.current, r = ke(), i = $t(n), s = vt(r, i), s.callback = e ?? null, Dt(n, s, i), t.current.lanes = i, Vr(t, i, r), Ae(t, r), t } function Es(t, e, n, r) { var i = e.current, s = ke(), l = $t(i); return n = Df(n), e.context === null ? e.context = n : e.pendingContext = n, e = vt(s, l), e.payload = { element: t }, r = r === void 0 ? null : r, r !== null && (e.callback = r), t = Dt(i, e, l), t !== null && (it(t, i, l, s), bi(t, i, l)), l } function ns(t) { if (t = t.current, !t.child) return null; switch (t.child.tag) { case 5: return t.child.stateNode; default: return t.child.stateNode } } function Yu(t, e) { if (t = t.memoizedState, t !== null && t.dehydrated !== null) { var n = t.retryLane; t.retryLane = n !== 0 && n < e ? n : e } } function yo(t, e) { Yu(t, e), (t = t.alternate) && Yu(t, e) } function Bh() { return null } var $f = typeof reportError == "function" ? reportError : function (t) { console.error(t) }; function So(t) { this._internalRoot = t } xs.prototype.render = So.prototype.render = function (t) { var e = this._internalRoot; if (e === null) throw Error(D(409)); Es(t, e, null, null) }; xs.prototype.unmount = So.prototype.unmount = function () { var t = this._internalRoot; if (t !== null) { this._internalRoot = null; var e = t.containerInfo; un(function () { Es(null, t, null, null) }), e[yt] = null } }; function xs(t) { this._internalRoot = t } xs.prototype.unstable_scheduleHydration = function (t) { if (t) { var e = pd(); t = { blockedOn: null, target: t, priority: e }; for (var n = 0; n < kt.length && e !== 0 && e < kt[n].priority; n++); kt.splice(n, 0, t), n === 0 && hd(t) } }; function Eo(t) { return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11) } function Ts(t) { return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11 && (t.nodeType !== 8 || t.nodeValue !== " react-mount-point-unstable ")) } function qu() { } function Vh(t, e, n, r, i) { if (i) { if (typeof r == "function") { var s = r; r = function () { var u = ns(l); s.call(u) } } var l = Rf(e, r, t, 0, null, !1, !1, "", qu); return t._reactRootContainer = l, t[yt] = l.current, Ir(t.nodeType === 8 ? t.parentNode : t), un(), l } for (; i = t.lastChild;)t.removeChild(i); if (typeof r == "function") { var o = r; r = function () { var u = ns(a); o.call(u) } } var a = wo(t, 0, !1, null, null, !1, !1, "", qu); return t._reactRootContainer = a, t[yt] = a.current, Ir(t.nodeType === 8 ? t.parentNode : t), un(function () { Es(e, a, n, r) }), a } function bs(t, e, n, r, i) { var s = n._reactRootContainer; if (s) { var l = s; if (typeof i == "function") { var o = i; i = function () { var a = ns(l); o.call(a) } } Es(e, l, t, i) } else l = Vh(n, e, t, i, r); return ns(l) } dd = function (t) { switch (t.tag) { case 3: var e = t.stateNode; if (e.current.memoizedState.isDehydrated) { var n = ar(e.pendingLanes); n !== 0 && (ja(e, n | 1), Ae(e, le()), !(U & 6) && (Hn = le() + 500, Gt())) } break; case 13: un(function () { var r = St(t, 1); if (r !== null) { var i = ke(); it(r, t, 1, i) } }), yo(t, 1) } }; Fa = function (t) { if (t.tag === 13) { var e = St(t, 134217728); if (e !== null) { var n = ke(); it(e, t, 134217728, n) } yo(t, 134217728) } }; fd = function (t) { if (t.tag === 13) { var e = $t(t), n = St(t, e); if (n !== null) { var r = ke(); it(n, t, e, r) } yo(t, e) } }; pd = function () { return q }; md = function (t, e) { var n = q; try { return q = t, e() } finally { q = n } }; Al = function (t, e, n) { switch (e) { case "input": if (Ml(t, n), e = n.name, n.type === "radio" && e != null) { for (n = t; n.parentNode;)n = n.parentNode; for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'), e = 0; e < n.length; e++) { var r = n[e]; if (r !== t && r.form === t.form) { var i = ms(r); if (!i) throw Error(D(90)); Wc(r), Ml(r, i) } } } break; case "textarea": Uc(t, n); break; case "select": e = n.value, e != null && _n(t, !!n.multiple, e, !1) } }; ed = mo; td = un; var Gh = { usingClientEntryPoint: !1, Events: [Wr, xn, ms, Zc, Jc, mo] }, ir = { findFiberByHostInstance: Zt, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, Wh = { bundleType: ir.bundleType, version: ir.version, rendererPackageName: ir.rendererPackageName, rendererConfig: ir.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: xt.ReactCurrentDispatcher, findHostInstanceByFiber: function (t) { return t = id(t), t === null ? null : t.stateNode }, findFiberByHostInstance: ir.findFiberByHostInstance || Bh, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var pi = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!pi.isDisabled && pi.supportsFiber) try { cs = pi.inject(Wh), ct = pi } catch { } } Ge.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Gh; Ge.createPortal = function (t, e) { var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!Eo(e)) throw Error(D(200)); return Hh(t, e, null, n) }; Ge.createRoot = function (t, e) { if (!Eo(t)) throw Error(D(299)); var n = !1, r = "", i = $f; return e != null && (e.unstable_strictMode === !0 && (n = !0), e.identifierPrefix !== void 0 && (r = e.identifierPrefix), e.onRecoverableError !== void 0 && (i = e.onRecoverableError)), e = wo(t, 1, !1, null, null, n, !1, r, i), t[yt] = e.current, Ir(t.nodeType === 8 ? t.parentNode : t), new So(e) }; Ge.findDOMNode = function (t) { if (t == null) return null; if (t.nodeType === 1) return t; var e = t._reactInternals; if (e === void 0) throw typeof t.render == "function" ? Error(D(188)) : (t = Object.keys(t).join(","), Error(D(268, t))); return t = id(e), t = t === null ? null : t.stateNode, t }; Ge.flushSync = function (t) { return un(t) }; Ge.hydrate = function (t, e, n) { if (!Ts(e)) throw Error(D(200)); return bs(null, t, e, !0, n) }; Ge.hydrateRoot = function (t, e, n) { if (!Eo(t)) throw Error(D(405)); var r = n != null && n.hydratedSources || null, i = !1, s = "", l = $f; if (n != null && (n.unstable_strictMode === !0 && (i = !0), n.identifierPrefix !== void 0 && (s = n.identifierPrefix), n.onRecoverableError !== void 0 && (l = n.onRecoverableError)), e = Rf(e, null, t, 1, n ?? null, i, !1, s, l), t[yt] = e.current, Ir(t), r) for (t = 0; t < r.length; t++)n = r[t], i = n._getVersion, i = i(n._source), e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [n, i] : e.mutableSourceEagerHydrationData.push(n, i); return new xs(e) }; Ge.render = function (t, e, n) { if (!Ts(e)) throw Error(D(200)); return bs(null, t, e, !1, n) }; Ge.unmountComponentAtNode = function (t) { if (!Ts(t)) throw Error(D(40)); return t._reactRootContainer ? (un(function () { bs(null, null, t, !1, function () { t._reactRootContainer = null, t[yt] = null }) }), !0) : !1 }; Ge.unstable_batchedUpdates = mo; Ge.unstable_renderSubtreeIntoContainer = function (t, e, n, r) { if (!Ts(n)) throw Error(D(200)); if (t == null || t._reactInternals === void 0) throw Error(D(38)); return bs(t, e, n, !1, r) }; Ge.version = "18.2.0-next-9e3b772b8-20220608"; function jf() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(jf) } catch (t) { console.error(t) } } jf(), Dc.exports = Ge; var Xh = Dc.exports, Qu = Xh; El.createRoot = Qu.createRoot, El.hydrateRoot = Qu.hydrateRoot; function Uh() { return A.jsxs("section", { className: "about", id: "about", children: [A.jsx("h2", { className: "title", children: "   " }), A.jsxs("div", { className: "text-wrapper", children: [A.jsx("p", { className: "text", children: "          2010 .                     ." }), A.jsx("p", { className: "text", children: "  - ,       .             ." })] }), A.jsxs("div", { className: "bottom-block", children: [A.jsxs("div", { className: "colored-box", children: [A.jsx("p", { className: "text", children: "  ,   :" }), A.jsxs("ul", { className: "text", children: [A.jsx("li", { children: "   " }), A.jsx("li", { children: " " }), A.jsx("li", { children: "    " }), A.jsx("li", { children: "     " })] })] }), A.jsx("img", { src: "./licence-icon.png", alt: "licence", className: "licence" })] })] }) } function Yh(t) { return A.jsx("a", { className: "btn", children: t.text }) } const qh = [{ name: " ", href: "#about" }, { name: "", href: "#team" }, { name: "", href: "#services" }, { name: "", href: "#contacts" }]; function Qh() { return A.jsx(A.Fragment, { children: A.jsxs("div", { className: "head", children: [A.jsxs("nav", { className: "nav", children: [A.jsx("img", { src: "./logo.svg", alt: "", className: "logo" }), A.jsx("ul", { className: "links", children: qh.map(t => A.jsx("li", { children: A.jsx("a", { href: t.href, className: "underline", children: t.name }) }, t.href)) })] }), A.jsxs("section", { className: "hero", children: [A.jsxs("div", { className: "wrapper", children: [A.jsxs("div", { className: "text-side", children: [A.jsx("h1", { className: "title", children: "  ? !" }), A.jsx("p", { className: "text", children: '  " "         .' }), A.jsx(Yh, { text: "  " })] }), A.jsx("div", { className: "img", children: A.jsx("img", { src: "./hero-illustration.svg", alt: "hero" }) })] }), A.jsx("p", { className: "capture", children: " , ,   -        .      !" })] })] }) }) } var Ff = {}, xo = {}, To = {}; Object.defineProperty(To, "__esModule", { value: !0 }); var Ku = "html", Zu = "head", mi = "body", Kh = /<([a-zA-Z]+[0-9]?)/, Ju = /<head[^]*>/i, ec = /<body[^]*>/i, rs = function (t, e) { throw new Error("This browser does not support `document.implementation.createHTMLDocument`") }, ma = function (t, e) { throw new Error("This browser does not support `DOMParser.prototype.parseFromString`") }, tc = typeof window == "object" && window.DOMParser; if (typeof tc == "function") { var Zh = new tc, Jh = "text/html"; ma = function (t, e) { return e && (t = "<".concat(e, ">").concat(t, "</").concat(e, ">")), Zh.parseFromString(t, Jh) }, rs = ma } if (typeof document == "object" && document.implementation) { var hi = document.implementation.createHTMLDocument(); rs = function (t, e) { if (e) { var n = hi.documentElement.querySelector(e); return n && (n.innerHTML = t), hi } return hi.documentElement.innerHTML = t, hi } } var gi = typeof document == "object" && document.createElement("template"), ha; gi && gi.content && (ha = function (t) { return gi.innerHTML = t, gi.content.childNodes }); function eg(t) { var e, n, r = t.match(Kh), i = r && r[1] ? r[1].toLowerCase() : ""; switch (i) { case Ku: { var s = ma(t); if (!Ju.test(t)) { var l = s.querySelector(Zu); (e = l == null ? void 0 : l.parentNode) === null || e === void 0 || e.removeChild(l) } if (!ec.test(t)) { var l = s.querySelector(mi); (n = l == null ? void 0 : l.parentNode) === null || n === void 0 || n.removeChild(l) } return s.querySelectorAll(Ku) } case Zu: case mi: { var o = rs(t).querySelectorAll(i); return ec.test(t) && Ju.test(t) ? o[0].parentNode.childNodes : o } default: { if (ha) return ha(t); var l = rs(t, mi).querySelector(mi); return l.childNodes } } } To.default = eg; var Bn = {}, bo = {}, Co = {}; (function (t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.Doctype = t.CDATA = t.Tag = t.Style = t.Script = t.Comment = t.Directive = t.Text = t.Root = t.isTag = t.ElementType = void 0; var e; (function (r) { r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype" })(e = t.ElementType || (t.ElementType = {})); function n(r) { return r.type === e.Tag || r.type === e.Script || r.type === e.Style } t.isTag = n, t.Root = e.Root, t.Text = e.Text, t.Directive = e.Directive, t.Comment = e.Comment, t.Script = e.Script, t.Style = e.Style, t.Tag = e.Tag, t.CDATA = e.CDATA, t.Doctype = e.Doctype })(Co); var G = {}, Wt = oe && oe.__extends || function () { var t = function (e, n) { return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (r, i) { r.__proto__ = i } || function (r, i) { for (var s in i) Object.prototype.hasOwnProperty.call(i, s) && (r[s] = i[s]) }, t(e, n) }; return function (e, n) { if (typeof n != "function" && n !== null) throw new TypeError("Class extends value " + String(n) + " is not a constructor or null"); t(e, n); function r() { this.constructor = e } e.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r) } }(), Er = oe && oe.__assign || function () { return Er = Object.assign || function (t) { for (var e, n = 1, r = arguments.length; n < r; n++) { e = arguments[n]; for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]) } return t }, Er.apply(this, arguments) }; Object.defineProperty(G, "__esModule", { value: !0 }); G.cloneNode = G.hasChildren = G.isDocument = G.isDirective = G.isComment = G.isText = G.isCDATA = G.isTag = G.Element = G.Document = G.CDATA = G.NodeWithChildren = G.ProcessingInstruction = G.Comment = G.Text = G.DataNode = G.Node = void 0; var De = Co, Po = function () { function t() { this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null } return Object.defineProperty(t.prototype, "parentNode", { get: function () { return this.parent }, set: function (e) { this.parent = e }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "previousSibling", { get: function () { return this.prev }, set: function (e) { this.prev = e }, enumerable: !1, configurable: !0 }), Object.defineProperty(t.prototype, "nextSibling", { get: function () { return this.next }, set: function (e) { this.next = e }, enumerable: !1, configurable: !0 }), t.prototype.cloneNode = function (e) { return e === void 0 && (e = !1), ko(this, e) }, t }(); G.Node = Po; var Cs = function (t) { Wt(e, t); function e(n) { var r = t.call(this) || this; return r.data = n, r } return Object.defineProperty(e.prototype, "nodeValue", { get: function () { return this.data }, set: function (n) { this.data = n }, enumerable: !1, configurable: !0 }), e }(Po); G.DataNode = Cs; var Hf = function (t) { Wt(e, t); function e() { var n = t !== null && t.apply(this, arguments) || this; return n.type = De.ElementType.Text, n } return Object.defineProperty(e.prototype, "nodeType", { get: function () { return 3 }, enumerable: !1, configurable: !0 }), e }(Cs); G.Text = Hf; var Bf = function (t) { Wt(e, t); function e() { var n = t !== null && t.apply(this, arguments) || this; return n.type = De.ElementType.Comment, n } return Object.defineProperty(e.prototype, "nodeType", { get: function () { return 8 }, enumerable: !1, configurable: !0 }), e }(Cs); G.Comment = Bf; var Vf = function (t) { Wt(e, t); function e(n, r) { var i = t.call(this, r) || this; return i.name = n, i.type = De.ElementType.Directive, i } return Object.defineProperty(e.prototype, "nodeType", { get: function () { return 1 }, enumerable: !1, configurable: !0 }), e }(Cs); G.ProcessingInstruction = Vf; var Ps = function (t) { Wt(e, t); function e(n) { var r = t.call(this) || this; return r.children = n, r } return Object.defineProperty(e.prototype, "firstChild", { get: function () { var n; return (n = this.children[0]) !== null && n !== void 0 ? n : null }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "lastChild", { get: function () { return this.children.length > 0 ? this.children[this.children.length - 1] : null }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "childNodes", { get: function () { return this.children }, set: function (n) { this.children = n }, enumerable: !1, configurable: !0 }), e }(Po); G.NodeWithChildren = Ps; var Gf = function (t) { Wt(e, t); function e() { var n = t !== null && t.apply(this, arguments) || this; return n.type = De.ElementType.CDATA, n } return Object.defineProperty(e.prototype, "nodeType", { get: function () { return 4 }, enumerable: !1, configurable: !0 }), e }(Ps); G.CDATA = Gf; var Wf = function (t) { Wt(e, t); function e() { var n = t !== null && t.apply(this, arguments) || this; return n.type = De.ElementType.Root, n } return Object.defineProperty(e.prototype, "nodeType", { get: function () { return 9 }, enumerable: !1, configurable: !0 }), e }(Ps); G.Document = Wf; var Xf = function (t) { Wt(e, t); function e(n, r, i, s) { i === void 0 && (i = []), s === void 0 && (s = n === "script" ? De.ElementType.Script : n === "style" ? De.ElementType.Style : De.ElementType.Tag); var l = t.call(this, i) || this; return l.name = n, l.attribs = r, l.type = s, l } return Object.defineProperty(e.prototype, "nodeType", { get: function () { return 1 }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "tagName", { get: function () { return this.name }, set: function (n) { this.name = n }, enumerable: !1, configurable: !0 }), Object.defineProperty(e.prototype, "attributes", { get: function () { var n = this; return Object.keys(this.attribs).map(function (r) { var i, s; return { name: r, value: n.attribs[r], namespace: (i = n["x-attribsNamespace"]) === null || i === void 0 ? void 0 : i[r], prefix: (s = n["x-attribsPrefix"]) === null || s === void 0 ? void 0 : s[r] } }) }, enumerable: !1, configurable: !0 }), e }(Ps); G.Element = Xf; function Uf(t) { return (0, De.isTag)(t) } G.isTag = Uf; function Yf(t) { return t.type === De.ElementType.CDATA } G.isCDATA = Yf; function qf(t) { return t.type === De.ElementType.Text } G.isText = qf; function Qf(t) { return t.type === De.ElementType.Comment } G.isComment = Qf; function Kf(t) { return t.type === De.ElementType.Directive } G.isDirective = Kf; function Zf(t) { return t.type === De.ElementType.Root } G.isDocument = Zf; function tg(t) { return Object.prototype.hasOwnProperty.call(t, "children") } G.hasChildren = tg; function ko(t, e) { e === void 0 && (e = !1); var n; if (qf(t)) n = new Hf(t.data); else if (Qf(t)) n = new Bf(t.data); else if (Uf(t)) { var r = e ? cl(t.children) : [], i = new Xf(t.name, Er({}, t.attribs), r); r.forEach(function (a) { return a.parent = i }), t.namespace != null && (i.namespace = t.namespace), t["x-attribsNamespace"] && (i["x-attribsNamespace"] = Er({}, t["x-attribsNamespace"])), t["x-attribsPrefix"] && (i["x-attribsPrefix"] = Er({}, t["x-attribsPrefix"])), n = i } else if (Yf(t)) { var r = e ? cl(t.children) : [], s = new Gf(r); r.forEach(function (u) { return u.parent = s }), n = s } else if (Zf(t)) { var r = e ? cl(t.children) : [], l = new Wf(r); r.forEach(function (u) { return u.parent = l }), t["x-mode"] && (l["x-mode"] = t["x-mode"]), n = l } else if (Kf(t)) { var o = new Vf(t.name, t.data); t["x-name"] != null && (o["x-name"] = t["x-name"], o["x-publicId"] = t["x-publicId"], o["x-systemId"] = t["x-systemId"]), n = o } else throw new Error("Not implemented yet: ".concat(t.type)); return n.startIndex = t.startIndex, n.endIndex = t.endIndex, t.sourceCodeLocation != null && (n.sourceCodeLocation = t.sourceCodeLocation), n } G.cloneNode = ko; function cl(t) { for (var e = t.map(function (r) { return ko(r, !0) }), n = 1; n < e.length; n++)e[n].prev = e[n - 1], e[n - 1].next = e[n]; return e } (function (t) { var e = oe && oe.__createBinding || (Object.create ? function (o, a, u, c) { c === void 0 && (c = u); var d = Object.getOwnPropertyDescriptor(a, u); (!d || ("get" in d ? !a.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function () { return a[u] } }), Object.defineProperty(o, c, d) } : function (o, a, u, c) { c === void 0 && (c = u), o[c] = a[u] }), n = oe && oe.__exportStar || function (o, a) { for (var u in o) u !== "default" && !Object.prototype.hasOwnProperty.call(a, u) && e(a, o, u) }; Object.defineProperty(t, "__esModule", { value: !0 }), t.DomHandler = void 0; var r = Co, i = G; n(G, t); var s = { withStartIndices: !1, withEndIndices: !1, xmlMode: !1 }, l = function () { function o(a, u, c) { this.dom = [], this.root = new i.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = s), typeof a == "object" && (u = a, a = void 0), this.callback = a ?? null, this.options = u ?? s, this.elementCB = c ?? null } return o.prototype.onparserinit = function (a) { this.parser = a }, o.prototype.onreset = function () { this.dom = [], this.root = new i.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null }, o.prototype.onend = function () { this.done || (this.done = !0, this.parser = null, this.handleCallback(null)) }, o.prototype.onerror = function (a) { this.handleCallback(a) }, o.prototype.onclosetag = function () { this.lastNode = null; var a = this.tagStack.pop(); this.options.withEndIndices && (a.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(a) }, o.prototype.onopentag = function (a, u) { var c = this.options.xmlMode ? r.ElementType.Tag : void 0, d = new i.Element(a, u, void 0, c); this.addNode(d), this.tagStack.push(d) }, o.prototype.ontext = function (a) { var u = this.lastNode; if (u && u.type === r.ElementType.Text) u.data += a, this.options.withEndIndices && (u.endIndex = this.parser.endIndex); else { var c = new i.Text(a); this.addNode(c), this.lastNode = c } }, o.prototype.oncomment = function (a) { if (this.lastNode && this.lastNode.type === r.ElementType.Comment) { this.lastNode.data += a; return } var u = new i.Comment(a); this.addNode(u), this.lastNode = u }, o.prototype.oncommentend = function () { this.lastNode = null }, o.prototype.oncdatastart = function () { var a = new i.Text(""), u = new i.CDATA([a]); this.addNode(u), a.parent = u, this.lastNode = a }, o.prototype.oncdataend = function () { this.lastNode = null }, o.prototype.onprocessinginstruction = function (a, u) { var c = new i.ProcessingInstruction(a, u); this.addNode(c) }, o.prototype.handleCallback = function (a) { if (typeof this.callback == "function") this.callback(a, this.dom); else if (a) throw a }, o.prototype.addNode = function (a) { var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1]; this.options.withStartIndices && (a.startIndex = this.parser.startIndex), this.options.withEndIndices && (a.endIndex = this.parser.endIndex), u.children.push(a), c && (a.prev = c, c.next = a), a.parent = u, this.lastNode = null }, o }(); t.DomHandler = l, t.default = l })(bo); var Jf = {}; (function (t) { Object.defineProperty(t, "__esModule", { value: !0 }), t.CASE_SENSITIVE_TAG_NAMES_MAP = t.CASE_SENSITIVE_TAG_NAMES = void 0, t.CASE_SENSITIVE_TAG_NAMES = ["animateMotion", "animateTransform", "clipPath", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "foreignObject", "linearGradient", "radialGradient", "textPath"], t.CASE_SENSITIVE_TAG_NAMES_MAP = t.CASE_SENSITIVE_TAG_NAMES.reduce(function (e, n) { return e[n.toLowerCase()] = n, e }, {}) })(Jf); Object.defineProperty(Bn, "__esModule", { value: !0 }); Bn.formatDOM = Bn.formatAttributes = void 0; var vi = bo, ng = Jf; function rg(t) { return ng.CASE_SENSITIVE_TAG_NAMES_MAP[t] } function ep(t) { for (var e = {}, n = 0, r = t.length; n < r; n++) { var i = t[n]; e[i.name] = i.value } return e } Bn.formatAttributes = ep; function ig(t) { t = t.toLowerCase(); var e = rg(t); return e || t } function tp(t, e, n) { e === void 0 && (e = null); for (var r = [], i, s = 0, l = t.length; s < l; s++) { var o = t[s]; switch (o.nodeType) { case 1: { var a = ig(o.nodeName); i = new vi.Element(a, ep(o.attributes)), i.children = tp(a === "template" ? o.content.childNodes : o.childNodes, i); break } case 3: i = new vi.Text(o.nodeValue); break; case 8: i = new vi.Comment(o.nodeValue); break; default: continue }var u = r[s - 1] || null; u && (u.next = i), i.parent = e, i.prev = u, i.next = null, r.push(i) } return n && (i = new vi.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), i.next = r[0] || null, i.parent = e, r.unshift(i), r[1] && (r[1].prev = r[0])), r } Bn.formatDOM = tp; var sg = oe && oe.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(xo, "__esModule", { value: !0 }); var lg = sg(To), ag = Bn, og = /<(![a-zA-Z\s]+)>/; function ug(t) { if (typeof t != "string") throw new TypeError("First argument must be a string"); if (!t) return []; var e = t.match(og), n = e ? e[1] : void 0; return (0, ag.formatDOM)((0, lg.default)(t), null, n) } xo.default = ug; var ks = {}, lt = {}, Ms = {}, cg = 0; Ms.SAME = cg; var dg = 1; Ms.CAMELCASE = dg; Ms.possibleStandardNames = { accept: 0, acceptCharset: 1, "accept-charset": "acceptCharset", accessKey: 1, action: 0, allowFullScreen: 1, alt: 0, as: 0, async: 0, autoCapitalize: 1, autoComplete: 1, autoCorrect: 1, autoFocus: 1, autoPlay: 1, autoSave: 1, capture: 0, cellPadding: 1, cellSpacing: 1, challenge: 0, charSet: 1, checked: 0, children: 0, cite: 0, class: "className", classID: 1, className: 1, cols: 0, colSpan: 1, content: 0, contentEditable: 1, contextMenu: 1, controls: 0, controlsList: 1, coords: 0, crossOrigin: 1, dangerouslySetInnerHTML: 1, data: 0, dateTime: 1, default: 0, defaultChecked: 1, defaultValue: 1, defer: 0, dir: 0, disabled: 0, disablePictureInPicture: 1, disableRemotePlayback: 1, download: 0, draggable: 0, encType: 1, enterKeyHint: 1, for: "htmlFor", form: 0, formMethod: 1, formAction: 1, formEncType: 1, formNoValidate: 1, formTarget: 1, frameBorder: 1, headers: 0, height: 0, hidden: 0, high: 0, href: 0, hrefLang: 1, htmlFor: 1, httpEquiv: 1, "http-equiv": "httpEquiv", icon: 0, id: 0, innerHTML: 1, inputMode: 1, integrity: 0, is: 0, itemID: 1, itemProp: 1, itemRef: 1, itemScope: 1, itemType: 1, keyParams: 1, keyType: 1, kind: 0, label: 0, lang: 0, list: 0, loop: 0, low: 0, manifest: 0, marginWidth: 1, marginHeight: 1, max: 0, maxLength: 1, media: 0, mediaGroup: 1, method: 0, min: 0, minLength: 1, multiple: 0, muted: 0, name: 0, noModule: 1, nonce: 0, noValidate: 1, open: 0, optimum: 0, pattern: 0, placeholder: 0, playsInline: 1, poster: 0, preload: 0, profile: 0, radioGroup: 1, readOnly: 1, referrerPolicy: 1, rel: 0, required: 0, reversed: 0, role: 0, rows: 0, rowSpan: 1, sandbox: 0, scope: 0, scoped: 0, scrolling: 0, seamless: 0, selected: 0, shape: 0, size: 0, sizes: 0, span: 0, spellCheck: 1, src: 0, srcDoc: 1, srcLang: 1, srcSet: 1, start: 0, step: 0, style: 0, summary: 0, tabIndex: 1, target: 0, title: 0, type: 0, useMap: 1, value: 0, width: 0, wmode: 0, wrap: 0, about: 0, accentHeight: 1, "accent-height": "accentHeight", accumulate: 0, additive: 0, alignmentBaseline: 1, "alignment-baseline": "alignmentBaseline", allowReorder: 1, alphabetic: 0, amplitude: 0, arabicForm: 1, "arabic-form": "arabicForm", ascent: 0, attributeName: 1, attributeType: 1, autoReverse: 1, azimuth: 0, baseFrequency: 1, baselineShift: 1, "baseline-shift": "baselineShift", baseProfile: 1, bbox: 0, begin: 0, bias: 0, by: 0, calcMode: 1, capHeight: 1, "cap-height": "capHeight", clip: 0, clipPath: 1, "clip-path": "clipPath", clipPathUnits: 1, clipRule: 1, "clip-rule": "clipRule", color: 0, colorInterpolation: 1, "color-interpolation": "colorInterpolation", colorInterpolationFilters: 1, "color-interpolation-filters": "colorInterpolationFilters", colorProfile: 1, "color-profile": "colorProfile", colorRendering: 1, "color-rendering": "colorRendering", contentScriptType: 1, contentStyleType: 1, cursor: 0, cx: 0, cy: 0, d: 0, datatype: 0, decelerate: 0, descent: 0, diffuseConstant: 1, direction: 0, display: 0, divisor: 0, dominantBaseline: 1, "dominant-baseline": "dominantBaseline", dur: 0, dx: 0, dy: 0, edgeMode: 1, elevation: 0, enableBackground: 1, "enable-background": "enableBackground", end: 0, exponent: 0, externalResourcesRequired: 1, fill: 0, fillOpacity: 1, "fill-opacity": "fillOpacity", fillRule: 1, "fill-rule": "fillRule", filter: 0, filterRes: 1, filterUnits: 1, floodOpacity: 1, "flood-opacity": "floodOpacity", floodColor: 1, "flood-color": "floodColor", focusable: 0, fontFamily: 1, "font-family": "fontFamily", fontSize: 1, "font-size": "fontSize", fontSizeAdjust: 1, "font-size-adjust": "fontSizeAdjust", fontStretch: 1, "font-stretch": "fontStretch", fontStyle: 1, "font-style": "fontStyle", fontVariant: 1, "font-variant": "fontVariant", fontWeight: 1, "font-weight": "fontWeight", format: 0, from: 0, fx: 0, fy: 0, g1: 0, g2: 0, glyphName: 1, "glyph-name": "glyphName", glyphOrientationHorizontal: 1, "glyph-orientation-horizontal": "glyphOrientationHorizontal", glyphOrientationVertical: 1, "glyph-orientation-vertical": "glyphOrientationVertical", glyphRef: 1, gradientTransform: 1, gradientUnits: 1, hanging: 0, horizAdvX: 1, "horiz-adv-x": "horizAdvX", horizOriginX: 1, "horiz-origin-x": "horizOriginX", ideographic: 0, imageRendering: 1, "image-rendering": "imageRendering", in2: 0, in: 0, inlist: 0, intercept: 0, k1: 0, k2: 0, k3: 0, k4: 0, k: 0, kernelMatrix: 1, kernelUnitLength: 1, kerning: 0, keyPoints: 1, keySplines: 1, keyTimes: 1, lengthAdjust: 1, letterSpacing: 1, "letter-spacing": "letterSpacing", lightingColor: 1, "lighting-color": "lightingColor", limitingConeAngle: 1, local: 0, markerEnd: 1, "marker-end": "markerEnd", markerHeight: 1, markerMid: 1, "marker-mid": "markerMid", markerStart: 1, "marker-start": "markerStart", markerUnits: 1, markerWidth: 1, mask: 0, maskContentUnits: 1, maskUnits: 1, mathematical: 0, mode: 0, numOctaves: 1, offset: 0, opacity: 0, operator: 0, order: 0, orient: 0, orientation: 0, origin: 0, overflow: 0, overlinePosition: 1, "overline-position": "overlinePosition", overlineThickness: 1, "overline-thickness": "overlineThickness", paintOrder: 1, "paint-order": "paintOrder", panose1: 0, "panose-1": "panose1", pathLength: 1, patternContentUnits: 1, patternTransform: 1, patternUnits: 1, pointerEvents: 1, "pointer-events": "pointerEvents", points: 0, pointsAtX: 1, pointsAtY: 1, pointsAtZ: 1, prefix: 0, preserveAlpha: 1, preserveAspectRatio: 1, primitiveUnits: 1, property: 0, r: 0, radius: 0, refX: 1, refY: 1, renderingIntent: 1, "rendering-intent": "renderingIntent", repeatCount: 1, repeatDur: 1, requiredExtensions: 1, requiredFeatures: 1, resource: 0, restart: 0, result: 0, results: 0, rotate: 0, rx: 0, ry: 0, scale: 0, security: 0, seed: 0, shapeRendering: 1, "shape-rendering": "shapeRendering", slope: 0, spacing: 0, specularConstant: 1, specularExponent: 1, speed: 0, spreadMethod: 1, startOffset: 1, stdDeviation: 1, stemh: 0, stemv: 0, stitchTiles: 1, stopColor: 1, "stop-color": "stopColor", stopOpacity: 1, "stop-opacity": "stopOpacity", strikethroughPosition: 1, "strikethrough-position": "strikethroughPosition", strikethroughThickness: 1, "strikethrough-thickness": "strikethroughThickness", string: 0, stroke: 0, strokeDasharray: 1, "stroke-dasharray": "strokeDasharray", strokeDashoffset: 1, "stroke-dashoffset": "strokeDashoffset", strokeLinecap: 1, "stroke-linecap": "strokeLinecap", strokeLinejoin: 1, "stroke-linejoin": "strokeLinejoin", strokeMiterlimit: 1, "stroke-miterlimit": "strokeMiterlimit", strokeWidth: 1, "stroke-width": "strokeWidth", strokeOpacity: 1, "stroke-opacity": "strokeOpacity", suppressContentEditableWarning: 1, suppressHydrationWarning: 1, surfaceScale: 1, systemLanguage: 1, tableValues: 1, targetX: 1, targetY: 1, textAnchor: 1, "text-anchor": "textAnchor", textDecoration: 1, "text-decoration": "textDecoration", textLength: 1, textRendering: 1, "text-rendering": "textRendering", to: 0, transform: 0, typeof: 0, u1: 0, u2: 0, underlinePosition: 1, "underline-position": "underlinePosition", underlineThickness: 1, "underline-thickness": "underlineThickness", unicode: 0, unicodeBidi: 1, "unicode-bidi": "unicodeBidi", unicodeRange: 1, "unicode-range": "unicodeRange", unitsPerEm: 1, "units-per-em": "unitsPerEm", unselectable: 0, vAlphabetic: 1, "v-alphabetic": "vAlphabetic", values: 0, vectorEffect: 1, "vector-effect": "vectorEffect", version: 0, vertAdvY: 1, "vert-adv-y": "vertAdvY", vertOriginX: 1, "vert-origin-x": "vertOriginX", vertOriginY: 1, "vert-origin-y": "vertOriginY", vHanging: 1, "v-hanging": "vHanging", vIdeographic: 1, "v-ideographic": "vIdeographic", viewBox: 1, viewTarget: 1, visibility: 0, vMathematical: 1, "v-mathematical": "vMathematical", vocab: 0, widths: 0, wordSpacing: 1, "word-spacing": "wordSpacing", writingMode: 1, "writing-mode": "writingMode", x1: 0, x2: 0, x: 0, xChannelSelector: 1, xHeight: 1, "x-height": "xHeight", xlinkActuate: 1, "xlink:actuate": "xlinkActuate", xlinkArcrole: 1, "xlink:arcrole": "xlinkArcrole", xlinkHref: 1, "xlink:href": "xlinkHref", xlinkRole: 1, "xlink:role": "xlinkRole", xlinkShow: 1, "xlink:show": "xlinkShow", xlinkTitle: 1, "xlink:title": "xlinkTitle", xlinkType: 1, "xlink:type": "xlinkType", xmlBase: 1, "xml:base": "xmlBase", xmlLang: 1, "xml:lang": "xmlLang", xmlns: 0, "xml:space": "xmlSpace", xmlnsXlink: 1, "xmlns:xlink": "xmlnsXlink", xmlSpace: 1, y1: 0, y2: 0, y: 0, yChannelSelector: 1, z: 0, zoomAndPan: 1 }; const np = 0, Xt = 1, _s = 2, Ls = 3, Mo = 4, rp = 5, ip = 6; function fg(t) { return Se.hasOwnProperty(t) ? Se[t] : null } function Le(t, e, n, r, i, s, l) { this.acceptsBooleans = e === _s || e === Ls || e === Mo, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = n, this.propertyName = t, this.type = e, this.sanitizeURL = s, this.removeEmptyString = l } const Se = {}, pg = ["children", "dangerouslySetInnerHTML", "defaultValue", "defaultChecked", "innerHTML", "suppressContentEditableWarning", "suppressHydrationWarning", "style"]; pg.forEach(t => { Se[t] = new Le(t, np, !1, t, null, !1, !1) });[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(([t, e]) => { Se[t] = new Le(t, Xt, !1, e, null, !1, !1) });["contentEditable", "draggable", "spellCheck", "value"].forEach(t => { Se[t] = new Le(t, _s, !1, t.toLowerCase(), null, !1, !1) });["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(t => { Se[t] = new Le(t, _s, !1, t, null, !1, !1) });["allowFullScreen", "async", "autoFocus", "autoPlay", "controls", "default", "defer", "disabled", "disablePictureInPicture", "disableRemotePlayback", "formNoValidate", "hidden", "loop", "noModule", "noValidate", "open", "playsInline", "readOnly", "required", "reversed", "scoped", "seamless", "itemScope"].forEach(t => { Se[t] = new Le(t, Ls, !1, t.toLowerCase(), null, !1, !1) });["checked", "multiple", "muted", "selected"].forEach(t => { Se[t] = new Le(t, Ls, !0, t, null, !1, !1) });["capture", "download"].forEach(t => { Se[t] = new Le(t, Mo, !1, t, null, !1, !1) });["cols", "rows", "size", "span"].forEach(t => { Se[t] = new Le(t, ip, !1, t, null, !1, !1) });["rowSpan", "start"].forEach(t => { Se[t] = new Le(t, rp, !1, t.toLowerCase(), null, !1, !1) }); const _o = /[\-\:]([a-z])/g, Lo = t => t[1].toUpperCase();["accent-height", "alignment-baseline", "arabic-form", "baseline-shift", "cap-height", "clip-path", "clip-rule", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "dominant-baseline", "enable-background", "fill-opacity", "fill-rule", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "glyph-name", "glyph-orientation-horizontal", "glyph-orientation-vertical", "horiz-adv-x", "horiz-origin-x", "image-rendering", "letter-spacing", "lighting-color", "marker-end", "marker-mid", "marker-start", "overline-position", "overline-thickness", "paint-order", "panose-1", "pointer-events", "rendering-intent", "shape-rendering", "stop-color", "stop-opacity", "strikethrough-position", "strikethrough-thickness", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-anchor", "text-decoration", "text-rendering", "underline-position", "underline-thickness", "unicode-bidi", "unicode-range", "units-per-em", "v-alphabetic", "v-hanging", "v-ideographic", "v-mathematical", "vector-effect", "vert-adv-y", "vert-origin-x", "vert-origin-y", "word-spacing", "writing-mode", "xmlns:xlink", "x-height"].forEach(t => { const e = t.replace(_o, Lo); Se[e] = new Le(e, Xt, !1, t, null, !1, !1) });["xlink:actuate", "xlink:arcrole", "xlink:role", "xlink:show", "xlink:title", "xlink:type"].forEach(t => { const e = t.replace(_o, Lo); Se[e] = new Le(e, Xt, !1, t, "http://www.w3.org/1999/xlink", !1, !1) });["xml:base", "xml:lang", "xml:space"].forEach(t => { const e = t.replace(_o, Lo); Se[e] = new Le(e, Xt, !1, t, "http://www.w3.org/XML/1998/namespace", !1, !1) });["tabIndex", "crossOrigin"].forEach(t => { Se[t] = new Le(t, Xt, !1, t.toLowerCase(), null, !1, !1) }); const mg = "xlinkHref"; Se[mg] = new Le("xlinkHref", Xt, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);["src", "href", "action", "formAction"].forEach(t => { Se[t] = new Le(t, Xt, !1, t.toLowerCase(), null, !0, !0) }); const { CAMELCASE: hg, SAME: gg, possibleStandardNames: nc } = Ms, vg = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", wg = vg + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", yg = RegExp.prototype.test.bind(new RegExp("^(data|aria)-[" + wg + "]*$")), Sg = Object.keys(nc).reduce((t, e) => { const n = nc[e]; return n === gg ? t[e] = e : n === hg ? t[e.toLowerCase()] = e : t[e] = n, t }, {}); lt.BOOLEAN = Ls; lt.BOOLEANISH_STRING = _s; lt.NUMERIC = rp; lt.OVERLOADED_BOOLEAN = Mo; lt.POSITIVE_NUMERIC = ip; lt.RESERVED = np; lt.STRING = Xt; lt.getPropertyInfo = fg; lt.isCustomAttribute = yg; lt.possibleStandardNames = Sg; var zo = {}, Io = {}, rc = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, Eg = /\n/g, xg = /^\s*/, Tg = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, bg = /^:\s*/, Cg = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, Pg = /^[;\s]*/, kg = /^\s+|\s+$/g, Mg = `
`, ic = "/", sc = "*", Kt = "", _g = "comment", Lg = "declaration", zg = function (t, e) { if (typeof t != "string") throw new TypeError("First argument must be a string"); if (!t) return []; e = e || {}; var n = 1, r = 1; function i(g) { var w = g.match(Eg); w && (n += w.length); var y = g.lastIndexOf(Mg); r = ~y ? g.length - y : r + g.length } function s() { var g = { line: n, column: r }; return function (w) { return w.position = new l(g), u(), w } } function l(g) { this.start = g, this.end = { line: n, column: r }, this.source = e.source } l.prototype.content = t; function o(g) { var w = new Error(e.source + ":" + n + ":" + r + ": " + g); if (w.reason = g, w.filename = e.source, w.line = n, w.column = r, w.source = t, !e.silent) throw w } function a(g) { var w = g.exec(t); if (w) { var y = w[0]; return i(y), t = t.slice(y.length), w } } function u() { a(xg) } function c(g) { var w; for (g = g || []; w = d();)w !== !1 && g.push(w); return g } function d() { var g = s(); if (!(ic != t.charAt(0) || sc != t.charAt(1))) { for (var w = 2; Kt != t.charAt(w) && (sc != t.charAt(w) || ic != t.charAt(w + 1));)++w; if (w += 2, Kt === t.charAt(w - 1)) return o("End of comment missing"); var y = t.slice(2, w - 2); return r += 2, i(y), t = t.slice(w), r += 2, g({ type: _g, comment: y }) } } function f() { var g = s(), w = a(Tg); if (w) { if (d(), !a(bg)) return o("property missing ':'"); var y = a(Cg), p = g({ type: Lg, property: lc(w[0].replace(rc, Kt)), value: y ? lc(y[0].replace(rc, Kt)) : Kt }); return a(Pg), p } } function v() { var g = []; c(g); for (var w; w = f();)w !== !1 && (g.push(w), c(g)); return g } return u(), v() }; function lc(t) { return t ? t.replace(kg, Kt) : Kt } var Ig = oe && oe.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(Io, "__esModule", { value: !0 }); var Og = Ig(zg); function Ng(t, e) { var n = null; if (!t || typeof t != "string") return n; var r = (0, Og.default)(t), i = typeof e == "function"; return r.forEach(function (s) { if (s.type === "declaration") { var l = s.property, o = s.value; i ? e(l, o, s) : o && (n = n || {}, n[l] = o) } }), n } Io.default = Ng; var zs = {}; Object.defineProperty(zs, "__esModule", { value: !0 }); zs.camelCase = void 0; var Ag = /^--[a-zA-Z0-9-]+$/, Dg = /-([a-z])/g, Rg = /^[^-]+$/, $g = /^-(webkit|moz|ms|o|khtml)-/, jg = /^-(ms)-/, Fg = function (t) { return !t || Rg.test(t) || Ag.test(t) }, Hg = function (t, e) { return e.toUpperCase() }, ac = function (t, e) { return "".concat(e, "-") }, Bg = function (t, e) { return e === void 0 && (e = {}), Fg(t) ? t : (t = t.toLowerCase(), e.reactCompat ? t = t.replace(jg, ac) : t = t.replace($g, ac), t.replace(Dg, Hg)) }; zs.camelCase = Bg; var Vg = oe && oe.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }, Gg = Vg(Io), Wg = zs; function ga(t, e) { var n = {}; return !t || typeof t != "string" || (0, Gg.default)(t, function (r, i) { r && i && (n[(0, Wg.camelCase)(r, e)] = i) }), n } ga.default = ga; var Xg = ga; (function (t) { var e = oe && oe.__importDefault || function (c) { return c && c.__esModule ? c : { default: c } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.returnFirstArg = t.canTextBeChildOfNode = t.ELEMENTS_WITH_NO_TEXT_CHILDREN = t.PRESERVE_CUSTOM_ATTRIBUTES = t.setStyleProp = t.isCustomComponent = void 0; var n = Y, r = e(Xg), i = new Set(["annotation-xml", "color-profile", "font-face", "font-face-src", "font-face-uri", "font-face-format", "font-face-name", "missing-glyph"]); function s(c, d) { return c.includes("-") ? !i.has(c) : !!(d && typeof d.is == "string") } t.isCustomComponent = s; var l = { reactCompat: !0 }; function o(c, d) { if (typeof c == "string") { if (!c.trim()) { d.style = {}; return } try { d.style = (0, r.default)(c, l) } catch { d.style = {} } } } t.setStyleProp = o, t.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, t.ELEMENTS_WITH_NO_TEXT_CHILDREN = new Set(["tr", "tbody", "thead", "tfoot", "colgroup", "table", "head", "html", "frameset"]); var a = function (c) { return !t.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name) }; t.canTextBeChildOfNode = a; var u = function (c) { return c }; t.returnFirstArg = u })(zo); Object.defineProperty(ks, "__esModule", { value: !0 }); var ur = lt, oc = zo, Ug = ["checked", "value"], Yg = ["input", "select", "textarea"], qg = { reset: !0, submit: !0 }; function Qg(t, e) { t === void 0 && (t = {}); var n = {}, r = !!(t.type && qg[t.type]); for (var i in t) { var s = t[i]; if ((0, ur.isCustomAttribute)(i)) { n[i] = s; continue } var l = i.toLowerCase(), o = uc(l); if (o) { var a = (0, ur.getPropertyInfo)(o); switch (Ug.includes(o) && Yg.includes(e) && !r && (o = uc("default" + l)), n[o] = s, a && a.type) { case ur.BOOLEAN: n[o] = !0; break; case ur.OVERLOADED_BOOLEAN: s === "" && (n[o] = !0); break }continue } oc.PRESERVE_CUSTOM_ATTRIBUTES && (n[i] = s) } return (0, oc.setStyleProp)(t.style, n), n } ks.default = Qg; function uc(t) { return ur.possibleStandardNames[t] } var Oo = {}, Kg = oe && oe.__importDefault || function (t) { return t && t.__esModule ? t : { default: t } }; Object.defineProperty(Oo, "__esModule", { value: !0 }); var dl = Y, Zg = Kg(ks), xr = zo, Jg = { cloneElement: dl.cloneElement, createElement: dl.createElement, isValidElement: dl.isValidElement }; function sp(t, e) { e === void 0 && (e = {}); for (var n = [], r = typeof e.replace == "function", i = e.transform || xr.returnFirstArg, s = e.library || Jg, l = s.cloneElement, o = s.createElement, a = s.isValidElement, u = t.length, c = 0; c < u; c++) { var d = t[c]; if (r) { var f = e.replace(d, c); if (a(f)) { u > 1 && (f = l(f, { key: f.key || c })), n.push(i(f, d, c)); continue } } if (d.type === "text") { var v = !d.data.trim().length; if (v && d.parent && !(0, xr.canTextBeChildOfNode)(d.parent) || e.trim && v) continue; n.push(i(d.data, d, c)); continue } var g = d, w = {}; ev(g) ? ((0, xr.setStyleProp)(g.attribs.style, g.attribs), w = g.attribs) : g.attribs && (w = (0, Zg.default)(g.attribs, g.name)); var y = void 0; switch (d.type) { case "script": case "style": d.children[0] && (w.dangerouslySetInnerHTML = { __html: d.children[0].data }); break; case "tag": d.name === "textarea" && d.children[0] ? w.defaultValue = d.children[0].data : d.children && d.children.length && (y = sp(d.children, e)); break; default: continue }u > 1 && (w.key = c), n.push(i(o(d.name, w, y), d, c)) } return n.length === 1 ? n[0] : n } Oo.default = sp; function ev(t) { return xr.PRESERVE_CUSTOM_ATTRIBUTES && t.type === "tag" && (0, xr.isCustomComponent)(t.name, t.attribs) } (function (t) { var e = oe && oe.__importDefault || function (a) { return a && a.__esModule ? a : { default: a } }; Object.defineProperty(t, "__esModule", { value: !0 }), t.htmlToDOM = t.domToReact = t.attributesToProps = t.Text = t.ProcessingInstruction = t.Element = t.Comment = void 0; var n = e(xo); t.htmlToDOM = n.default; var r = e(ks); t.attributesToProps = r.default; var i = e(Oo); t.domToReact = i.default; var s = bo; Object.defineProperty(t, "Comment", { enumerable: !0, get: function () { return s.Comment } }), Object.defineProperty(t, "Element", { enumerable: !0, get: function () { return s.Element } }), Object.defineProperty(t, "ProcessingInstruction", { enumerable: !0, get: function () { return s.ProcessingInstruction } }), Object.defineProperty(t, "Text", { enumerable: !0, get: function () { return s.Text } }); var l = { lowerCaseAttributeNames: !1 }; function o(a, u) { if (typeof a != "string") throw new TypeError("First argument must be a string"); return a ? (0, i.default)((0, n.default)(a, (u == null ? void 0 : u.htmlparser2) || l), u) : [] } t.default = o })(Ff); const cc = bc(Ff), lp = cc.default || cc; function dc(t) { return t !== null && typeof t == "object" && "constructor" in t && t.constructor === Object } function No(t, e) { t === void 0 && (t = {}), e === void 0 && (e = {}), Object.keys(e).forEach(n => { typeof t[n] > "u" ? t[n] = e[n] : dc(e[n]) && dc(t[n]) && Object.keys(e[n]).length > 0 && No(t[n], e[n]) }) } const ap = { body: {}, addEventListener() { }, removeEventListener() { }, activeElement: { blur() { }, nodeName: "" }, querySelector() { return null }, querySelectorAll() { return [] }, getElementById() { return null }, createEvent() { return { initEvent() { } } }, createElement() { return { children: [], childNodes: [], style: {}, setAttribute() { }, getElementsByTagName() { return [] } } }, createElementNS() { return {} }, importNode() { return null }, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" } }; function we() { const t = typeof document < "u" ? document : {}; return No(t, ap), t } const tv = { document: ap, navigator: { userAgent: "" }, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" }, history: { replaceState() { }, pushState() { }, go() { }, back() { } }, CustomEvent: function () { return this }, addEventListener() { }, removeEventListener() { }, getComputedStyle() { return { getPropertyValue() { return "" } } }, Image() { }, Date() { }, screen: {}, setTimeout() { }, clearTimeout() { }, matchMedia() { return {} }, requestAnimationFrame(t) { return typeof setTimeout > "u" ? (t(), null) : setTimeout(t, 0) }, cancelAnimationFrame(t) { typeof setTimeout > "u" || clearTimeout(t) } }; function se() { const t = typeof window < "u" ? window : {}; return No(t, tv), t } function bt(t) { return t === void 0 && (t = ""), t.trim().split(" ").filter(e => !!e.trim()) } function nv(t) { const e = t; Object.keys(e).forEach(n => { try { e[n] = null } catch { } try { delete e[n] } catch { } }) } function cn(t, e) { return e === void 0 && (e = 0), setTimeout(t, e) } function Ye() { return Date.now() } function rv(t) { const e = se(); let n; return e.getComputedStyle && (n = e.getComputedStyle(t, null)), !n && t.currentStyle && (n = t.currentStyle), n || (n = t.style), n } function va(t, e) { e === void 0 && (e = "x"); const n = se(); let r, i, s; const l = rv(t); return n.WebKitCSSMatrix ? (i = l.transform || l.webkitTransform, i.split(",").length > 6 && (i = i.split(", ").map(o => o.replace(",", ".")).join(", ")), s = new n.WebKitCSSMatrix(i === "none" ? "" : i)) : (s = l.MozTransform || l.OTransform || l.MsTransform || l.msTransform || l.transform || l.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), r = s.toString().split(",")), e === "x" && (n.WebKitCSSMatrix ? i = s.m41 : r.length === 16 ? i = parseFloat(r[12]) : i = parseFloat(r[4])), e === "y" && (n.WebKitCSSMatrix ? i = s.m42 : r.length === 16 ? i = parseFloat(r[13]) : i = parseFloat(r[5])), i || 0 } function cr(t) { return typeof t == "object" && t !== null && t.constructor && Object.prototype.toString.call(t).slice(8, -1) === "Object" } function iv(t) { return typeof window < "u" && typeof window.HTMLElement < "u" ? t instanceof HTMLElement : t && (t.nodeType === 1 || t.nodeType === 11) } function je() { const t = Object(arguments.length <= 0 ? void 0 : arguments[0]), e = ["__proto__", "constructor", "prototype"]; for (let n = 1; n < arguments.length; n += 1) { const r = n < 0 || arguments.length <= n ? void 0 : arguments[n]; if (r != null && !iv(r)) { const i = Object.keys(Object(r)).filter(s => e.indexOf(s) < 0); for (let s = 0, l = i.length; s < l; s += 1) { const o = i[s], a = Object.getOwnPropertyDescriptor(r, o); a !== void 0 && a.enumerable && (cr(t[o]) && cr(r[o]) ? r[o].__swiper__ ? t[o] = r[o] : je(t[o], r[o]) : !cr(t[o]) && cr(r[o]) ? (t[o] = {}, r[o].__swiper__ ? t[o] = r[o] : je(t[o], r[o])) : t[o] = r[o]) } } } return t } function dr(t, e, n) { t.style.setProperty(e, n) } function op(t) { let { swiper: e, targetPosition: n, side: r } = t; const i = se(), s = -e.translate; let l = null, o; const a = e.params.speed; e.wrapperEl.style.scrollSnapType = "none", i.cancelAnimationFrame(e.cssModeFrameID); const u = n > s ? "next" : "prev", c = (f, v) => u === "next" && f >= v || u === "prev" && f <= v, d = () => { o = new Date().getTime(), l === null && (l = o); const f = Math.max(Math.min((o - l) / a, 1), 0), v = .5 - Math.cos(f * Math.PI) / 2; let g = s + v * (n - s); if (c(g, n) && (g = n), e.wrapperEl.scrollTo({ [r]: g }), c(g, n)) { e.wrapperEl.style.overflow = "hidden", e.wrapperEl.style.scrollSnapType = "", setTimeout(() => { e.wrapperEl.style.overflow = "", e.wrapperEl.scrollTo({ [r]: g }) }), i.cancelAnimationFrame(e.cssModeFrameID); return } e.cssModeFrameID = i.requestAnimationFrame(d) }; d() } function pn(t) { return t.querySelector(".swiper-slide-transform") || t.shadowRoot && t.shadowRoot.querySelector(".swiper-slide-transform") || t } function ge(t, e) { return e === void 0 && (e = ""), [...t.children].filter(n => n.matches(e)) } function is(t) { try { console.warn(t); return } catch { } } function He(t, e) { e === void 0 && (e = []); const n = document.createElement(t); return n.classList.add(...Array.isArray(e) ? e : bt(e)), n } function ss(t) { const e = se(), n = we(), r = t.getBoundingClientRect(), i = n.body, s = t.clientTop || i.clientTop || 0, l = t.clientLeft || i.clientLeft || 0, o = t === e ? e.scrollY : t.scrollTop, a = t === e ? e.scrollX : t.scrollLeft; return { top: r.top + o - s, left: r.left + a - l } } function sv(t, e) { const n = []; for (; t.previousElementSibling;) { const r = t.previousElementSibling; e ? r.matches(e) && n.push(r) : n.push(r), t = r } return n } function lv(t, e) { const n = []; for (; t.nextElementSibling;) { const r = t.nextElementSibling; e ? r.matches(e) && n.push(r) : n.push(r), t = r } return n } function zt(t, e) { return se().getComputedStyle(t, null).getPropertyValue(e) } function Hr(t) { let e = t, n; if (e) { for (n = 0; (e = e.previousSibling) !== null;)e.nodeType === 1 && (n += 1); return n } } function rn(t, e) { const n = []; let r = t.parentElement; for (; r;)e ? r.matches(e) && n.push(r) : n.push(r), r = r.parentElement; return n } function Tr(t, e) { function n(r) { r.target === t && (e.call(t, r), t.removeEventListener("transitionend", n)) } e && t.addEventListener("transitionend", n) } function wa(t, e, n) { const r = se(); return n ? t[e === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(r.getComputedStyle(t, null).getPropertyValue(e === "width" ? "margin-right" : "margin-top")) + parseFloat(r.getComputedStyle(t, null).getPropertyValue(e === "width" ? "margin-left" : "margin-bottom")) : t.offsetWidth } function V(t) { return (Array.isArray(t) ? t : [t]).filter(e => !!e) } let fl; function av() { const t = se(), e = we(); return { smoothScroll: e.documentElement && e.documentElement.style && "scrollBehavior" in e.documentElement.style, touch: !!("ontouchstart" in t || t.DocumentTouch && e instanceof t.DocumentTouch) } } function up() { return fl || (fl = av()), fl } let pl; function ov(t) { let { userAgent: e } = t === void 0 ? {} : t; const n = up(), r = se(), i = r.navigator.platform, s = e || r.navigator.userAgent, l = { ios: !1, android: !1 }, o = r.screen.width, a = r.screen.height, u = s.match(/(Android);?[\s\/]+([\d.]+)?/); let c = s.match(/(iPad).*OS\s([\d_]+)/); const d = s.match(/(iPod)(.*OS\s([\d_]+))?/), f = !c && s.match(/(iPhone\sOS|iOS)\s([\d_]+)/), v = i === "Win32"; let g = i === "MacIntel"; const w = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"]; return !c && g && n.touch && w.indexOf(`${o}x${a}`) >= 0 && (c = s.match(/(Version)\/([\d.]+)/), c || (c = [0, 1, "13_0_0"]), g = !1), u && !v && (l.os = "android", l.android = !0), (c || f || d) && (l.os = "ios", l.ios = !0), l } function cp(t) { return t === void 0 && (t = {}), pl || (pl = ov(t)), pl } let ml; function uv() { const t = se(), e = cp(); let n = !1; function r() { const o = t.navigator.userAgent.toLowerCase(); return o.indexOf("safari") >= 0 && o.indexOf("chrome") < 0 && o.indexOf("android") < 0 } if (r()) { const o = String(t.navigator.userAgent); if (o.includes("Version/")) { const [a, u] = o.split("Version/")[1].split(" ")[0].split(".").map(c => Number(c)); n = a < 16 || a === 16 && u < 2 } } const i = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(t.navigator.userAgent), s = r(), l = s || i && e.ios; return { isSafari: n || s, needPerspectiveFix: n, need3dFix: l, isWebView: i } } function cv() { return ml || (ml = uv()), ml } function dv(t) { let { swiper: e, on: n, emit: r } = t; const i = se(); let s = null, l = null; const o = () => { !e || e.destroyed || !e.initialized || (r("beforeResize"), r("resize")) }, a = () => { !e || e.destroyed || !e.initialized || (s = new ResizeObserver(d => { l = i.requestAnimationFrame(() => { const { width: f, height: v } = e; let g = f, w = v; d.forEach(y => { let { contentBoxSize: p, contentRect: m, target: h } = y; h && h !== e.el || (g = m ? m.width : (p[0] || p).inlineSize, w = m ? m.height : (p[0] || p).blockSize) }), (g !== f || w !== v) && o() }) }), s.observe(e.el)) }, u = () => { l && i.cancelAnimationFrame(l), s && s.unobserve && e.el && (s.unobserve(e.el), s = null) }, c = () => { !e || e.destroyed || !e.initialized || r("orientationchange") }; n("init", () => { if (e.params.resizeObserver && typeof i.ResizeObserver < "u") { a(); return } i.addEventListener("resize", o), i.addEventListener("orientationchange", c) }), n("destroy", () => { u(), i.removeEventListener("resize", o), i.removeEventListener("orientationchange", c) }) } function fv(t) { let { swiper: e, extendParams: n, on: r, emit: i } = t; const s = [], l = se(), o = function (c, d) { d === void 0 && (d = {}); const f = l.MutationObserver || l.WebkitMutationObserver, v = new f(g => { if (e.__preventObserver__) return; if (g.length === 1) { i("observerUpdate", g[0]); return } const w = function () { i("observerUpdate", g[0]) }; l.requestAnimationFrame ? l.requestAnimationFrame(w) : l.setTimeout(w, 0) }); v.observe(c, { attributes: typeof d.attributes > "u" ? !0 : d.attributes, childList: typeof d.childList > "u" ? !0 : d.childList, characterData: typeof d.characterData > "u" ? !0 : d.characterData }), s.push(v) }, a = () => { if (e.params.observer) { if (e.params.observeParents) { const c = rn(e.hostEl); for (let d = 0; d < c.length; d += 1)o(c[d]) } o(e.hostEl, { childList: e.params.observeSlideChildren }), o(e.wrapperEl, { attributes: !1 }) } }, u = () => { s.forEach(c => { c.disconnect() }), s.splice(0, s.length) }; n({ observer: !1, observeParents: !1, observeSlideChildren: !1 }), r("init", a), r("destroy", u) } var pv = { on(t, e, n) { const r = this; if (!r.eventsListeners || r.destroyed || typeof e != "function") return r; const i = n ? "unshift" : "push"; return t.split(" ").forEach(s => { r.eventsListeners[s] || (r.eventsListeners[s] = []), r.eventsListeners[s][i](e) }), r }, once(t, e, n) { const r = this; if (!r.eventsListeners || r.destroyed || typeof e != "function") return r; function i() { r.off(t, i), i.__emitterProxy && delete i.__emitterProxy; for (var s = arguments.length, l = new Array(s), o = 0; o < s; o++)l[o] = arguments[o]; e.apply(r, l) } return i.__emitterProxy = e, r.on(t, i, n) }, onAny(t, e) { const n = this; if (!n.eventsListeners || n.destroyed || typeof t != "function") return n; const r = e ? "unshift" : "push"; return n.eventsAnyListeners.indexOf(t) < 0 && n.eventsAnyListeners[r](t), n }, offAny(t) { const e = this; if (!e.eventsListeners || e.destroyed || !e.eventsAnyListeners) return e; const n = e.eventsAnyListeners.indexOf(t); return n >= 0 && e.eventsAnyListeners.splice(n, 1), e }, off(t, e) { const n = this; return !n.eventsListeners || n.destroyed || !n.eventsListeners || t.split(" ").forEach(r => { typeof e > "u" ? n.eventsListeners[r] = [] : n.eventsListeners[r] && n.eventsListeners[r].forEach((i, s) => { (i === e || i.__emitterProxy && i.__emitterProxy === e) && n.eventsListeners[r].splice(s, 1) }) }), n }, emit() { const t = this; if (!t.eventsListeners || t.destroyed || !t.eventsListeners) return t; let e, n, r; for (var i = arguments.length, s = new Array(i), l = 0; l < i; l++)s[l] = arguments[l]; return typeof s[0] == "string" || Array.isArray(s[0]) ? (e = s[0], n = s.slice(1, s.length), r = t) : (e = s[0].events, n = s[0].data, r = s[0].context || t), n.unshift(r), (Array.isArray(e) ? e : e.split(" ")).forEach(a => { t.eventsAnyListeners && t.eventsAnyListeners.length && t.eventsAnyListeners.forEach(u => { u.apply(r, [a, ...n]) }), t.eventsListeners && t.eventsListeners[a] && t.eventsListeners[a].forEach(u => { u.apply(r, n) }) }), t } }; function mv() { const t = this; let e, n; const r = t.el; typeof t.params.width < "u" && t.params.width !== null ? e = t.params.width : e = r.clientWidth, typeof t.params.height < "u" && t.params.height !== null ? n = t.params.height : n = r.clientHeight, !(e === 0 && t.isHorizontal() || n === 0 && t.isVertical()) && (e = e - parseInt(zt(r, "padding-left") || 0, 10) - parseInt(zt(r, "padding-right") || 0, 10), n = n - parseInt(zt(r, "padding-top") || 0, 10) - parseInt(zt(r, "padding-bottom") || 0, 10), Number.isNaN(e) && (e = 0), Number.isNaN(n) && (n = 0), Object.assign(t, { width: e, height: n, size: t.isHorizontal() ? e : n })) } function hv() { const t = this; function e(P, N) { return parseFloat(P.getPropertyValue(t.getDirectionLabel(N)) || 0) } const n = t.params, { wrapperEl: r, slidesEl: i, size: s, rtlTranslate: l, wrongRTL: o } = t, a = t.virtual && n.virtual.enabled, u = a ? t.virtual.slides.length : t.slides.length, c = ge(i, `.${t.params.slideClass}, swiper-slide`), d = a ? t.virtual.slides.length : c.length; let f = []; const v = [], g = []; let w = n.slidesOffsetBefore; typeof w == "function" && (w = n.slidesOffsetBefore.call(t)); let y = n.slidesOffsetAfter; typeof y == "function" && (y = n.slidesOffsetAfter.call(t)); const p = t.snapGrid.length, m = t.slidesGrid.length; let h = n.spaceBetween, S = -w, x = 0, T = 0; if (typeof s > "u") return; typeof h == "string" && h.indexOf("%") >= 0 ? h = parseFloat(h.replace("%", "")) / 100 * s : typeof h == "string" && (h = parseFloat(h)), t.virtualSize = -h, c.forEach(P => { l ? P.style.marginLeft = "" : P.style.marginRight = "", P.style.marginBottom = "", P.style.marginTop = "" }), n.centeredSlides && n.cssMode && (dr(r, "--swiper-centered-offset-before", ""), dr(r, "--swiper-centered-offset-after", "")); const L = n.grid && n.grid.rows > 1 && t.grid; L ? t.grid.initSlides(c) : t.grid && t.grid.unsetSlides(); let b; const C = n.slidesPerView === "auto" && n.breakpoints && Object.keys(n.breakpoints).filter(P => typeof n.breakpoints[P].slidesPerView < "u").length > 0; for (let P = 0; P < d; P += 1) { b = 0; let N; if (c[P] && (N = c[P]), L && t.grid.updateSlide(P, N, c), !(c[P] && zt(N, "display") === "none")) { if (n.slidesPerView === "auto") { C && (c[P].style[t.getDirectionLabel("width")] = ""); const M = getComputedStyle(N), _ = N.style.transform, O = N.style.webkitTransform; if (_ && (N.style.transform = "none"), O && (N.style.webkitTransform = "none"), n.roundLengths) b = t.isHorizontal() ? wa(N, "width", !0) : wa(N, "height", !0); else { const R = e(M, "width"), j = e(M, "padding-left"), I = e(M, "padding-right"), E = e(M, "margin-left"), k = e(M, "margin-right"), z = M.getPropertyValue("box-sizing"); if (z && z === "border-box") b = R + E + k; else { const { clientWidth: F, offsetWidth: B } = N; b = R + j + I + E + k + (B - F) } } _ && (N.style.transform = _), O && (N.style.webkitTransform = O), n.roundLengths && (b = Math.floor(b)) } else b = (s - (n.slidesPerView - 1) * h) / n.slidesPerView, n.roundLengths && (b = Math.floor(b)), c[P] && (c[P].style[t.getDirectionLabel("width")] = `${b}px`); c[P] && (c[P].swiperSlideSize = b), g.push(b), n.centeredSlides ? (S = S + b / 2 + x / 2 + h, x === 0 && P !== 0 && (S = S - s / 2 - h), P === 0 && (S = S - s / 2 - h), Math.abs(S) < 1 / 1e3 && (S = 0), n.roundLengths && (S = Math.floor(S)), T % n.slidesPerGroup === 0 && f.push(S), v.push(S)) : (n.roundLengths && (S = Math.floor(S)), (T - Math.min(t.params.slidesPerGroupSkip, T)) % t.params.slidesPerGroup === 0 && f.push(S), v.push(S), S = S + b + h), t.virtualSize += b + h, x = b, T += 1 } } if (t.virtualSize = Math.max(t.virtualSize, s) + y, l && o && (n.effect === "slide" || n.effect === "coverflow") && (r.style.width = `${t.virtualSize + h}px`), n.setWrapperSize && (r.style[t.getDirectionLabel("width")] = `${t.virtualSize + h}px`), L && t.grid.updateWrapperSize(b, f), !n.centeredSlides) { const P = []; for (let N = 0; N < f.length; N += 1) { let M = f[N]; n.roundLengths && (M = Math.floor(M)), f[N] <= t.virtualSize - s && P.push(M) } f = P, Math.floor(t.virtualSize - s) - Math.floor(f[f.length - 1]) > 1 && f.push(t.virtualSize - s) } if (a && n.loop) { const P = g[0] + h; if (n.slidesPerGroup > 1) { const N = Math.ceil((t.virtual.slidesBefore + t.virtual.slidesAfter) / n.slidesPerGroup), M = P * n.slidesPerGroup; for (let _ = 0; _ < N; _ += 1)f.push(f[f.length - 1] + M) } for (let N = 0; N < t.virtual.slidesBefore + t.virtual.slidesAfter; N += 1)n.slidesPerGroup === 1 && f.push(f[f.length - 1] + P), v.push(v[v.length - 1] + P), t.virtualSize += P } if (f.length === 0 && (f = [0]), h !== 0) { const P = t.isHorizontal() && l ? "marginLeft" : t.getDirectionLabel("marginRight"); c.filter((N, M) => !n.cssMode || n.loop ? !0 : M !== c.length - 1).forEach(N => { N.style[P] = `${h}px` }) } if (n.centeredSlides && n.centeredSlidesBounds) { let P = 0; g.forEach(M => { P += M + (h || 0) }), P -= h; const N = P - s; f = f.map(M => M <= 0 ? -w : M > N ? N + y : M) } if (n.centerInsufficientSlides) { let P = 0; if (g.forEach(N => { P += N + (h || 0) }), P -= h, P < s) { const N = (s - P) / 2; f.forEach((M, _) => { f[_] = M - N }), v.forEach((M, _) => { v[_] = M + N }) } } if (Object.assign(t, { slides: c, snapGrid: f, slidesGrid: v, slidesSizesGrid: g }), n.centeredSlides && n.cssMode && !n.centeredSlidesBounds) { dr(r, "--swiper-centered-offset-before", `${-f[0]}px`), dr(r, "--swiper-centered-offset-after", `${t.size / 2 - g[g.length - 1] / 2}px`); const P = -t.snapGrid[0], N = -t.slidesGrid[0]; t.snapGrid = t.snapGrid.map(M => M + P), t.slidesGrid = t.slidesGrid.map(M => M + N) } if (d !== u && t.emit("slidesLengthChange"), f.length !== p && (t.params.watchOverflow && t.checkOverflow(), t.emit("snapGridLengthChange")), v.length !== m && t.emit("slidesGridLengthChange"), n.watchSlidesProgress && t.updateSlidesOffset(), t.emit("slidesUpdated"), !a && !n.cssMode && (n.effect === "slide" || n.effect === "fade")) { const P = `${n.containerModifierClass}backface-hidden`, N = t.el.classList.contains(P); d <= n.maxBackfaceHiddenSlides ? N || t.el.classList.add(P) : N && t.el.classList.remove(P) } } function gv(t) { const e = this, n = [], r = e.virtual && e.params.virtual.enabled; let i = 0, s; typeof t == "number" ? e.setTransition(t) : t === !0 && e.setTransition(e.params.speed); const l = o => r ? e.slides[e.getSlideIndexByData(o)] : e.slides[o]; if (e.params.slidesPerView !== "auto" && e.params.slidesPerView > 1) if (e.params.centeredSlides) (e.visibleSlides || []).forEach(o => { n.push(o) }); else for (s = 0; s < Math.ceil(e.params.slidesPerView); s += 1) { const o = e.activeIndex + s; if (o > e.slides.length && !r) break; n.push(l(o)) } else n.push(l(e.activeIndex)); for (s = 0; s < n.length; s += 1)if (typeof n[s] < "u") { const o = n[s].offsetHeight; i = o > i ? o : i } (i || i === 0) && (e.wrapperEl.style.height = `${i}px`) } function vv() { const t = this, e = t.slides, n = t.isElement ? t.isHorizontal() ? t.wrapperEl.offsetLeft : t.wrapperEl.offsetTop : 0; for (let r = 0; r < e.length; r += 1)e[r].swiperSlideOffset = (t.isHorizontal() ? e[r].offsetLeft : e[r].offsetTop) - n - t.cssOverflowAdjustment() } function wv(t) { t === void 0 && (t = this && this.translate || 0); const e = this, n = e.params, { slides: r, rtlTranslate: i, snapGrid: s } = e; if (r.length === 0) return; typeof r[0].swiperSlideOffset > "u" && e.updateSlidesOffset(); let l = -t; i && (l = t), r.forEach(a => { a.classList.remove(n.slideVisibleClass, n.slideFullyVisibleClass) }), e.visibleSlidesIndexes = [], e.visibleSlides = []; let o = n.spaceBetween; typeof o == "string" && o.indexOf("%") >= 0 ? o = parseFloat(o.replace("%", "")) / 100 * e.size : typeof o == "string" && (o = parseFloat(o)); for (let a = 0; a < r.length; a += 1) { const u = r[a]; let c = u.swiperSlideOffset; n.cssMode && n.centeredSlides && (c -= r[0].swiperSlideOffset); const d = (l + (n.centeredSlides ? e.minTranslate() : 0) - c) / (u.swiperSlideSize + o), f = (l - s[0] + (n.centeredSlides ? e.minTranslate() : 0) - c) / (u.swiperSlideSize + o), v = -(l - c), g = v + e.slidesSizesGrid[a], w = v >= 0 && v <= e.size - e.slidesSizesGrid[a]; (v >= 0 && v < e.size - 1 || g > 1 && g <= e.size || v <= 0 && g >= e.size) && (e.visibleSlides.push(u), e.visibleSlidesIndexes.push(a), r[a].classList.add(n.slideVisibleClass)), w && r[a].classList.add(n.slideFullyVisibleClass), u.progress = i ? -d : d, u.originalProgress = i ? -f : f } } function yv(t) { const e = this; if (typeof t > "u") { const c = e.rtlTranslate ? -1 : 1; t = e && e.translate && e.translate * c || 0 } const n = e.params, r = e.maxTranslate() - e.minTranslate(); let { progress: i, isBeginning: s, isEnd: l, progressLoop: o } = e; const a = s, u = l; if (r === 0) i = 0, s = !0, l = !0; else { i = (t - e.minTranslate()) / r; const c = Math.abs(t - e.minTranslate()) < 1, d = Math.abs(t - e.maxTranslate()) < 1; s = c || i <= 0, l = d || i >= 1, c && (i = 0), d && (i = 1) } if (n.loop) { const c = e.getSlideIndexByData(0), d = e.getSlideIndexByData(e.slides.length - 1), f = e.slidesGrid[c], v = e.slidesGrid[d], g = e.slidesGrid[e.slidesGrid.length - 1], w = Math.abs(t); w >= f ? o = (w - f) / g : o = (w + g - v) / g, o > 1 && (o -= 1) } Object.assign(e, { progress: i, progressLoop: o, isBeginning: s, isEnd: l }), (n.watchSlidesProgress || n.centeredSlides && n.autoHeight) && e.updateSlidesProgress(t), s && !a && e.emit("reachBeginning toEdge"), l && !u && e.emit("reachEnd toEdge"), (a && !s || u && !l) && e.emit("fromEdge"), e.emit("progress", i) } const hl = (t, e, n) => { e && !t.classList.contains(n) ? t.classList.add(n) : !e && t.classList.contains(n) && t.classList.remove(n) }; function Sv() { const t = this, { slides: e, params: n, slidesEl: r, activeIndex: i } = t, s = t.virtual && n.virtual.enabled, l = t.grid && n.grid && n.grid.rows > 1, o = d => ge(r, `.${n.slideClass}${d}, swiper-slide${d}`)[0]; let a, u, c; if (s) if (n.loop) { let d = i - t.virtual.slidesBefore; d < 0 && (d = t.virtual.slides.length + d), d >= t.virtual.slides.length && (d -= t.virtual.slides.length), a = o(`[data-swiper-slide-index="${d}"]`) } else a = o(`[data-swiper-slide-index="${i}"]`); else l ? (a = e.filter(d => d.column === i)[0], c = e.filter(d => d.column === i + 1)[0], u = e.filter(d => d.column === i - 1)[0]) : a = e[i]; a && (l || (c = lv(a, `.${n.slideClass}, swiper-slide`)[0], n.loop && !c && (c = e[0]), u = sv(a, `.${n.slideClass}, swiper-slide`)[0], n.loop && !u === 0 && (u = e[e.length - 1]))), e.forEach(d => { hl(d, d === a, n.slideActiveClass), hl(d, d === c, n.slideNextClass), hl(d, d === u, n.slidePrevClass) }), t.emitSlidesClasses() } const zi = (t, e) => { if (!t || t.destroyed || !t.params) return; const n = () => t.isElement ? "swiper-slide" : `.${t.params.slideClass}`, r = e.closest(n()); if (r) { let i = r.querySelector(`.${t.params.lazyPreloaderClass}`); !i && t.isElement && (r.shadowRoot ? i = r.shadowRoot.querySelector(`.${t.params.lazyPreloaderClass}`) : requestAnimationFrame(() => { r.shadowRoot && (i = r.shadowRoot.querySelector(`.${t.params.lazyPreloaderClass}`), i && i.remove()) })), i && i.remove() } }, gl = (t, e) => { if (!t.slides[e]) return; const n = t.slides[e].querySelector('[loading="lazy"]'); n && n.removeAttribute("loading") }, ya = t => { if (!t || t.destroyed || !t.params) return; let e = t.params.lazyPreloadPrevNext; const n = t.slides.length; if (!n || !e || e < 0) return; e = Math.min(e, n); const r = t.params.slidesPerView === "auto" ? t.slidesPerViewDynamic() : Math.ceil(t.params.slidesPerView), i = t.activeIndex; if (t.params.grid && t.params.grid.rows > 1) { const l = i, o = [l - e]; o.push(...Array.from({ length: e }).map((a, u) => l + r + u)), t.slides.forEach((a, u) => { o.includes(a.column) && gl(t, u) }); return } const s = i + r - 1; if (t.params.rewind || t.params.loop) for (let l = i - e; l <= s + e; l += 1) { const o = (l % n + n) % n; (o < i || o > s) && gl(t, o) } else for (let l = Math.max(i - e, 0); l <= Math.min(s + e, n - 1); l += 1)l !== i && (l > s || l < i) && gl(t, l) }; function Ev(t) { const { slidesGrid: e, params: n } = t, r = t.rtlTranslate ? t.translate : -t.translate; let i; for (let s = 0; s < e.length; s += 1)typeof e[s + 1] < "u" ? r >= e[s] && r < e[s + 1] - (e[s + 1] - e[s]) / 2 ? i = s : r >= e[s] && r < e[s + 1] && (i = s + 1) : r >= e[s] && (i = s); return n.normalizeSlideIndex && (i < 0 || typeof i > "u") && (i = 0), i } function xv(t) { const e = this, n = e.rtlTranslate ? e.translate : -e.translate, { snapGrid: r, params: i, activeIndex: s, realIndex: l, snapIndex: o } = e; let a = t, u; const c = v => { let g = v - e.virtual.slidesBefore; return g < 0 && (g = e.virtual.slides.length + g), g >= e.virtual.slides.length && (g -= e.virtual.slides.length), g }; if (typeof a > "u" && (a = Ev(e)), r.indexOf(n) >= 0) u = r.indexOf(n); else { const v = Math.min(i.slidesPerGroupSkip, a); u = v + Math.floor((a - v) / i.slidesPerGroup) } if (u >= r.length && (u = r.length - 1), a === s && !e.params.loop) { u !== o && (e.snapIndex = u, e.emit("snapIndexChange")); return } if (a === s && e.params.loop && e.virtual && e.params.virtual.enabled) { e.realIndex = c(a); return } const d = e.grid && i.grid && i.grid.rows > 1; let f; if (e.virtual && i.virtual.enabled && i.loop) f = c(a); else if (d) { const v = e.slides.filter(w => w.column === a)[0]; let g = parseInt(v.getAttribute("data-swiper-slide-index"), 10); Number.isNaN(g) && (g = Math.max(e.slides.indexOf(v), 0)), f = Math.floor(g / i.grid.rows) } else if (e.slides[a]) { const v = e.slides[a].getAttribute("data-swiper-slide-index"); v ? f = parseInt(v, 10) : f = a } else f = a; Object.assign(e, { previousSnapIndex: o, snapIndex: u, previousRealIndex: l, realIndex: f, previousIndex: s, activeIndex: a }), e.initialized && ya(e), e.emit("activeIndexChange"), e.emit("snapIndexChange"), (e.initialized || e.params.runCallbacksOnInit) && (l !== f && e.emit("realIndexChange"), e.emit("slideChange")) } function Tv(t, e) { const n = this, r = n.params; let i = t.closest(`.${r.slideClass}, swiper-slide`); !i && n.isElement && e && e.length > 1 && e.includes(t) && [...e.slice(e.indexOf(t) + 1, e.length)].forEach(o => { !i && o.matches && o.matches(`.${r.slideClass}, swiper-slide`) && (i = o) }); let s = !1, l; if (i) { for (let o = 0; o < n.slides.length; o += 1)if (n.slides[o] === i) { s = !0, l = o; break } } if (i && s) n.clickedSlide = i, n.virtual && n.params.virtual.enabled ? n.clickedIndex = parseInt(i.getAttribute("data-swiper-slide-index"), 10) : n.clickedIndex = l; else { n.clickedSlide = void 0, n.clickedIndex = void 0; return } r.slideToClickedSlide && n.clickedIndex !== void 0 && n.clickedIndex !== n.activeIndex && n.slideToClickedSlide() } var bv = { updateSize: mv, updateSlides: hv, updateAutoHeight: gv, updateSlidesOffset: vv, updateSlidesProgress: wv, updateProgress: yv, updateSlidesClasses: Sv, updateActiveIndex: xv, updateClickedSlide: Tv }; function Cv(t) { t === void 0 && (t = this.isHorizontal() ? "x" : "y"); const e = this, { params: n, rtlTranslate: r, translate: i, wrapperEl: s } = e; if (n.virtualTranslate) return r ? -i : i; if (n.cssMode) return i; let l = va(s, t); return l += e.cssOverflowAdjustment(), r && (l = -l), l || 0 } function Pv(t, e) { const n = this, { rtlTranslate: r, params: i, wrapperEl: s, progress: l } = n; let o = 0, a = 0; const u = 0; n.isHorizontal() ? o = r ? -t : t : a = t, i.roundLengths && (o = Math.floor(o), a = Math.floor(a)), n.previousTranslate = n.translate, n.translate = n.isHorizontal() ? o : a, i.cssMode ? s[n.isHorizontal() ? "scrollLeft" : "scrollTop"] = n.isHorizontal() ? -o : -a : i.virtualTranslate || (n.isHorizontal() ? o -= n.cssOverflowAdjustment() : a -= n.cssOverflowAdjustment(), s.style.transform = `translate3d(${o}px, ${a}px, ${u}px)`); let c; const d = n.maxTranslate() - n.minTranslate(); d === 0 ? c = 0 : c = (t - n.minTranslate()) / d, c !== l && n.updateProgress(t), n.emit("setTranslate", n.translate, e) } function kv() { return -this.snapGrid[0] } function Mv() { return -this.snapGrid[this.snapGrid.length - 1] } function _v(t, e, n, r, i) { t === void 0 && (t = 0), e === void 0 && (e = this.params.speed), n === void 0 && (n = !0), r === void 0 && (r = !0); const s = this, { params: l, wrapperEl: o } = s; if (s.animating && l.preventInteractionOnTransition) return !1; const a = s.minTranslate(), u = s.maxTranslate(); let c; if (r && t > a ? c = a : r && t < u ? c = u : c = t, s.updateProgress(c), l.cssMode) { const d = s.isHorizontal(); if (e === 0) o[d ? "scrollLeft" : "scrollTop"] = -c; else { if (!s.support.smoothScroll) return op({ swiper: s, targetPosition: -c, side: d ? "left" : "top" }), !0; o.scrollTo({ [d ? "left" : "top"]: -c, behavior: "smooth" }) } return !0 } return e === 0 ? (s.setTransition(0), s.setTranslate(c), n && (s.emit("beforeTransitionStart", e, i), s.emit("transitionEnd"))) : (s.setTransition(e), s.setTranslate(c), n && (s.emit("beforeTransitionStart", e, i), s.emit("transitionStart")), s.animating || (s.animating = !0, s.onTranslateToWrapperTransitionEnd || (s.onTranslateToWrapperTransitionEnd = function (f) { !s || s.destroyed || f.target === this && (s.wrapperEl.removeEventListener("transitionend", s.onTranslateToWrapperTransitionEnd), s.onTranslateToWrapperTransitionEnd = null, delete s.onTranslateToWrapperTransitionEnd, s.animating = !1, n && s.emit("transitionEnd")) }), s.wrapperEl.addEventListener("transitionend", s.onTranslateToWrapperTransitionEnd))), !0 } var Lv = { getTranslate: Cv, setTranslate: Pv, minTranslate: kv, maxTranslate: Mv, translateTo: _v }; function zv(t, e) { const n = this; n.params.cssMode || (n.wrapperEl.style.transitionDuration = `${t}ms`, n.wrapperEl.style.transitionDelay = t === 0 ? "0ms" : ""), n.emit("setTransition", t, e) } function dp(t) { let { swiper: e, runCallbacks: n, direction: r, step: i } = t; const { activeIndex: s, previousIndex: l } = e; let o = r; if (o || (s > l ? o = "next" : s < l ? o = "prev" : o = "reset"), e.emit(`transition${i}`), n && s !== l) { if (o === "reset") { e.emit(`slideResetTransition${i}`); return } e.emit(`slideChangeTransition${i}`), o === "next" ? e.emit(`slideNextTransition${i}`) : e.emit(`slidePrevTransition${i}`) } } function Iv(t, e) { t === void 0 && (t = !0); const n = this, { params: r } = n; r.cssMode || (r.autoHeight && n.updateAutoHeight(), dp({ swiper: n, runCallbacks: t, direction: e, step: "Start" })) } function Ov(t, e) { t === void 0 && (t = !0); const n = this, { params: r } = n; n.animating = !1, !r.cssMode && (n.setTransition(0), dp({ swiper: n, runCallbacks: t, direction: e, step: "End" })) } var Nv = { setTransition: zv, transitionStart: Iv, transitionEnd: Ov }; function Av(t, e, n, r, i) { t === void 0 && (t = 0), n === void 0 && (n = !0), typeof t == "string" && (t = parseInt(t, 10)); const s = this; let l = t; l < 0 && (l = 0); const { params: o, snapGrid: a, slidesGrid: u, previousIndex: c, activeIndex: d, rtlTranslate: f, wrapperEl: v, enabled: g } = s; if (!g && !r && !i || s.destroyed || s.animating && o.preventInteractionOnTransition) return !1; typeof e > "u" && (e = s.params.speed); const w = Math.min(s.params.slidesPerGroupSkip, l); let y = w + Math.floor((l - w) / s.params.slidesPerGroup); y >= a.length && (y = a.length - 1); const p = -a[y]; if (o.normalizeSlideIndex) for (let h = 0; h < u.length; h += 1) { const S = -Math.floor(p * 100), x = Math.floor(u[h] * 100), T = Math.floor(u[h + 1] * 100); typeof u[h + 1] < "u" ? S >= x && S < T - (T - x) / 2 ? l = h : S >= x && S < T && (l = h + 1) : S >= x && (l = h) } if (s.initialized && l !== d && (!s.allowSlideNext && (f ? p > s.translate && p > s.minTranslate() : p < s.translate && p < s.minTranslate()) || !s.allowSlidePrev && p > s.translate && p > s.maxTranslate() && (d || 0) !== l)) return !1; l !== (c || 0) && n && s.emit("beforeSlideChangeStart"), s.updateProgress(p); let m; if (l > d ? m = "next" : l < d ? m = "prev" : m = "reset", f && -p === s.translate || !f && p === s.translate) return s.updateActiveIndex(l), o.autoHeight && s.updateAutoHeight(), s.updateSlidesClasses(), o.effect !== "slide" && s.setTranslate(p), m !== "reset" && (s.transitionStart(n, m), s.transitionEnd(n, m)), !1; if (o.cssMode) { const h = s.isHorizontal(), S = f ? p : -p; if (e === 0) { const x = s.virtual && s.params.virtual.enabled; x && (s.wrapperEl.style.scrollSnapType = "none", s._immediateVirtual = !0), x && !s._cssModeVirtualInitialSet && s.params.initialSlide > 0 ? (s._cssModeVirtualInitialSet = !0, requestAnimationFrame(() => { v[h ? "scrollLeft" : "scrollTop"] = S })) : v[h ? "scrollLeft" : "scrollTop"] = S, x && requestAnimationFrame(() => { s.wrapperEl.style.scrollSnapType = "", s._immediateVirtual = !1 }) } else { if (!s.support.smoothScroll) return op({ swiper: s, targetPosition: S, side: h ? "left" : "top" }), !0; v.scrollTo({ [h ? "left" : "top"]: S, behavior: "smooth" }) } return !0 } return s.setTransition(e), s.setTranslate(p), s.updateActiveIndex(l), s.updateSlidesClasses(), s.emit("beforeTransitionStart", e, r), s.transitionStart(n, m), e === 0 ? s.transitionEnd(n, m) : s.animating || (s.animating = !0, s.onSlideToWrapperTransitionEnd || (s.onSlideToWrapperTransitionEnd = function (S) { !s || s.destroyed || S.target === this && (s.wrapperEl.removeEventListener("transitionend", s.onSlideToWrapperTransitionEnd), s.onSlideToWrapperTransitionEnd = null, delete s.onSlideToWrapperTransitionEnd, s.transitionEnd(n, m)) }), s.wrapperEl.addEventListener("transitionend", s.onSlideToWrapperTransitionEnd)), !0 } function Dv(t, e, n, r) { t === void 0 && (t = 0), n === void 0 && (n = !0), typeof t == "string" && (t = parseInt(t, 10)); const i = this; if (i.destroyed) return; typeof e > "u" && (e = i.params.speed); const s = i.grid && i.params.grid && i.params.grid.rows > 1; let l = t; if (i.params.loop) if (i.virtual && i.params.virtual.enabled) l = l + i.virtual.slidesBefore; else { let o; if (s) { const f = l * i.params.grid.rows; o = i.slides.filter(v => v.getAttribute("data-swiper-slide-index") * 1 === f)[0].column } else o = i.getSlideIndexByData(l); const a = s ? Math.ceil(i.slides.length / i.params.grid.rows) : i.slides.length, { centeredSlides: u } = i.params; let c = i.params.slidesPerView; c === "auto" ? c = i.slidesPerViewDynamic() : (c = Math.ceil(parseFloat(i.params.slidesPerView, 10)), u && c % 2 === 0 && (c = c + 1)); let d = a - o < c; if (u && (d = d || o < Math.ceil(c / 2)), r && u && i.params.slidesPerView !== "auto" && !s && (d = !1), d) { const f = u ? o < i.activeIndex ? "prev" : "next" : o - i.activeIndex - 1 < i.params.slidesPerView ? "next" : "prev"; i.loopFix({ direction: f, slideTo: !0, activeSlideIndex: f === "next" ? o + 1 : o - a + 1, slideRealIndex: f === "next" ? i.realIndex : void 0 }) } if (s) { const f = l * i.params.grid.rows; l = i.slides.filter(v => v.getAttribute("data-swiper-slide-index") * 1 === f)[0].column } else l = i.getSlideIndexByData(l) } return requestAnimationFrame(() => { i.slideTo(l, e, n, r) }), i } function Rv(t, e, n) { e === void 0 && (e = !0); const r = this, { enabled: i, params: s, animating: l } = r; if (!i || r.destroyed) return r; typeof t > "u" && (t = r.params.speed); let o = s.slidesPerGroup; s.slidesPerView === "auto" && s.slidesPerGroup === 1 && s.slidesPerGroupAuto && (o = Math.max(r.slidesPerViewDynamic("current", !0), 1)); const a = r.activeIndex < s.slidesPerGroupSkip ? 1 : o, u = r.virtual && s.virtual.enabled; if (s.loop) { if (l && !u && s.loopPreventsSliding) return !1; if (r.loopFix({ direction: "next" }), r._clientLeft = r.wrapperEl.clientLeft, r.activeIndex === r.slides.length - 1 && s.cssMode) return requestAnimationFrame(() => { r.slideTo(r.activeIndex + a, t, e, n) }), !0 } return s.rewind && r.isEnd ? r.slideTo(0, t, e, n) : r.slideTo(r.activeIndex + a, t, e, n) } function $v(t, e, n) { e === void 0 && (e = !0); const r = this, { params: i, snapGrid: s, slidesGrid: l, rtlTranslate: o, enabled: a, animating: u } = r; if (!a || r.destroyed) return r; typeof t > "u" && (t = r.params.speed); const c = r.virtual && i.virtual.enabled; if (i.loop) { if (u && !c && i.loopPreventsSliding) return !1; r.loopFix({ direction: "prev" }), r._clientLeft = r.wrapperEl.clientLeft } const d = o ? r.translate : -r.translate; function f(p) { return p < 0 ? -Math.floor(Math.abs(p)) : Math.floor(p) } const v = f(d), g = s.map(p => f(p)); let w = s[g.indexOf(v) - 1]; if (typeof w > "u" && i.cssMode) { let p; s.forEach((m, h) => { v >= m && (p = h) }), typeof p < "u" && (w = s[p > 0 ? p - 1 : p]) } let y = 0; if (typeof w < "u" && (y = l.indexOf(w), y < 0 && (y = r.activeIndex - 1), i.slidesPerView === "auto" && i.slidesPerGroup === 1 && i.slidesPerGroupAuto && (y = y - r.slidesPerViewDynamic("previous", !0) + 1, y = Math.max(y, 0))), i.rewind && r.isBeginning) { const p = r.params.virtual && r.params.virtual.enabled && r.virtual ? r.virtual.slides.length - 1 : r.slides.length - 1; return r.slideTo(p, t, e, n) } else if (i.loop && r.activeIndex === 0 && i.cssMode) return requestAnimationFrame(() => { r.slideTo(y, t, e, n) }), !0; return r.slideTo(y, t, e, n) } function jv(t, e, n) { e === void 0 && (e = !0); const r = this; if (!r.destroyed) return typeof t > "u" && (t = r.params.speed), r.slideTo(r.activeIndex, t, e, n) } function Fv(t, e, n, r) { e === void 0 && (e = !0), r === void 0 && (r = .5); const i = this; if (i.destroyed) return; typeof t > "u" && (t = i.params.speed); let s = i.activeIndex; const l = Math.min(i.params.slidesPerGroupSkip, s), o = l + Math.floor((s - l) / i.params.slidesPerGroup), a = i.rtlTranslate ? i.translate : -i.translate; if (a >= i.snapGrid[o]) { const u = i.snapGrid[o], c = i.snapGrid[o + 1]; a - u > (c - u) * r && (s += i.params.slidesPerGroup) } else { const u = i.snapGrid[o - 1], c = i.snapGrid[o]; a - u <= (c - u) * r && (s -= i.params.slidesPerGroup) } return s = Math.max(s, 0), s = Math.min(s, i.slidesGrid.length - 1), i.slideTo(s, t, e, n) } function Hv() { const t = this; if (t.destroyed) return; const { params: e, slidesEl: n } = t, r = e.slidesPerView === "auto" ? t.slidesPerViewDynamic() : e.slidesPerView; let i = t.clickedIndex, s; const l = t.isElement ? "swiper-slide" : `.${e.slideClass}`; if (e.loop) { if (t.animating) return; s = parseInt(t.clickedSlide.getAttribute("data-swiper-slide-index"), 10), e.centeredSlides ? i < t.loopedSlides - r / 2 || i > t.slides.length - t.loopedSlides + r / 2 ? (t.loopFix(), i = t.getSlideIndex(ge(n, `${l}[data-swiper-slide-index="${s}"]`)[0]), cn(() => { t.slideTo(i) })) : t.slideTo(i) : i > t.slides.length - r ? (t.loopFix(), i = t.getSlideIndex(ge(n, `${l}[data-swiper-slide-index="${s}"]`)[0]), cn(() => { t.slideTo(i) })) : t.slideTo(i) } else t.slideTo(i) } var Bv = { slideTo: Av, slideToLoop: Dv, slideNext: Rv, slidePrev: $v, slideReset: jv, slideToClosest: Fv, slideToClickedSlide: Hv }; function Vv(t) { const e = this, { params: n, slidesEl: r } = e; if (!n.loop || e.virtual && e.params.virtual.enabled) return; const i = () => { ge(r, `.${n.slideClass}, swiper-slide`).forEach((d, f) => { d.setAttribute("data-swiper-slide-index", f) }) }, s = e.grid && n.grid && n.grid.rows > 1, l = n.slidesPerGroup * (s ? n.grid.rows : 1), o = e.slides.length % l !== 0, a = s && e.slides.length % n.grid.rows !== 0, u = c => { for (let d = 0; d < c; d += 1) { const f = e.isElement ? He("swiper-slide", [n.slideBlankClass]) : He("div", [n.slideClass, n.slideBlankClass]); e.slidesEl.append(f) } }; if (o) { if (n.loopAddBlankSlides) { const c = l - e.slides.length % l; u(c), e.recalcSlides(), e.updateSlides() } else is("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)"); i() } else if (a) { if (n.loopAddBlankSlides) { const c = n.grid.rows - e.slides.length % n.grid.rows; u(c), e.recalcSlides(), e.updateSlides() } else is("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)"); i() } else i(); e.loopFix({ slideRealIndex: t, direction: n.centeredSlides ? void 0 : "next" }) } function Gv(t) { let { slideRealIndex: e, slideTo: n = !0, direction: r, setTranslate: i, activeSlideIndex: s, byController: l, byMousewheel: o } = t === void 0 ? {} : t; const a = this; if (!a.params.loop) return; a.emit("beforeLoopFix"); const { slides: u, allowSlidePrev: c, allowSlideNext: d, slidesEl: f, params: v } = a, { centeredSlides: g } = v; if (a.allowSlidePrev = !0, a.allowSlideNext = !0, a.virtual && v.virtual.enabled) { n && (!v.centeredSlides && a.snapIndex === 0 ? a.slideTo(a.virtual.slides.length, 0, !1, !0) : v.centeredSlides && a.snapIndex < v.slidesPerView ? a.slideTo(a.virtual.slides.length + a.snapIndex, 0, !1, !0) : a.snapIndex === a.snapGrid.length - 1 && a.slideTo(a.virtual.slidesBefore, 0, !1, !0)), a.allowSlidePrev = c, a.allowSlideNext = d, a.emit("loopFix"); return } let w = v.slidesPerView; w === "auto" ? w = a.slidesPerViewDynamic() : (w = Math.ceil(parseFloat(v.slidesPerView, 10)), g && w % 2 === 0 && (w = w + 1)); const y = v.slidesPerGroupAuto ? w : v.slidesPerGroup; let p = y; p % y !== 0 && (p += y - p % y), p += v.loopAdditionalSlides, a.loopedSlides = p; const m = a.grid && v.grid && v.grid.rows > 1; u.length < w + p ? is("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters") : m && v.grid.fill === "row" && is("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`"); const h = [], S = []; let x = a.activeIndex; typeof s > "u" ? s = a.getSlideIndex(u.filter(_ => _.classList.contains(v.slideActiveClass))[0]) : x = s; const T = r === "next" || !r, L = r === "prev" || !r; let b = 0, C = 0; const P = m ? Math.ceil(u.length / v.grid.rows) : u.length, M = (m ? u[s].column : s) + (g && typeof i > "u" ? -w / 2 + .5 : 0); if (M < p) { b = Math.max(p - M, y); for (let _ = 0; _ < p - M; _ += 1) { const O = _ - Math.floor(_ / P) * P; if (m) { const R = P - O - 1; for (let j = u.length - 1; j >= 0; j -= 1)u[j].column === R && h.push(j) } else h.push(P - O - 1) } } else if (M + w > P - p) { C = Math.max(M - (P - p * 2), y); for (let _ = 0; _ < C; _ += 1) { const O = _ - Math.floor(_ / P) * P; m ? u.forEach((R, j) => { R.column === O && S.push(j) }) : S.push(O) } } if (a.__preventObserver__ = !0, requestAnimationFrame(() => { a.__preventObserver__ = !1 }), L && h.forEach(_ => { u[_].swiperLoopMoveDOM = !0, f.prepend(u[_]), u[_].swiperLoopMoveDOM = !1 }), T && S.forEach(_ => { u[_].swiperLoopMoveDOM = !0, f.append(u[_]), u[_].swiperLoopMoveDOM = !1 }), a.recalcSlides(), v.slidesPerView === "auto" ? a.updateSlides() : m && (h.length > 0 && L || S.length > 0 && T) && a.slides.forEach((_, O) => { a.grid.updateSlide(O, _, a.slides) }), v.watchSlidesProgress && a.updateSlidesOffset(), n) { if (h.length > 0 && L) { if (typeof e > "u") { const _ = a.slidesGrid[x], R = a.slidesGrid[x + b] - _; o ? a.setTranslate(a.translate - R) : (a.slideTo(x + Math.ceil(b), 0, !1, !0), i && (a.touchEventsData.startTranslate = a.touchEventsData.startTranslate - R, a.touchEventsData.currentTranslate = a.touchEventsData.currentTranslate - R)) } else if (i) { const _ = m ? h.length / v.grid.rows : h.length; a.slideTo(a.activeIndex + _, 0, !1, !0), a.touchEventsData.currentTranslate = a.translate } } else if (S.length > 0 && T) if (typeof e > "u") { const _ = a.slidesGrid[x], R = a.slidesGrid[x - C] - _; o ? a.setTranslate(a.translate - R) : (a.slideTo(x - C, 0, !1, !0), i && (a.touchEventsData.startTranslate = a.touchEventsData.startTranslate - R, a.touchEventsData.currentTranslate = a.touchEventsData.currentTranslate - R)) } else { const _ = m ? S.length / v.grid.rows : S.length; a.slideTo(a.activeIndex - _, 0, !1, !0) } } if (a.allowSlidePrev = c, a.allowSlideNext = d, a.controller && a.controller.control && !l) { const _ = { slideRealIndex: e, direction: r, setTranslate: i, activeSlideIndex: s, byController: !0 }; Array.isArray(a.controller.control) ? a.controller.control.forEach(O => { !O.destroyed && O.params.loop && O.loopFix({ ..._, slideTo: O.params.slidesPerView === v.slidesPerView ? n : !1 }) }) : a.controller.control instanceof a.constructor && a.controller.control.params.loop && a.controller.control.loopFix({ ..._, slideTo: a.controller.control.params.slidesPerView === v.slidesPerView ? n : !1 }) } a.emit("loopFix") } function Wv() { const t = this, { params: e, slidesEl: n } = t; if (!e.loop || t.virtual && t.params.virtual.enabled) return; t.recalcSlides(); const r = []; t.slides.forEach(i => { const s = typeof i.swiperSlideIndex > "u" ? i.getAttribute("data-swiper-slide-index") * 1 : i.swiperSlideIndex; r[s] = i }), t.slides.forEach(i => { i.removeAttribute("data-swiper-slide-index") }), r.forEach(i => { n.append(i) }), t.recalcSlides(), t.slideTo(t.realIndex, 0) } var Xv = { loopCreate: Vv, loopFix: Gv, loopDestroy: Wv }; function Uv(t) { const e = this; if (!e.params.simulateTouch || e.params.watchOverflow && e.isLocked || e.params.cssMode) return; const n = e.params.touchEventsTarget === "container" ? e.el : e.wrapperEl; e.isElement && (e.__preventObserver__ = !0), n.style.cursor = "move", n.style.cursor = t ? "grabbing" : "grab", e.isElement && requestAnimationFrame(() => { e.__preventObserver__ = !1 }) } function Yv() { const t = this; t.params.watchOverflow && t.isLocked || t.params.cssMode || (t.isElement && (t.__preventObserver__ = !0), t[t.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "", t.isElement && requestAnimationFrame(() => { t.__preventObserver__ = !1 })) } var qv = { setGrabCursor: Uv, unsetGrabCursor: Yv }; function Qv(t, e) { e === void 0 && (e = this); function n(r) { if (!r || r === we() || r === se()) return null; r.assignedSlot && (r = r.assignedSlot); const i = r.closest(t); return !i && !r.getRootNode ? null : i || n(r.getRootNode().host) } return n(e) } function fc(t, e, n) { const r = se(), { params: i } = t, s = i.edgeSwipeDetection, l = i.edgeSwipeThreshold; return s && (n <= l || n >= r.innerWidth - l) ? s === "prevent" ? (e.preventDefault(), !0) : !1 : !0 } function Kv(t) { const e = this, n = we(); let r = t; r.originalEvent && (r = r.originalEvent); const i = e.touchEventsData; if (r.type === "pointerdown") { if (i.pointerId !== null && i.pointerId !== r.pointerId) return; i.pointerId = r.pointerId } else r.type === "touchstart" && r.targetTouches.length === 1 && (i.touchId = r.targetTouches[0].identifier); if (r.type === "touchstart") { fc(e, r, r.targetTouches[0].pageX); return } const { params: s, touches: l, enabled: o } = e; if (!o || !s.simulateTouch && r.pointerType === "mouse" || e.animating && s.preventInteractionOnTransition) return; !e.animating && s.cssMode && s.loop && e.loopFix(); let a = r.target; if (s.touchEventsTarget === "wrapper" && !e.wrapperEl.contains(a) || "which" in r && r.which === 3 || "button" in r && r.button > 0 || i.isTouched && i.isMoved) return; const u = !!s.noSwipingClass && s.noSwipingClass !== "", c = r.composedPath ? r.composedPath() : r.path; u && r.target && r.target.shadowRoot && c && (a = c[0]); const d = s.noSwipingSelector ? s.noSwipingSelector : `.${s.noSwipingClass}`, f = !!(r.target && r.target.shadowRoot); if (s.noSwiping && (f ? Qv(d, a) : a.closest(d))) { e.allowClick = !0; return } if (s.swipeHandler && !a.closest(s.swipeHandler)) return; l.currentX = r.pageX, l.currentY = r.pageY; const v = l.currentX, g = l.currentY; if (!fc(e, r, v)) return; Object.assign(i, { isTouched: !0, isMoved: !1, allowTouchCallbacks: !0, isScrolling: void 0, startMoving: void 0 }), l.startX = v, l.startY = g, i.touchStartTime = Ye(), e.allowClick = !0, e.updateSize(), e.swipeDirection = void 0, s.threshold > 0 && (i.allowThresholdMove = !1); let w = !0; a.matches(i.focusableElements) && (w = !1, a.nodeName === "SELECT" && (i.isTouched = !1)), n.activeElement && n.activeElement.matches(i.focusableElements) && n.activeElement !== a && n.activeElement.blur(); const y = w && e.allowTouchMove && s.touchStartPreventDefault; (s.touchStartForcePreventDefault || y) && !a.isContentEditable && r.preventDefault(), s.freeMode && s.freeMode.enabled && e.freeMode && e.animating && !s.cssMode && e.freeMode.onTouchStart(), e.emit("touchStart", r) } function Zv(t) { const e = we(), n = this, r = n.touchEventsData, { params: i, touches: s, rtlTranslate: l, enabled: o } = n; if (!o || !i.simulateTouch && t.pointerType === "mouse") return; let a = t; if (a.originalEvent && (a = a.originalEvent), a.type === "pointermove" && (r.touchId !== null || a.pointerId !== r.pointerId)) return; let u; if (a.type === "touchmove") { if (u = [...a.changedTouches].filter(T => T.identifier === r.touchId)[0], !u || u.identifier !== r.touchId) return } else u = a; if (!r.isTouched) { r.startMoving && r.isScrolling && n.emit("touchMoveOpposite", a); return } const c = u.pageX, d = u.pageY; if (a.preventedByNestedSwiper) { s.startX = c, s.startY = d; return } if (!n.allowTouchMove) { a.target.matches(r.focusableElements) || (n.allowClick = !1), r.isTouched && (Object.assign(s, { startX: c, startY: d, currentX: c, currentY: d }), r.touchStartTime = Ye()); return } if (i.touchReleaseOnEdges && !i.loop) { if (n.isVertical()) { if (d < s.startY && n.translate <= n.maxTranslate() || d > s.startY && n.translate >= n.minTranslate()) { r.isTouched = !1, r.isMoved = !1; return } } else if (c < s.startX && n.translate <= n.maxTranslate() || c > s.startX && n.translate >= n.minTranslate()) return } if (e.activeElement && a.target === e.activeElement && a.target.matches(r.focusableElements)) { r.isMoved = !0, n.allowClick = !1; return } r.allowTouchCallbacks && n.emit("touchMove", a), s.previousX = s.currentX, s.previousY = s.currentY, s.currentX = c, s.currentY = d; const f = s.currentX - s.startX, v = s.currentY - s.startY; if (n.params.threshold && Math.sqrt(f ** 2 + v ** 2) < n.params.threshold) return; if (typeof r.isScrolling > "u") { let T; n.isHorizontal() && s.currentY === s.startY || n.isVertical() && s.currentX === s.startX ? r.isScrolling = !1 : f * f + v * v >= 25 && (T = Math.atan2(Math.abs(v), Math.abs(f)) * 180 / Math.PI, r.isScrolling = n.isHorizontal() ? T > i.touchAngle : 90 - T > i.touchAngle) } if (r.isScrolling && n.emit("touchMoveOpposite", a), typeof r.startMoving > "u" && (s.currentX !== s.startX || s.currentY !== s.startY) && (r.startMoving = !0), r.isScrolling) { r.isTouched = !1; return } if (!r.startMoving) return; n.allowClick = !1, !i.cssMode && a.cancelable && a.preventDefault(), i.touchMoveStopPropagation && !i.nested && a.stopPropagation(); let g = n.isHorizontal() ? f : v, w = n.isHorizontal() ? s.currentX - s.previousX : s.currentY - s.previousY; i.oneWayMovement && (g = Math.abs(g) * (l ? 1 : -1), w = Math.abs(w) * (l ? 1 : -1)), s.diff = g, g *= i.touchRatio, l && (g = -g, w = -w); const y = n.touchesDirection; n.swipeDirection = g > 0 ? "prev" : "next", n.touchesDirection = w > 0 ? "prev" : "next"; const p = n.params.loop && !i.cssMode, m = n.touchesDirection === "next" && n.allowSlideNext || n.touchesDirection === "prev" && n.allowSlidePrev; if (!r.isMoved) { if (p && m && n.loopFix({ direction: n.swipeDirection }), r.startTranslate = n.getTranslate(), n.setTransition(0), n.animating) { const T = new window.CustomEvent("transitionend", { bubbles: !0, cancelable: !0 }); n.wrapperEl.dispatchEvent(T) } r.allowMomentumBounce = !1, i.grabCursor && (n.allowSlideNext === !0 || n.allowSlidePrev === !0) && n.setGrabCursor(!0), n.emit("sliderFirstMove", a) } let h; if (new Date().getTime(), r.isMoved && r.allowThresholdMove && y !== n.touchesDirection && p && m && Math.abs(g) >= 1) { Object.assign(s, { startX: c, startY: d, currentX: c, currentY: d, startTranslate: r.currentTranslate }), r.loopSwapReset = !0, r.startTranslate = r.currentTranslate; return } n.emit("sliderMove", a), r.isMoved = !0, r.currentTranslate = g + r.startTranslate; let S = !0, x = i.resistanceRatio; if (i.touchReleaseOnEdges && (x = 0), g > 0 ? (p && m && !h && r.allowThresholdMove && r.currentTranslate > (i.centeredSlides ? n.minTranslate() - n.slidesSizesGrid[n.activeIndex + 1] : n.minTranslate()) && n.loopFix({ direction: "prev", setTranslate: !0, activeSlideIndex: 0 }), r.currentTranslate > n.minTranslate() && (S = !1, i.resistance && (r.currentTranslate = n.minTranslate() - 1 + (-n.minTranslate() + r.startTranslate + g) ** x))) : g < 0 && (p && m && !h && r.allowThresholdMove && r.currentTranslate < (i.centeredSlides ? n.maxTranslate() + n.slidesSizesGrid[n.slidesSizesGrid.length - 1] : n.maxTranslate()) && n.loopFix({ direction: "next", setTranslate: !0, activeSlideIndex: n.slides.length - (i.slidesPerView === "auto" ? n.slidesPerViewDynamic() : Math.ceil(parseFloat(i.slidesPerView, 10))) }), r.currentTranslate < n.maxTranslate() && (S = !1, i.resistance && (r.currentTranslate = n.maxTranslate() + 1 - (n.maxTranslate() - r.startTranslate - g) ** x))), S && (a.preventedByNestedSwiper = !0), !n.allowSlideNext && n.swipeDirection === "next" && r.currentTranslate < r.startTranslate && (r.currentTranslate = r.startTranslate), !n.allowSlidePrev && n.swipeDirection === "prev" && r.currentTranslate > r.startTranslate && (r.currentTranslate = r.startTranslate), !n.allowSlidePrev && !n.allowSlideNext && (r.currentTranslate = r.startTranslate), i.threshold > 0) if (Math.abs(g) > i.threshold || r.allowThresholdMove) { if (!r.allowThresholdMove) { r.allowThresholdMove = !0, s.startX = s.currentX, s.startY = s.currentY, r.currentTranslate = r.startTranslate, s.diff = n.isHorizontal() ? s.currentX - s.startX : s.currentY - s.startY; return } } else { r.currentTranslate = r.startTranslate; return } !i.followFinger || i.cssMode || ((i.freeMode && i.freeMode.enabled && n.freeMode || i.watchSlidesProgress) && (n.updateActiveIndex(), n.updateSlidesClasses()), i.freeMode && i.freeMode.enabled && n.freeMode && n.freeMode.onTouchMove(), n.updateProgress(r.currentTranslate), n.setTranslate(r.currentTranslate)) } function Jv(t) { const e = this, n = e.touchEventsData; let r = t; r.originalEvent && (r = r.originalEvent); let i; if (r.type === "touchend" || r.type === "touchcancel") { if (i = [...r.changedTouches].filter(x => x.identifier === n.touchId)[0], !i || i.identifier !== n.touchId) return } else { if (n.touchId !== null || r.pointerId !== n.pointerId) return; i = r } if (["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(r.type) && !(["pointercancel", "contextmenu"].includes(r.type) && (e.browser.isSafari || e.browser.isWebView))) return; n.pointerId = null, n.touchId = null; const { params: l, touches: o, rtlTranslate: a, slidesGrid: u, enabled: c } = e; if (!c || !l.simulateTouch && r.pointerType === "mouse") return; if (n.allowTouchCallbacks && e.emit("touchEnd", r), n.allowTouchCallbacks = !1, !n.isTouched) { n.isMoved && l.grabCursor && e.setGrabCursor(!1), n.isMoved = !1, n.startMoving = !1; return } l.grabCursor && n.isMoved && n.isTouched && (e.allowSlideNext === !0 || e.allowSlidePrev === !0) && e.setGrabCursor(!1); const d = Ye(), f = d - n.touchStartTime; if (e.allowClick) { const x = r.path || r.composedPath && r.composedPath(); e.updateClickedSlide(x && x[0] || r.target, x), e.emit("tap click", r), f < 300 && d - n.lastClickTime < 300 && e.emit("doubleTap doubleClick", r) } if (n.lastClickTime = Ye(), cn(() => { e.destroyed || (e.allowClick = !0) }), !n.isTouched || !n.isMoved || !e.swipeDirection || o.diff === 0 && !n.loopSwapReset || n.currentTranslate === n.startTranslate && !n.loopSwapReset) { n.isTouched = !1, n.isMoved = !1, n.startMoving = !1; return } n.isTouched = !1, n.isMoved = !1, n.startMoving = !1; let v; if (l.followFinger ? v = a ? e.translate : -e.translate : v = -n.currentTranslate, l.cssMode) return; if (l.freeMode && l.freeMode.enabled) { e.freeMode.onTouchEnd({ currentPos: v }); return } const g = v >= -e.maxTranslate() && !e.params.loop; let w = 0, y = e.slidesSizesGrid[0]; for (let x = 0; x < u.length; x += x < l.slidesPerGroupSkip ? 1 : l.slidesPerGroup) { const T = x < l.slidesPerGroupSkip - 1 ? 1 : l.slidesPerGroup; typeof u[x + T] < "u" ? (g || v >= u[x] && v < u[x + T]) && (w = x, y = u[x + T] - u[x]) : (g || v >= u[x]) && (w = x, y = u[u.length - 1] - u[u.length - 2]) } let p = null, m = null; l.rewind && (e.isBeginning ? m = l.virtual && l.virtual.enabled && e.virtual ? e.virtual.slides.length - 1 : e.slides.length - 1 : e.isEnd && (p = 0)); const h = (v - u[w]) / y, S = w < l.slidesPerGroupSkip - 1 ? 1 : l.slidesPerGroup; if (f > l.longSwipesMs) { if (!l.longSwipes) { e.slideTo(e.activeIndex); return } e.swipeDirection === "next" && (h >= l.longSwipesRatio ? e.slideTo(l.rewind && e.isEnd ? p : w + S) : e.slideTo(w)), e.swipeDirection === "prev" && (h > 1 - l.longSwipesRatio ? e.slideTo(w + S) : m !== null && h < 0 && Math.abs(h) > l.longSwipesRatio ? e.slideTo(m) : e.slideTo(w)) } else { if (!l.shortSwipes) { e.slideTo(e.activeIndex); return } e.navigation && (r.target === e.navigation.nextEl || r.target === e.navigation.prevEl) ? r.target === e.navigation.nextEl ? e.slideTo(w + S) : e.slideTo(w) : (e.swipeDirection === "next" && e.slideTo(p !== null ? p : w + S), e.swipeDirection === "prev" && e.slideTo(m !== null ? m : w)) } } function pc() { const t = this, { params: e, el: n } = t; if (n && n.offsetWidth === 0) return; e.breakpoints && t.setBreakpoint(); const { allowSlideNext: r, allowSlidePrev: i, snapGrid: s } = t, l = t.virtual && t.params.virtual.enabled; t.allowSlideNext = !0, t.allowSlidePrev = !0, t.updateSize(), t.updateSlides(), t.updateSlidesClasses(); const o = l && e.loop; (e.slidesPerView === "auto" || e.slidesPerView > 1) && t.isEnd && !t.isBeginning && !t.params.centeredSlides && !o ? t.slideTo(t.slides.length - 1, 0, !1, !0) : t.params.loop && !l ? t.slideToLoop(t.realIndex, 0, !1, !0) : t.slideTo(t.activeIndex, 0, !1, !0), t.autoplay && t.autoplay.running && t.autoplay.paused && (clearTimeout(t.autoplay.resizeTimeout), t.autoplay.resizeTimeout = setTimeout(() => { t.autoplay && t.autoplay.running && t.autoplay.paused && t.autoplay.resume() }, 500)), t.allowSlidePrev = i, t.allowSlideNext = r, t.params.watchOverflow && s !== t.snapGrid && t.checkOverflow() } function e0(t) { const e = this; e.enabled && (e.allowClick || (e.params.preventClicks && t.preventDefault(), e.params.preventClicksPropagation && e.animating && (t.stopPropagation(), t.stopImmediatePropagation()))) } function t0() { const t = this, { wrapperEl: e, rtlTranslate: n, enabled: r } = t; if (!r) return; t.previousTranslate = t.translate, t.isHorizontal() ? t.translate = -e.scrollLeft : t.translate = -e.scrollTop, t.translate === 0 && (t.translate = 0), t.updateActiveIndex(), t.updateSlidesClasses(); let i; const s = t.maxTranslate() - t.minTranslate(); s === 0 ? i = 0 : i = (t.translate - t.minTranslate()) / s, i !== t.progress && t.updateProgress(n ? -t.translate : t.translate), t.emit("setTranslate", t.translate, !1) } function n0(t) { const e = this; zi(e, t.target), !(e.params.cssMode || e.params.slidesPerView !== "auto" && !e.params.autoHeight) && e.update() } function r0() { const t = this; t.documentTouchHandlerProceeded || (t.documentTouchHandlerProceeded = !0, t.params.touchReleaseOnEdges && (t.el.style.touchAction = "auto")) } const fp = (t, e) => { const n = we(), { params: r, el: i, wrapperEl: s, device: l } = t, o = !!r.nested, a = e === "on" ? "addEventListener" : "removeEventListener", u = e; n[a]("touchstart", t.onDocumentTouchStart, { passive: !1, capture: o }), i[a]("touchstart", t.onTouchStart, { passive: !1 }), i[a]("pointerdown", t.onTouchStart, { passive: !1 }), n[a]("touchmove", t.onTouchMove, { passive: !1, capture: o }), n[a]("pointermove", t.onTouchMove, { passive: !1, capture: o }), n[a]("touchend", t.onTouchEnd, { passive: !0 }), n[a]("pointerup", t.onTouchEnd, { passive: !0 }), n[a]("pointercancel", t.onTouchEnd, { passive: !0 }), n[a]("touchcancel", t.onTouchEnd, { passive: !0 }), n[a]("pointerout", t.onTouchEnd, { passive: !0 }), n[a]("pointerleave", t.onTouchEnd, { passive: !0 }), n[a]("contextmenu", t.onTouchEnd, { passive: !0 }), (r.preventClicks || r.preventClicksPropagation) && i[a]("click", t.onClick, !0), r.cssMode && s[a]("scroll", t.onScroll), r.updateOnWindowResize ? t[u](l.ios || l.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", pc, !0) : t[u]("observerUpdate", pc, !0), i[a]("load", t.onLoad, { capture: !0 }) }; function i0() { const t = this, { params: e } = t; t.onTouchStart = Kv.bind(t), t.onTouchMove = Zv.bind(t), t.onTouchEnd = Jv.bind(t), t.onDocumentTouchStart = r0.bind(t), e.cssMode && (t.onScroll = t0.bind(t)), t.onClick = e0.bind(t), t.onLoad = n0.bind(t), fp(t, "on") } function s0() { fp(this, "off") } var l0 = { attachEvents: i0, detachEvents: s0 }; const mc = (t, e) => t.grid && e.grid && e.grid.rows > 1; function a0() { const t = this, { realIndex: e, initialized: n, params: r, el: i } = t, s = r.breakpoints; if (!s || s && Object.keys(s).length === 0) return; const l = t.getBreakpoint(s, t.params.breakpointsBase, t.el); if (!l || t.currentBreakpoint === l) return; const a = (l in s ? s[l] : void 0) || t.originalParams, u = mc(t, r), c = mc(t, a), d = t.params.grabCursor, f = a.grabCursor, v = r.enabled; u && !c ? (i.classList.remove(`${r.containerModifierClass}grid`, `${r.containerModifierClass}grid-column`), t.emitContainerClasses()) : !u && c && (i.classList.add(`${r.containerModifierClass}grid`), (a.grid.fill && a.grid.fill === "column" || !a.grid.fill && r.grid.fill === "column") && i.classList.add(`${r.containerModifierClass}grid-column`), t.emitContainerClasses()), d && !f ? t.unsetGrabCursor() : !d && f && t.setGrabCursor(), ["navigation", "pagination", "scrollbar"].forEach(h => { if (typeof a[h] > "u") return; const S = r[h] && r[h].enabled, x = a[h] && a[h].enabled; S && !x && t[h].disable(), !S && x && t[h].enable() }); const g = a.direction && a.direction !== r.direction, w = r.loop && (a.slidesPerView !== r.slidesPerView || g), y = r.loop; g && n && t.changeDirection(), je(t.params, a); const p = t.params.enabled, m = t.params.loop; Object.assign(t, { allowTouchMove: t.params.allowTouchMove, allowSlideNext: t.params.allowSlideNext, allowSlidePrev: t.params.allowSlidePrev }), v && !p ? t.disable() : !v && p && t.enable(), t.currentBreakpoint = l, t.emit("_beforeBreakpoint", a), n && (w ? (t.loopDestroy(), t.loopCreate(e), t.updateSlides()) : !y && m ? (t.loopCreate(e), t.updateSlides()) : y && !m && t.loopDestroy()), t.emit("breakpoint", a) } function o0(t, e, n) { if (e === void 0 && (e = "window"), !t || e === "container" && !n) return; let r = !1; const i = se(), s = e === "window" ? i.innerHeight : n.clientHeight, l = Object.keys(t).map(o => { if (typeof o == "string" && o.indexOf("@") === 0) { const a = parseFloat(o.substr(1)); return { value: s * a, point: o } } return { value: o, point: o } }); l.sort((o, a) => parseInt(o.value, 10) - parseInt(a.value, 10)); for (let o = 0; o < l.length; o += 1) { const { point: a, value: u } = l[o]; e === "window" ? i.matchMedia(`(min-width: ${u}px)`).matches && (r = a) : u <= n.clientWidth && (r = a) } return r || "max" } var u0 = { setBreakpoint: a0, getBreakpoint: o0 }; function c0(t, e) { const n = []; return t.forEach(r => { typeof r == "object" ? Object.keys(r).forEach(i => { r[i] && n.push(e + i) }) : typeof r == "string" && n.push(e + r) }), n } function d0() { const t = this, { classNames: e, params: n, rtl: r, el: i, device: s } = t, l = c0(["initialized", n.direction, { "free-mode": t.params.freeMode && n.freeMode.enabled }, { autoheight: n.autoHeight }, { rtl: r }, { grid: n.grid && n.grid.rows > 1 }, { "grid-column": n.grid && n.grid.rows > 1 && n.grid.fill === "column" }, { android: s.android }, { ios: s.ios }, { "css-mode": n.cssMode }, { centered: n.cssMode && n.centeredSlides }, { "watch-progress": n.watchSlidesProgress }], n.containerModifierClass); e.push(...l), i.classList.add(...e), t.emitContainerClasses() } function f0() { const t = this, { el: e, classNames: n } = t; e.classList.remove(...n), t.emitContainerClasses() } var p0 = { addClasses: d0, removeClasses: f0 }; function m0() { const t = this, { isLocked: e, params: n } = t, { slidesOffsetBefore: r } = n; if (r) { const i = t.slides.length - 1, s = t.slidesGrid[i] + t.slidesSizesGrid[i] + r * 2; t.isLocked = t.size > s } else t.isLocked = t.snapGrid.length === 1; n.allowSlideNext === !0 && (t.allowSlideNext = !t.isLocked), n.allowSlidePrev === !0 && (t.allowSlidePrev = !t.isLocked), e && e !== t.isLocked && (t.isEnd = !1), e !== t.isLocked && t.emit(t.isLocked ? "lock" : "unlock") } var h0 = { checkOverflow: m0 }, Sa = { init: !0, direction: "horizontal", oneWayMovement: !1, swiperElementNodeName: "SWIPER-CONTAINER", touchEventsTarget: "wrapper", initialSlide: 0, speed: 300, cssMode: !1, updateOnWindowResize: !0, resizeObserver: !0, nested: !1, createElements: !1, eventsPrefix: "swiper", enabled: !0, focusableElements: "input, select, option, textarea, button, video, label", width: null, height: null, preventInteractionOnTransition: !1, userAgent: null, url: null, edgeSwipeDetection: !1, edgeSwipeThreshold: 20, autoHeight: !1, setWrapperSize: !1, virtualTranslate: !1, effect: "slide", breakpoints: void 0, breakpointsBase: "window", spaceBetween: 0, slidesPerView: 1, slidesPerGroup: 1, slidesPerGroupSkip: 0, slidesPerGroupAuto: !1, centeredSlides: !1, centeredSlidesBounds: !1, slidesOffsetBefore: 0, slidesOffsetAfter: 0, normalizeSlideIndex: !0, centerInsufficientSlides: !1, watchOverflow: !0, roundLengths: !1, touchRatio: 1, touchAngle: 45, simulateTouch: !0, shortSwipes: !0, longSwipes: !0, longSwipesRatio: .5, longSwipesMs: 300, followFinger: !0, allowTouchMove: !0, threshold: 5, touchMoveStopPropagation: !1, touchStartPreventDefault: !0, touchStartForcePreventDefault: !1, touchReleaseOnEdges: !1, uniqueNavElements: !0, resistance: !0, resistanceRatio: .85, watchSlidesProgress: !1, grabCursor: !1, preventClicks: !0, preventClicksPropagation: !0, slideToClickedSlide: !1, loop: !1, loopAddBlankSlides: !0, loopAdditionalSlides: 0, loopPreventsSliding: !0, rewind: !1, allowSlidePrev: !0, allowSlideNext: !0, swipeHandler: null, noSwiping: !0, noSwipingClass: "swiper-no-swiping", noSwipingSelector: null, passiveListeners: !0, maxBackfaceHiddenSlides: 10, containerModifierClass: "swiper-", slideClass: "swiper-slide", slideBlankClass: "swiper-slide-blank", slideActiveClass: "swiper-slide-active", slideVisibleClass: "swiper-slide-visible", slideFullyVisibleClass: "swiper-slide-fully-visible", slideNextClass: "swiper-slide-next", slidePrevClass: "swiper-slide-prev", wrapperClass: "swiper-wrapper", lazyPreloaderClass: "swiper-lazy-preloader", lazyPreloadPrevNext: 0, runCallbacksOnInit: !0, _emitClasses: !1 }; function g0(t, e) { return function (r) { r === void 0 && (r = {}); const i = Object.keys(r)[0], s = r[i]; if (typeof s != "object" || s === null) { je(e, r); return } if (t[i] === !0 && (t[i] = { enabled: !0 }), i === "navigation" && t[i] && t[i].enabled && !t[i].prevEl && !t[i].nextEl && (t[i].auto = !0), ["pagination", "scrollbar"].indexOf(i) >= 0 && t[i] && t[i].enabled && !t[i].el && (t[i].auto = !0), !(i in t && "enabled" in s)) { je(e, r); return } typeof t[i] == "object" && !("enabled" in t[i]) && (t[i].enabled = !0), t[i] || (t[i] = { enabled: !1 }), je(e, r) } } const vl = { eventsEmitter: pv, update: bv, translate: Lv, transition: Nv, slide: Bv, loop: Xv, grabCursor: qv, events: l0, breakpoints: u0, checkOverflow: h0, classes: p0 }, wl = {}; class $e { constructor() { let e, n; for (var r = arguments.length, i = new Array(r), s = 0; s < r; s++)i[s] = arguments[s]; i.length === 1 && i[0].constructor && Object.prototype.toString.call(i[0]).slice(8, -1) === "Object" ? n = i[0] : [e, n] = i, n || (n = {}), n = je({}, n), e && !n.el && (n.el = e); const l = we(); if (n.el && typeof n.el == "string" && l.querySelectorAll(n.el).length > 1) { const c = []; return l.querySelectorAll(n.el).forEach(d => { const f = je({}, n, { el: d }); c.push(new $e(f)) }), c } const o = this; o.__swiper__ = !0, o.support = up(), o.device = cp({ userAgent: n.userAgent }), o.browser = cv(), o.eventsListeners = {}, o.eventsAnyListeners = [], o.modules = [...o.__modules__], n.modules && Array.isArray(n.modules) && o.modules.push(...n.modules); const a = {}; o.modules.forEach(c => { c({ params: n, swiper: o, extendParams: g0(n, a), on: o.on.bind(o), once: o.once.bind(o), off: o.off.bind(o), emit: o.emit.bind(o) }) }); const u = je({}, Sa, a); return o.params = je({}, u, wl, n), o.originalParams = je({}, o.params), o.passedParams = je({}, n), o.params && o.params.on && Object.keys(o.params.on).forEach(c => { o.on(c, o.params.on[c]) }), o.params && o.params.onAny && o.onAny(o.params.onAny), Object.assign(o, { enabled: o.params.enabled, el: e, classNames: [], slides: [], slidesGrid: [], snapGrid: [], slidesSizesGrid: [], isHorizontal() { return o.params.direction === "horizontal" }, isVertical() { return o.params.direction === "vertical" }, activeIndex: 0, realIndex: 0, isBeginning: !0, isEnd: !1, translate: 0, previousTranslate: 0, progress: 0, velocity: 0, animating: !1, cssOverflowAdjustment() { return Math.trunc(this.translate / 2 ** 23) * 2 ** 23 }, allowSlideNext: o.params.allowSlideNext, allowSlidePrev: o.params.allowSlidePrev, touchEventsData: { isTouched: void 0, isMoved: void 0, allowTouchCallbacks: void 0, touchStartTime: void 0, isScrolling: void 0, currentTranslate: void 0, startTranslate: void 0, allowThresholdMove: void 0, focusableElements: o.params.focusableElements, lastClickTime: 0, clickTimeout: void 0, velocities: [], allowMomentumBounce: void 0, startMoving: void 0, pointerId: null, touchId: null }, allowClick: !0, allowTouchMove: o.params.allowTouchMove, touches: { startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0 }, imagesToLoad: [], imagesLoaded: 0 }), o.emit("_swiper"), o.params.init && o.init(), o } getDirectionLabel(e) { return this.isHorizontal() ? e : { width: "height", "margin-top": "margin-left", "margin-bottom ": "margin-right", "margin-left": "margin-top", "margin-right": "margin-bottom", "padding-left": "padding-top", "padding-right": "padding-bottom", marginRight: "marginBottom" }[e] } getSlideIndex(e) { const { slidesEl: n, params: r } = this, i = ge(n, `.${r.slideClass}, swiper-slide`), s = Hr(i[0]); return Hr(e) - s } getSlideIndexByData(e) { return this.getSlideIndex(this.slides.filter(n => n.getAttribute("data-swiper-slide-index") * 1 === e)[0]) } recalcSlides() { const e = this, { slidesEl: n, params: r } = e; e.slides = ge(n, `.${r.slideClass}, swiper-slide`) } enable() { const e = this; e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit("enable")) } disable() { const e = this; e.enabled && (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit("disable")) } setProgress(e, n) { const r = this; e = Math.min(Math.max(e, 0), 1); const i = r.minTranslate(), l = (r.maxTranslate() - i) * e + i; r.translateTo(l, typeof n > "u" ? 0 : n), r.updateActiveIndex(), r.updateSlidesClasses() } emitContainerClasses() { const e = this; if (!e.params._emitClasses || !e.el) return; const n = e.el.className.split(" ").filter(r => r.indexOf("swiper") === 0 || r.indexOf(e.params.containerModifierClass) === 0); e.emit("_containerClasses", n.join(" ")) } getSlideClasses(e) { const n = this; return n.destroyed ? "" : e.className.split(" ").filter(r => r.indexOf("swiper-slide") === 0 || r.indexOf(n.params.slideClass) === 0).join(" ") } emitSlidesClasses() { const e = this; if (!e.params._emitClasses || !e.el) return; const n = []; e.slides.forEach(r => { const i = e.getSlideClasses(r); n.push({ slideEl: r, classNames: i }), e.emit("_slideClass", r, i) }), e.emit("_slideClasses", n) } slidesPerViewDynamic(e, n) { e === void 0 && (e = "current"), n === void 0 && (n = !1); const r = this, { params: i, slides: s, slidesGrid: l, slidesSizesGrid: o, size: a, activeIndex: u } = r; let c = 1; if (typeof i.slidesPerView == "number") return i.slidesPerView; if (i.centeredSlides) { let d = s[u] ? Math.ceil(s[u].swiperSlideSize) : 0, f; for (let v = u + 1; v < s.length; v += 1)s[v] && !f && (d += Math.ceil(s[v].swiperSlideSize), c += 1, d > a && (f = !0)); for (let v = u - 1; v >= 0; v -= 1)s[v] && !f && (d += s[v].swiperSlideSize, c += 1, d > a && (f = !0)) } else if (e === "current") for (let d = u + 1; d < s.length; d += 1)(n ? l[d] + o[d] - l[u] < a : l[d] - l[u] < a) && (c += 1); else for (let d = u - 1; d >= 0; d -= 1)l[u] - l[d] < a && (c += 1); return c } update() { const e = this; if (!e || e.destroyed) return; const { snapGrid: n, params: r } = e; r.breakpoints && e.setBreakpoint(), [...e.el.querySelectorAll('[loading="lazy"]')].forEach(l => { l.complete && zi(e, l) }), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(); function i() { const l = e.rtlTranslate ? e.translate * -1 : e.translate, o = Math.min(Math.max(l, e.maxTranslate()), e.minTranslate()); e.setTranslate(o), e.updateActiveIndex(), e.updateSlidesClasses() } let s; if (r.freeMode && r.freeMode.enabled && !r.cssMode) i(), r.autoHeight && e.updateAutoHeight(); else { if ((r.slidesPerView === "auto" || r.slidesPerView > 1) && e.isEnd && !r.centeredSlides) { const l = e.virtual && r.virtual.enabled ? e.virtual.slides : e.slides; s = e.slideTo(l.length - 1, 0, !1, !0) } else s = e.slideTo(e.activeIndex, 0, !1, !0); s || i() } r.watchOverflow && n !== e.snapGrid && e.checkOverflow(), e.emit("update") } changeDirection(e, n) { n === void 0 && (n = !0); const r = this, i = r.params.direction; return e || (e = i === "horizontal" ? "vertical" : "horizontal"), e === i || e !== "horizontal" && e !== "vertical" || (r.el.classList.remove(`${r.params.containerModifierClass}${i}`), r.el.classList.add(`${r.params.containerModifierClass}${e}`), r.emitContainerClasses(), r.params.direction = e, r.slides.forEach(s => { e === "vertical" ? s.style.width = "" : s.style.height = "" }), r.emit("changeDirection"), n && r.update()), r } changeLanguageDirection(e) { const n = this; n.rtl && e === "rtl" || !n.rtl && e === "ltr" || (n.rtl = e === "rtl", n.rtlTranslate = n.params.direction === "horizontal" && n.rtl, n.rtl ? (n.el.classList.add(`${n.params.containerModifierClass}rtl`), n.el.dir = "rtl") : (n.el.classList.remove(`${n.params.containerModifierClass}rtl`), n.el.dir = "ltr"), n.update()) } mount(e) { const n = this; if (n.mounted) return !0; let r = e || n.params.el; if (typeof r == "string" && (r = document.querySelector(r)), !r) return !1; r.swiper = n, r.parentNode && r.parentNode.host && r.parentNode.host.nodeName === n.params.swiperElementNodeName.toUpperCase() && (n.isElement = !0); const i = () => `.${(n.params.wrapperClass || "").trim().split(" ").join(".")}`; let l = r && r.shadowRoot && r.shadowRoot.querySelector ? r.shadowRoot.querySelector(i()) : ge(r, i())[0]; return !l && n.params.createElements && (l = He("div", n.params.wrapperClass), r.append(l), ge(r, `.${n.params.slideClass}`).forEach(o => { l.append(o) })), Object.assign(n, { el: r, wrapperEl: l, slidesEl: n.isElement && !r.parentNode.host.slideSlots ? r.parentNode.host : l, hostEl: n.isElement ? r.parentNode.host : r, mounted: !0, rtl: r.dir.toLowerCase() === "rtl" || zt(r, "direction") === "rtl", rtlTranslate: n.params.direction === "horizontal" && (r.dir.toLowerCase() === "rtl" || zt(r, "direction") === "rtl"), wrongRTL: zt(l, "display") === "-webkit-box" }), !0 } init(e) { const n = this; if (n.initialized || n.mount(e) === !1) return n; n.emit("beforeInit"), n.params.breakpoints && n.setBreakpoint(), n.addClasses(), n.updateSize(), n.updateSlides(), n.params.watchOverflow && n.checkOverflow(), n.params.grabCursor && n.enabled && n.setGrabCursor(), n.params.loop && n.virtual && n.params.virtual.enabled ? n.slideTo(n.params.initialSlide + n.virtual.slidesBefore, 0, n.params.runCallbacksOnInit, !1, !0) : n.slideTo(n.params.initialSlide, 0, n.params.runCallbacksOnInit, !1, !0), n.params.loop && n.loopCreate(), n.attachEvents(); const i = [...n.el.querySelectorAll('[loading="lazy"]')]; return n.isElement && i.push(...n.hostEl.querySelectorAll('[loading="lazy"]')), i.forEach(s => { s.complete ? zi(n, s) : s.addEventListener("load", l => { zi(n, l.target) }) }), ya(n), n.initialized = !0, ya(n), n.emit("init"), n.emit("afterInit"), n } destroy(e, n) { e === void 0 && (e = !0), n === void 0 && (n = !0); const r = this, { params: i, el: s, wrapperEl: l, slides: o } = r; return typeof r.params > "u" || r.destroyed || (r.emit("beforeDestroy"), r.initialized = !1, r.detachEvents(), i.loop && r.loopDestroy(), n && (r.removeClasses(), s.removeAttribute("style"), l.removeAttribute("style"), o && o.length && o.forEach(a => { a.classList.remove(i.slideVisibleClass, i.slideFullyVisibleClass, i.slideActiveClass, i.slideNextClass, i.slidePrevClass), a.removeAttribute("style"), a.removeAttribute("data-swiper-slide-index") })), r.emit("destroy"), Object.keys(r.eventsListeners).forEach(a => { r.off(a) }), e !== !1 && (r.el.swiper = null, nv(r)), r.destroyed = !0), null } static extendDefaults(e) { je(wl, e) } static get extendedDefaults() { return wl } static get defaults() { return Sa } static installModule(e) { $e.prototype.__modules__ || ($e.prototype.__modules__ = []); const n = $e.prototype.__modules__; typeof e == "function" && n.indexOf(e) < 0 && n.push(e) } static use(e) { return Array.isArray(e) ? (e.forEach(n => $e.installModule(n)), $e) : ($e.installModule(e), $e) } } Object.keys(vl).forEach(t => { Object.keys(vl[t]).forEach(e => { $e.prototype[e] = vl[t][e] }) }); $e.use([dv, fv]); function v0(t) { let { swiper: e, extendParams: n, on: r, emit: i } = t; n({ virtual: { enabled: !1, slides: [], cache: !0, renderSlide: null, renderExternal: null, renderExternalUpdate: !0, addSlidesBefore: 0, addSlidesAfter: 0 } }); let s; const l = we(); e.virtual = { cache: {}, from: void 0, to: void 0, slides: [], offset: 0, slidesGrid: [] }; const o = l.createElement("div"); function a(g, w) { const y = e.params.virtual; if (y.cache && e.virtual.cache[w]) return e.virtual.cache[w]; let p; return y.renderSlide ? (p = y.renderSlide.call(e, g, w), typeof p == "string" && (o.innerHTML = p, p = o.children[0])) : e.isElement ? p = He("swiper-slide") : p = He("div", e.params.slideClass), p.setAttribute("data-swiper-slide-index", w), y.renderSlide || (p.innerHTML = g), y.cache && (e.virtual.cache[w] = p), p } function u(g, w) { const { slidesPerView: y, slidesPerGroup: p, centeredSlides: m, loop: h, initialSlide: S } = e.params; if (w && !h && S > 0) return; const { addSlidesBefore: x, addSlidesAfter: T } = e.params.virtual, { from: L, to: b, slides: C, slidesGrid: P, offset: N } = e.virtual; e.params.cssMode || e.updateActiveIndex(); const M = e.activeIndex || 0; let _; e.rtlTranslate ? _ = "right" : _ = e.isHorizontal() ? "left" : "top"; let O, R; m ? (O = Math.floor(y / 2) + p + T, R = Math.floor(y / 2) + p + x) : (O = y + (p - 1) + T, R = (h ? y : p) + x); let j = M - R, I = M + O; h || (j = Math.max(j, 0), I = Math.min(I, C.length - 1)); let E = (e.slidesGrid[j] || 0) - (e.slidesGrid[0] || 0); h && M >= R ? (j -= R, m || (E += e.slidesGrid[0])) : h && M < R && (j = -R, m && (E += e.slidesGrid[0])), Object.assign(e.virtual, { from: j, to: I, offset: E, slidesGrid: e.slidesGrid, slidesBefore: R, slidesAfter: O }); function k() { e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), i("virtualUpdate") } if (L === j && b === I && !g) { e.slidesGrid !== P && E !== N && e.slides.forEach(H => { H.style[_] = `${E - Math.abs(e.cssOverflowAdjustment())}px` }), e.updateProgress(), i("virtualUpdate"); return } if (e.params.virtual.renderExternal) { e.params.virtual.renderExternal.call(e, { offset: E, from: j, to: I, slides: function () { const X = []; for (let re = j; re <= I; re += 1)X.push(C[re]); return X }() }), e.params.virtual.renderExternalUpdate ? k() : i("virtualUpdate"); return } const z = [], F = [], B = H => { let X = H; return H < 0 ? X = C.length + H : X >= C.length && (X = X - C.length), X }; if (g) e.slides.filter(H => H.matches(`.${e.params.slideClass}, swiper-slide`)).forEach(H => { H.remove() }); else for (let H = L; H <= b; H += 1)if (H < j || H > I) { const X = B(H); e.slides.filter(re => re.matches(`.${e.params.slideClass}[data-swiper-slide-index="${X}"], swiper-slide[data-swiper-slide-index="${X}"]`)).forEach(re => { re.remove() }) } const ue = h ? -C.length : 0, fe = h ? C.length * 2 : C.length; for (let H = ue; H < fe; H += 1)if (H >= j && H <= I) { const X = B(H); typeof b > "u" || g ? F.push(X) : (H > b && F.push(X), H < L && z.push(X)) } if (F.forEach(H => { e.slidesEl.append(a(C[H], H)) }), h) for (let H = z.length - 1; H >= 0; H -= 1) { const X = z[H]; e.slidesEl.prepend(a(C[X], X)) } else z.sort((H, X) => X - H), z.forEach(H => { e.slidesEl.prepend(a(C[H], H)) }); ge(e.slidesEl, ".swiper-slide, swiper-slide").forEach(H => { H.style[_] = `${E - Math.abs(e.cssOverflowAdjustment())}px` }), k() } function c(g) { if (typeof g == "object" && "length" in g) for (let w = 0; w < g.length; w += 1)g[w] && e.virtual.slides.push(g[w]); else e.virtual.slides.push(g); u(!0) } function d(g) { const w = e.activeIndex; let y = w + 1, p = 1; if (Array.isArray(g)) { for (let m = 0; m < g.length; m += 1)g[m] && e.virtual.slides.unshift(g[m]); y = w + g.length, p = g.length } else e.virtual.slides.unshift(g); if (e.params.virtual.cache) { const m = e.virtual.cache, h = {}; Object.keys(m).forEach(S => { const x = m[S], T = x.getAttribute("data-swiper-slide-index"); T && x.setAttribute("data-swiper-slide-index", parseInt(T, 10) + p), h[parseInt(S, 10) + p] = x }), e.virtual.cache = h } u(!0), e.slideTo(y, 0) } function f(g) { if (typeof g > "u" || g === null) return; let w = e.activeIndex; if (Array.isArray(g)) for (let y = g.length - 1; y >= 0; y -= 1)e.params.virtual.cache && (delete e.virtual.cache[g[y]], Object.keys(e.virtual.cache).forEach(p => { p > g && (e.virtual.cache[p - 1] = e.virtual.cache[p], e.virtual.cache[p - 1].setAttribute("data-swiper-slide-index", p - 1), delete e.virtual.cache[p]) })), e.virtual.slides.splice(g[y], 1), g[y] < w && (w -= 1), w = Math.max(w, 0); else e.params.virtual.cache && (delete e.virtual.cache[g], Object.keys(e.virtual.cache).forEach(y => { y > g && (e.virtual.cache[y - 1] = e.virtual.cache[y], e.virtual.cache[y - 1].setAttribute("data-swiper-slide-index", y - 1), delete e.virtual.cache[y]) })), e.virtual.slides.splice(g, 1), g < w && (w -= 1), w = Math.max(w, 0); u(!0), e.slideTo(w, 0) } function v() { e.virtual.slides = [], e.params.virtual.cache && (e.virtual.cache = {}), u(!0), e.slideTo(0, 0) } r("beforeInit", () => { if (!e.params.virtual.enabled) return; let g; if (typeof e.passedParams.virtual.slides > "u") { const w = [...e.slidesEl.children].filter(y => y.matches(`.${e.params.slideClass}, swiper-slide`)); w && w.length && (e.virtual.slides = [...w], g = !0, w.forEach((y, p) => { y.setAttribute("data-swiper-slide-index", p), e.virtual.cache[p] = y, y.remove() })) } g || (e.virtual.slides = e.params.virtual.slides), e.classNames.push(`${e.params.containerModifierClass}virtual`), e.params.watchSlidesProgress = !0, e.originalParams.watchSlidesProgress = !0, u(!1, !0) }), r("setTranslate", () => { e.params.virtual.enabled && (e.params.cssMode && !e._immediateVirtual ? (clearTimeout(s), s = setTimeout(() => { u() }, 100)) : u()) }), r("init update resize", () => { e.params.virtual.enabled && e.params.cssMode && dr(e.wrapperEl, "--swiper-virtual-size", `${e.virtualSize}px`) }), Object.assign(e.virtual, { appendSlide: c, prependSlide: d, removeSlide: f, removeAllSlides: v, update: u }) } function w0(t) { let { swiper: e, extendParams: n, on: r, emit: i } = t; const s = we(), l = se(); e.keyboard = { enabled: !1 }, n({ keyboard: { enabled: !1, onlyInViewport: !0, pageUpDown: !0 } }); function o(c) { if (!e.enabled) return; const { rtlTranslate: d } = e; let f = c; f.originalEvent && (f = f.originalEvent); const v = f.keyCode || f.charCode, g = e.params.keyboard.pageUpDown, w = g && v === 33, y = g && v === 34, p = v === 37, m = v === 39, h = v === 38, S = v === 40; if (!e.allowSlideNext && (e.isHorizontal() && m || e.isVertical() && S || y) || !e.allowSlidePrev && (e.isHorizontal() && p || e.isVertical() && h || w)) return !1; if (!(f.shiftKey || f.altKey || f.ctrlKey || f.metaKey) && !(s.activeElement && s.activeElement.nodeName && (s.activeElement.nodeName.toLowerCase() === "input" || s.activeElement.nodeName.toLowerCase() === "textarea"))) { if (e.params.keyboard.onlyInViewport && (w || y || p || m || h || S)) { let x = !1; if (rn(e.el, `.${e.params.slideClass}, swiper-slide`).length > 0 && rn(e.el, `.${e.params.slideActiveClass}`).length === 0) return; const T = e.el, L = T.clientWidth, b = T.clientHeight, C = l.innerWidth, P = l.innerHeight, N = ss(T); d && (N.left -= T.scrollLeft); const M = [[N.left, N.top], [N.left + L, N.top], [N.left, N.top + b], [N.left + L, N.top + b]]; for (let _ = 0; _ < M.length; _ += 1) { const O = M[_]; if (O[0] >= 0 && O[0] <= C && O[1] >= 0 && O[1] <= P) { if (O[0] === 0 && O[1] === 0) continue; x = !0 } } if (!x) return } e.isHorizontal() ? ((w || y || p || m) && (f.preventDefault ? f.preventDefault() : f.returnValue = !1), ((y || m) && !d || (w || p) && d) && e.slideNext(), ((w || p) && !d || (y || m) && d) && e.slidePrev()) : ((w || y || h || S) && (f.preventDefault ? f.preventDefault() : f.returnValue = !1), (y || S) && e.slideNext(), (w || h) && e.slidePrev()), i("keyPress", v) } } function a() { e.keyboard.enabled || (s.addEventListener("keydown", o), e.keyboard.enabled = !0) } function u() { e.keyboard.enabled && (s.removeEventListener("keydown", o), e.keyboard.enabled = !1) } r("init", () => { e.params.keyboard.enabled && a() }), r("destroy", () => { e.keyboard.enabled && u() }), Object.assign(e.keyboard, { enable: a, disable: u }) } function y0(t) { let { swiper: e, extendParams: n, on: r, emit: i } = t; const s = se(); n({ mousewheel: { enabled: !1, releaseOnEdges: !1, invert: !1, forceToAxis: !1, sensitivity: 1, eventsTarget: "container", thresholdDelta: null, thresholdTime: null, noMousewheelClass: "swiper-no-mousewheel" } }), e.mousewheel = { enabled: !1 }; let l, o = Ye(), a; const u = []; function c(h) { let L = 0, b = 0, C = 0, P = 0; return "detail" in h && (b = h.detail), "wheelDelta" in h && (b = -h.wheelDelta / 120), "wheelDeltaY" in h && (b = -h.wheelDeltaY / 120), "wheelDeltaX" in h && (L = -h.wheelDeltaX / 120), "axis" in h && h.axis === h.HORIZONTAL_AXIS && (L = b, b = 0), C = L * 10, P = b * 10, "deltaY" in h && (P = h.deltaY), "deltaX" in h && (C = h.deltaX), h.shiftKey && !C && (C = P, P = 0), (C || P) && h.deltaMode && (h.deltaMode === 1 ? (C *= 40, P *= 40) : (C *= 800, P *= 800)), C && !L && (L = C < 1 ? -1 : 1), P && !b && (b = P < 1 ? -1 : 1), { spinX: L, spinY: b, pixelX: C, pixelY: P } } function d() { e.enabled && (e.mouseEntered = !0) } function f() { e.enabled && (e.mouseEntered = !1) } function v(h) { return e.params.mousewheel.thresholdDelta && h.delta < e.params.mousewheel.thresholdDelta || e.params.mousewheel.thresholdTime && Ye() - o < e.params.mousewheel.thresholdTime ? !1 : h.delta >= 6 && Ye() - o < 60 ? !0 : (h.direction < 0 ? (!e.isEnd || e.params.loop) && !e.animating && (e.slideNext(), i("scroll", h.raw)) : (!e.isBeginning || e.params.loop) && !e.animating && (e.slidePrev(), i("scroll", h.raw)), o = new s.Date().getTime(), !1) } function g(h) { const S = e.params.mousewheel; if (h.direction < 0) { if (e.isEnd && !e.params.loop && S.releaseOnEdges) return !0 } else if (e.isBeginning && !e.params.loop && S.releaseOnEdges) return !0; return !1 } function w(h) { let S = h, x = !0; if (!e.enabled || h.target.closest(`.${e.params.mousewheel.noMousewheelClass}`)) return; const T = e.params.mousewheel; e.params.cssMode && S.preventDefault(); let L = e.el; e.params.mousewheel.eventsTarget !== "container" && (L = document.querySelector(e.params.mousewheel.eventsTarget)); const b = L && L.contains(S.target); if (!e.mouseEntered && !b && !T.releaseOnEdges) return !0; S.originalEvent && (S = S.originalEvent); let C = 0; const P = e.rtlTranslate ? -1 : 1, N = c(S); if (T.forceToAxis) if (e.isHorizontal()) if (Math.abs(N.pixelX) > Math.abs(N.pixelY)) C = -N.pixelX * P; else return !0; else if (Math.abs(N.pixelY) > Math.abs(N.pixelX)) C = -N.pixelY; else return !0; else C = Math.abs(N.pixelX) > Math.abs(N.pixelY) ? -N.pixelX * P : -N.pixelY; if (C === 0) return !0; T.invert && (C = -C); let M = e.getTranslate() + C * T.sensitivity; if (M >= e.minTranslate() && (M = e.minTranslate()), M <= e.maxTranslate() && (M = e.maxTranslate()), x = e.params.loop ? !0 : !(M === e.minTranslate() || M === e.maxTranslate()), x && e.params.nested && S.stopPropagation(), !e.params.freeMode || !e.params.freeMode.enabled) { const _ = { time: Ye(), delta: Math.abs(C), direction: Math.sign(C), raw: h }; u.length >= 2 && u.shift(); const O = u.length ? u[u.length - 1] : void 0; if (u.push(_), O ? (_.direction !== O.direction || _.delta > O.delta || _.time > O.time + 150) && v(_) : v(_), g(_)) return !0 } else { const _ = { time: Ye(), delta: Math.abs(C), direction: Math.sign(C) }, O = a && _.time < a.time + 500 && _.delta <= a.delta && _.direction === a.direction; if (!O) { a = void 0; let R = e.getTranslate() + C * T.sensitivity; const j = e.isBeginning, I = e.isEnd; if (R >= e.minTranslate() && (R = e.minTranslate()), R <= e.maxTranslate() && (R = e.maxTranslate()), e.setTransition(0), e.setTranslate(R), e.updateProgress(), e.updateActiveIndex(), e.updateSlidesClasses(), (!j && e.isBeginning || !I && e.isEnd) && e.updateSlidesClasses(), e.params.loop && e.loopFix({ direction: _.direction < 0 ? "next" : "prev", byMousewheel: !0 }), e.params.freeMode.sticky) { clearTimeout(l), l = void 0, u.length >= 15 && u.shift(); const E = u.length ? u[u.length - 1] : void 0, k = u[0]; if (u.push(_), E && (_.delta > E.delta || _.direction !== E.direction)) u.splice(0); else if (u.length >= 15 && _.time - k.time < 500 && k.delta - _.delta >= 1 && _.delta <= 6) { const z = C > 0 ? .8 : .2; a = _, u.splice(0), l = cn(() => { e.slideToClosest(e.params.speed, !0, void 0, z) }, 0) } l || (l = cn(() => { a = _, u.splice(0), e.slideToClosest(e.params.speed, !0, void 0, .5) }, 500)) } if (O || i("scroll", S), e.params.autoplay && e.params.autoplayDisableOnInteraction && e.autoplay.stop(), T.releaseOnEdges && (R === e.minTranslate() || R === e.maxTranslate())) return !0 } } return S.preventDefault ? S.preventDefault() : S.returnValue = !1, !1 } function y(h) { let S = e.el; e.params.mousewheel.eventsTarget !== "container" && (S = document.querySelector(e.params.mousewheel.eventsTarget)), S[h]("mouseenter", d), S[h]("mouseleave", f), S[h]("wheel", w) } function p() { return e.params.cssMode ? (e.wrapperEl.removeEventListener("wheel", w), !0) : e.mousewheel.enabled ? !1 : (y("addEventListener"), e.mousewheel.enabled = !0, !0) } function m() { return e.params.cssMode ? (e.wrapperEl.addEventListener(event, w), !0) : e.mousewheel.enabled ? (y("removeEventListener"), e.mousewheel.enabled = !1, !0) : !1 } r("init", () => { !e.params.mousewheel.enabled && e.params.cssMode && m(), e.params.mousewheel.enabled && p() }), r("destroy", () => { e.params.cssMode && p(), e.mousewheel.enabled && m() }), Object.assign(e.mousewheel, { enable: p, disable: m }) } function Ao(t, e, n, r) { return t.params.createElements && Object.keys(r).forEach(i => { if (!n[i] && n.auto === !0) { let s = ge(t.el, `.${r[i]}`)[0]; s || (s = He("div", r[i]), s.className = r[i], t.el.append(s)), n[i] = s, e[i] = s } }), n } function S0(t) { let { swiper: e, extendParams: n, on: r, emit: i } = t; n({ navigation: { nextEl: null, prevEl: null, hideOnClick: !1, disabledClass: "swiper-button-disabled", hiddenClass: "swiper-button-hidden", lockClass: "swiper-button-lock", navigationDisabledClass: "swiper-navigation-disabled" } }), e.navigation = { nextEl: null, prevEl: null }; function s(g) { let w; return g && typeof g == "string" && e.isElement && (w = e.el.querySelector(g), w) ? w : (g && (typeof g == "string" && (w = [...document.querySelectorAll(g)]), e.params.uniqueNavElements && typeof g == "string" && w && w.length > 1 && e.el.querySelectorAll(g).length === 1 ? w = e.el.querySelector(g) : w && w.length === 1 && (w = w[0])), g && !w ? g : w) } function l(g, w) { const y = e.params.navigation; g = V(g), g.forEach(p => { p && (p.classList[w ? "add" : "remove"](...y.disabledClass.split(" ")), p.tagName === "BUTTON" && (p.disabled = w), e.params.watchOverflow && e.enabled && p.classList[e.isLocked ? "add" : "remove"](y.lockClass)) }) } function o() { const { nextEl: g, prevEl: w } = e.navigation; if (e.params.loop) { l(w, !1), l(g, !1); return } l(w, e.isBeginning && !e.params.rewind), l(g, e.isEnd && !e.params.rewind) } function a(g) { g.preventDefault(), !(e.isBeginning && !e.params.loop && !e.params.rewind) && (e.slidePrev(), i("navigationPrev")) } function u(g) { g.preventDefault(), !(e.isEnd && !e.params.loop && !e.params.rewind) && (e.slideNext(), i("navigationNext")) } function c() { const g = e.params.navigation; if (e.params.navigation = Ao(e, e.originalParams.navigation, e.params.navigation, { nextEl: "swiper-button-next", prevEl: "swiper-button-prev" }), !(g.nextEl || g.prevEl)) return; let w = s(g.nextEl), y = s(g.prevEl); Object.assign(e.navigation, { nextEl: w, prevEl: y }), w = V(w), y = V(y); const p = (m, h) => { m && m.addEventListener("click", h === "next" ? u : a), !e.enabled && m && m.classList.add(...g.lockClass.split(" ")) }; w.forEach(m => p(m, "next")), y.forEach(m => p(m, "prev")) } function d() { let { nextEl: g, prevEl: w } = e.navigation; g = V(g), w = V(w); const y = (p, m) => { p.removeEventListener("click", m === "next" ? u : a), p.classList.remove(...e.params.navigation.disabledClass.split(" ")) }; g.forEach(p => y(p, "next")), w.forEach(p => y(p, "prev")) } r("init", () => { e.params.navigation.enabled === !1 ? v() : (c(), o()) }), r("toEdge fromEdge lock unlock", () => { o() }), r("destroy", () => { d() }), r("enable disable", () => { let { nextEl: g, prevEl: w } = e.navigation; if (g = V(g), w = V(w), e.enabled) { o(); return } [...g, ...w].filter(y => !!y).forEach(y => y.classList.add(e.params.navigation.lockClass)) }), r("click", (g, w) => { let { nextEl: y, prevEl: p } = e.navigation; y = V(y), p = V(p); const m = w.target; if (e.params.navigation.hideOnClick && !p.includes(m) && !y.includes(m)) { if (e.pagination && e.params.pagination && e.params.pagination.clickable && (e.pagination.el === m || e.pagination.el.contains(m))) return; let h; y.length ? h = y[0].classList.contains(e.params.navigation.hiddenClass) : p.length && (h = p[0].classList.contains(e.params.navigation.hiddenClass)), i(h === !0 ? "navigationShow" : "navigationHide"), [...y, ...p].filter(S => !!S).forEach(S => S.classList.toggle(e.params.navigation.hiddenClass)) } }); const f = () => { e.el.classList.remove(...e.params.navigation.navigationDisabledClass.split(" ")), c(), o() }, v = () => { e.el.classList.add(...e.params.navigation.navigationDisabledClass.split(" ")), d() }; Object.assign(e.navigation, { enable: f, disable: v, update: o, init: c, destroy: d }) } function mt(t) { return t === void 0 && (t = ""), `.${t.trim().replace(/([\.:!+\/])/g, "\\$1").replace(/ /g, ".")}` } function E0(t) { let { swiper: e, extendParams: n, on: r, emit: i } = t; const s = "swiper-pagination"; n({ pagination: { el: null, bulletElement: "span", clickable: !1, hideOnClick: !1, renderBullet: null, renderProgressbar: null, renderFraction: null, renderCustom: null, progressbarOpposite: !1, type: "bullets", dynamicBullets: !1, dynamicMainBullets: 1, formatFractionCurrent: p => p, formatFractionTotal: p => p, bulletClass: `${s}-bullet`, bulletActiveClass: `${s}-bullet-active`, modifierClass: `${s}-`, currentClass: `${s}-current`, totalClass: `${s}-total`, hiddenClass: `${s}-hidden`, progressbarFillClass: `${s}-progressbar-fill`, progressbarOppositeClass: `${s}-progressbar-opposite`, clickableClass: `${s}-clickable`, lockClass: `${s}-lock`, horizontalClass: `${s}-horizontal`, verticalClass: `${s}-vertical`, paginationDisabledClass: `${s}-disabled` } }), e.pagination = { el: null, bullets: [] }; let l, o = 0; function a() { return !e.params.pagination.el || !e.pagination.el || Array.isArray(e.pagination.el) && e.pagination.el.length === 0 } function u(p, m) { const { bulletActiveClass: h } = e.params.pagination; p && (p = p[`${m === "prev" ? "previous" : "next"}ElementSibling`], p && (p.classList.add(`${h}-${m}`), p = p[`${m === "prev" ? "previous" : "next"}ElementSibling`], p && p.classList.add(`${h}-${m}-${m}`))) } function c(p) { const m = p.target.closest(mt(e.params.pagination.bulletClass)); if (!m) return; p.preventDefault(); const h = Hr(m) * e.params.slidesPerGroup; if (e.params.loop) { if (e.realIndex === h) return; e.slideToLoop(h) } else e.slideTo(h) } function d() { const p = e.rtl, m = e.params.pagination; if (a()) return; let h = e.pagination.el; h = V(h); let S, x; const T = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length, L = e.params.loop ? Math.ceil(T / e.params.slidesPerGroup) : e.snapGrid.length; if (e.params.loop ? (x = e.previousRealIndex || 0, S = e.params.slidesPerGroup > 1 ? Math.floor(e.realIndex / e.params.slidesPerGroup) : e.realIndex) : typeof e.snapIndex < "u" ? (S = e.snapIndex, x = e.previousSnapIndex) : (x = e.previousIndex || 0, S = e.activeIndex || 0), m.type === "bullets" && e.pagination.bullets && e.pagination.bullets.length > 0) { const b = e.pagination.bullets; let C, P, N; if (m.dynamicBullets && (l = wa(b[0], e.isHorizontal() ? "width" : "height", !0), h.forEach(M => { M.style[e.isHorizontal() ? "width" : "height"] = `${l * (m.dynamicMainBullets + 4)}px` }), m.dynamicMainBullets > 1 && x !== void 0 && (o += S - (x || 0), o > m.dynamicMainBullets - 1 ? o = m.dynamicMainBullets - 1 : o < 0 && (o = 0)), C = Math.max(S - o, 0), P = C + (Math.min(b.length, m.dynamicMainBullets) - 1), N = (P + C) / 2), b.forEach(M => { const _ = [...["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map(O => `${m.bulletActiveClass}${O}`)].map(O => typeof O == "string" && O.includes(" ") ? O.split(" ") : O).flat(); M.classList.remove(..._) }), h.length > 1) b.forEach(M => { const _ = Hr(M); _ === S ? M.classList.add(...m.bulletActiveClass.split(" ")) : e.isElement && M.setAttribute("part", "bullet"), m.dynamicBullets && (_ >= C && _ <= P && M.classList.add(...`${m.bulletActiveClass}-main`.split(" ")), _ === C && u(M, "prev"), _ === P && u(M, "next")) }); else { const M = b[S]; if (M && M.classList.add(...m.bulletActiveClass.split(" ")), e.isElement && b.forEach((_, O) => { _.setAttribute("part", O === S ? "bullet-active" : "bullet") }), m.dynamicBullets) { const _ = b[C], O = b[P]; for (let R = C; R <= P; R += 1)b[R] && b[R].classList.add(...`${m.bulletActiveClass}-main`.split(" ")); u(_, "prev"), u(O, "next") } } if (m.dynamicBullets) { const M = Math.min(b.length, m.dynamicMainBullets + 4), _ = (l * M - l) / 2 - N * l, O = p ? "right" : "left"; b.forEach(R => { R.style[e.isHorizontal() ? O : "top"] = `${_}px` }) } } h.forEach((b, C) => { if (m.type === "fraction" && (b.querySelectorAll(mt(m.currentClass)).forEach(P => { P.textContent = m.formatFractionCurrent(S + 1) }), b.querySelectorAll(mt(m.totalClass)).forEach(P => { P.textContent = m.formatFractionTotal(L) })), m.type === "progressbar") { let P; m.progressbarOpposite ? P = e.isHorizontal() ? "vertical" : "horizontal" : P = e.isHorizontal() ? "horizontal" : "vertical"; const N = (S + 1) / L; let M = 1, _ = 1; P === "horizontal" ? M = N : _ = N, b.querySelectorAll(mt(m.progressbarFillClass)).forEach(O => { O.style.transform = `translate3d(0,0,0) scaleX(${M}) scaleY(${_})`, O.style.transitionDuration = `${e.params.speed}ms` }) } m.type === "custom" && m.renderCustom ? (b.innerHTML = m.renderCustom(e, S + 1, L), C === 0 && i("paginationRender", b)) : (C === 0 && i("paginationRender", b), i("paginationUpdate", b)), e.params.watchOverflow && e.enabled && b.classList[e.isLocked ? "add" : "remove"](m.lockClass) }) } function f() { const p = e.params.pagination; if (a()) return; const m = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.grid && e.params.grid.rows > 1 ? e.slides.length / Math.ceil(e.params.grid.rows) : e.slides.length; let h = e.pagination.el; h = V(h); let S = ""; if (p.type === "bullets") { let x = e.params.loop ? Math.ceil(m / e.params.slidesPerGroup) : e.snapGrid.length; e.params.freeMode && e.params.freeMode.enabled && x > m && (x = m); for (let T = 0; T < x; T += 1)p.renderBullet ? S += p.renderBullet.call(e, T, p.bulletClass) : S += `<${p.bulletElement} ${e.isElement ? 'part="bullet"' : ""} class="${p.bulletClass}"></${p.bulletElement}>` } p.type === "fraction" && (p.renderFraction ? S = p.renderFraction.call(e, p.currentClass, p.totalClass) : S = `<span class="${p.currentClass}"></span> / <span class="${p.totalClass}"></span>`), p.type === "progressbar" && (p.renderProgressbar ? S = p.renderProgressbar.call(e, p.progressbarFillClass) : S = `<span class="${p.progressbarFillClass}"></span>`), e.pagination.bullets = [], h.forEach(x => { p.type !== "custom" && (x.innerHTML = S || ""), p.type === "bullets" && e.pagination.bullets.push(...x.querySelectorAll(mt(p.bulletClass))) }), p.type !== "custom" && i("paginationRender", h[0]) } function v() { e.params.pagination = Ao(e, e.originalParams.pagination, e.params.pagination, { el: "swiper-pagination" }); const p = e.params.pagination; if (!p.el) return; let m; typeof p.el == "string" && e.isElement && (m = e.el.querySelector(p.el)), !m && typeof p.el == "string" && (m = [...document.querySelectorAll(p.el)]), m || (m = p.el), !(!m || m.length === 0) && (e.params.uniqueNavElements && typeof p.el == "string" && Array.isArray(m) && m.length > 1 && (m = [...e.el.querySelectorAll(p.el)], m.length > 1 && (m = m.filter(h => rn(h, ".swiper")[0] === e.el)[0])), Array.isArray(m) && m.length === 1 && (m = m[0]), Object.assign(e.pagination, { el: m }), m = V(m), m.forEach(h => { p.type === "bullets" && p.clickable && h.classList.add(...(p.clickableClass || "").split(" ")), h.classList.add(p.modifierClass + p.type), h.classList.add(e.isHorizontal() ? p.horizontalClass : p.verticalClass), p.type === "bullets" && p.dynamicBullets && (h.classList.add(`${p.modifierClass}${p.type}-dynamic`), o = 0, p.dynamicMainBullets < 1 && (p.dynamicMainBullets = 1)), p.type === "progressbar" && p.progressbarOpposite && h.classList.add(p.progressbarOppositeClass), p.clickable && h.addEventListener("click", c), e.enabled || h.classList.add(p.lockClass) })) } function g() { const p = e.params.pagination; if (a()) return; let m = e.pagination.el; m && (m = V(m), m.forEach(h => { h.classList.remove(p.hiddenClass), h.classList.remove(p.modifierClass + p.type), h.classList.remove(e.isHorizontal() ? p.horizontalClass : p.verticalClass), p.clickable && (h.classList.remove(...(p.clickableClass || "").split(" ")), h.removeEventListener("click", c)) })), e.pagination.bullets && e.pagination.bullets.forEach(h => h.classList.remove(...p.bulletActiveClass.split(" "))) } r("changeDirection", () => { if (!e.pagination || !e.pagination.el) return; const p = e.params.pagination; let { el: m } = e.pagination; m = V(m), m.forEach(h => { h.classList.remove(p.horizontalClass, p.verticalClass), h.classList.add(e.isHorizontal() ? p.horizontalClass : p.verticalClass) }) }), r("init", () => { e.params.pagination.enabled === !1 ? y() : (v(), f(), d()) }), r("activeIndexChange", () => { typeof e.snapIndex > "u" && d() }), r("snapIndexChange", () => { d() }), r("snapGridLengthChange", () => { f(), d() }), r("destroy", () => { g() }), r("enable disable", () => { let { el: p } = e.pagination; p && (p = V(p), p.forEach(m => m.classList[e.enabled ? "remove" : "add"](e.params.pagination.lockClass))) }), r("lock unlock", () => { d() }), r("click", (p, m) => { const h = m.target, S = V(e.pagination.el); if (e.params.pagination.el && e.params.pagination.hideOnClick && S && S.length > 0 && !h.classList.contains(e.params.pagination.bulletClass)) { if (e.navigation && (e.navigation.nextEl && h === e.navigation.nextEl || e.navigation.prevEl && h === e.navigation.prevEl)) return; const x = S[0].classList.contains(e.params.pagination.hiddenClass); i(x === !0 ? "paginationShow" : "paginationHide"), S.forEach(T => T.classList.toggle(e.params.pagination.hiddenClass)) } }); const w = () => { e.el.classList.remove(e.params.pagination.paginationDisabledClass); let { el: p } = e.pagination; p && (p = V(p), p.forEach(m => m.classList.remove(e.params.pagination.paginationDisabledClass))), v(), f(), d() }, y = () => { e.el.classList.add(e.params.pagination.paginationDisabledClass); let { el: p } = e.pagination; p && (p = V(p), p.forEach(m => m.classList.add(e.params.pagination.paginationDisabledClass))), g() }; Object.assign(e.pagination, { enable: w, disable: y, render: f, update: d, init: v, destroy: g }) } function x0(t) { let { swiper: e, extendParams: n, on: r, emit: i } = t; const s = we(); let l = !1, o = null, a = null, u, c, d, f; n({ scrollbar: { el: null, dragSize: "auto", hide: !1, draggable: !1, snapOnRelease: !0, lockClass: "swiper-scrollbar-lock", dragClass: "swiper-scrollbar-drag", scrollbarDisabledClass: "swiper-scrollbar-disabled", horizontalClass: "swiper-scrollbar-horizontal", verticalClass: "swiper-scrollbar-vertical" } }), e.scrollbar = { el: null, dragEl: null }; function v() { if (!e.params.scrollbar.el || !e.scrollbar.el) return; const { scrollbar: M, rtlTranslate: _ } = e, { dragEl: O, el: R } = M, j = e.params.scrollbar, I = e.params.loop ? e.progressLoop : e.progress; let E = c, k = (d - c) * I; _ ? (k = -k, k > 0 ? (E = c - k, k = 0) : -k + c > d && (E = d + k)) : k < 0 ? (E = c + k, k = 0) : k + c > d && (E = d - k), e.isHorizontal() ? (O.style.transform = `translate3d(${k}px, 0, 0)`, O.style.width = `${E}px`) : (O.style.transform = `translate3d(0px, ${k}px, 0)`, O.style.height = `${E}px`), j.hide && (clearTimeout(o), R.style.opacity = 1, o = setTimeout(() => { R.style.opacity = 0, R.style.transitionDuration = "400ms" }, 1e3)) } function g(M) { !e.params.scrollbar.el || !e.scrollbar.el || (e.scrollbar.dragEl.style.transitionDuration = `${M}ms`) } function w() { if (!e.params.scrollbar.el || !e.scrollbar.el) return; const { scrollbar: M } = e, { dragEl: _, el: O } = M; _.style.width = "", _.style.height = "", d = e.isHorizontal() ? O.offsetWidth : O.offsetHeight, f = e.size / (e.virtualSize + e.params.slidesOffsetBefore - (e.params.centeredSlides ? e.snapGrid[0] : 0)), e.params.scrollbar.dragSize === "auto" ? c = d * f : c = parseInt(e.params.scrollbar.dragSize, 10), e.isHorizontal() ? _.style.width = `${c}px` : _.style.height = `${c}px`, f >= 1 ? O.style.display = "none" : O.style.display = "", e.params.scrollbar.hide && (O.style.opacity = 0), e.params.watchOverflow && e.enabled && M.el.classList[e.isLocked ? "add" : "remove"](e.params.scrollbar.lockClass) } function y(M) { return e.isHorizontal() ? M.clientX : M.clientY } function p(M) { const { scrollbar: _, rtlTranslate: O } = e, { el: R } = _; let j; j = (y(M) - ss(R)[e.isHorizontal() ? "left" : "top"] - (u !== null ? u : c / 2)) / (d - c), j = Math.max(Math.min(j, 1), 0), O && (j = 1 - j); const I = e.minTranslate() + (e.maxTranslate() - e.minTranslate()) * j; e.updateProgress(I), e.setTranslate(I), e.updateActiveIndex(), e.updateSlidesClasses() } function m(M) { const _ = e.params.scrollbar, { scrollbar: O, wrapperEl: R } = e, { el: j, dragEl: I } = O; l = !0, u = M.target === I ? y(M) - M.target.getBoundingClientRect()[e.isHorizontal() ? "left" : "top"] : null, M.preventDefault(), M.stopPropagation(), R.style.transitionDuration = "100ms", I.style.transitionDuration = "100ms", p(M), clearTimeout(a), j.style.transitionDuration = "0ms", _.hide && (j.style.opacity = 1), e.params.cssMode && (e.wrapperEl.style["scroll-snap-type"] = "none"), i("scrollbarDragStart", M) } function h(M) { const { scrollbar: _, wrapperEl: O } = e, { el: R, dragEl: j } = _; l && (M.preventDefault && M.cancelable ? M.preventDefault() : M.returnValue = !1, p(M), O.style.transitionDuration = "0ms", R.style.transitionDuration = "0ms", j.style.transitionDuration = "0ms", i("scrollbarDragMove", M)) } function S(M) { const _ = e.params.scrollbar, { scrollbar: O, wrapperEl: R } = e, { el: j } = O; l && (l = !1, e.params.cssMode && (e.wrapperEl.style["scroll-snap-type"] = "", R.style.transitionDuration = ""), _.hide && (clearTimeout(a), a = cn(() => { j.style.opacity = 0, j.style.transitionDuration = "400ms" }, 1e3)), i("scrollbarDragEnd", M), _.snapOnRelease && e.slideToClosest()) } function x(M) { const { scrollbar: _, params: O } = e, R = _.el; if (!R) return; const j = R, I = O.passiveListeners ? { passive: !1, capture: !1 } : !1, E = O.passiveListeners ? { passive: !0, capture: !1 } : !1; if (!j) return; const k = M === "on" ? "addEventListener" : "removeEventListener"; j[k]("pointerdown", m, I), s[k]("pointermove", h, I), s[k]("pointerup", S, E) } function T() { !e.params.scrollbar.el || !e.scrollbar.el || x("on") } function L() { !e.params.scrollbar.el || !e.scrollbar.el || x("off") } function b() { const { scrollbar: M, el: _ } = e; e.params.scrollbar = Ao(e, e.originalParams.scrollbar, e.params.scrollbar, { el: "swiper-scrollbar" }); const O = e.params.scrollbar; if (!O.el) return; let R; if (typeof O.el == "string" && e.isElement && (R = e.el.querySelector(O.el)), !R && typeof O.el == "string") { if (R = s.querySelectorAll(O.el), !R.length) return } else R || (R = O.el); e.params.uniqueNavElements && typeof O.el == "string" && R.length > 1 && _.querySelectorAll(O.el).length === 1 && (R = _.querySelector(O.el)), R.length > 0 && (R = R[0]), R.classList.add(e.isHorizontal() ? O.horizontalClass : O.verticalClass); let j; R && (j = R.querySelector(mt(e.params.scrollbar.dragClass)), j || (j = He("div", e.params.scrollbar.dragClass), R.append(j))), Object.assign(M, { el: R, dragEl: j }), O.draggable && T(), R && R.classList[e.enabled ? "remove" : "add"](...bt(e.params.scrollbar.lockClass)) } function C() { const M = e.params.scrollbar, _ = e.scrollbar.el; _ && _.classList.remove(...bt(e.isHorizontal() ? M.horizontalClass : M.verticalClass)), L() } r("changeDirection", () => { if (!e.scrollbar || !e.scrollbar.el) return; const M = e.params.scrollbar; let { el: _ } = e.scrollbar; _ = V(_), _.forEach(O => { O.classList.remove(M.horizontalClass, M.verticalClass), O.classList.add(e.isHorizontal() ? M.horizontalClass : M.verticalClass) }) }), r("init", () => { e.params.scrollbar.enabled === !1 ? N() : (b(), w(), v()) }), r("update resize observerUpdate lock unlock changeDirection", () => { w() }), r("setTranslate", () => { v() }), r("setTransition", (M, _) => { g(_) }), r("enable disable", () => { const { el: M } = e.scrollbar; M && M.classList[e.enabled ? "remove" : "add"](...bt(e.params.scrollbar.lockClass)) }), r("destroy", () => { C() }); const P = () => { e.el.classList.remove(...bt(e.params.scrollbar.scrollbarDisabledClass)), e.scrollbar.el && e.scrollbar.el.classList.remove(...bt(e.params.scrollbar.scrollbarDisabledClass)), b(), w(), v() }, N = () => { e.el.classList.add(...bt(e.params.scrollbar.scrollbarDisabledClass)), e.scrollbar.el && e.scrollbar.el.classList.add(...bt(e.params.scrollbar.scrollbarDisabledClass)), C() }; Object.assign(e.scrollbar, { enable: P, disable: N, updateSize: w, setTranslate: v, init: b, destroy: C }) } function T0(t) { let { swiper: e, extendParams: n, on: r } = t; n({ parallax: { enabled: !1 } }); const i = "[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]", s = (a, u) => { const { rtl: c } = e, d = c ? -1 : 1, f = a.getAttribute("data-swiper-parallax") || "0"; let v = a.getAttribute("data-swiper-parallax-x"), g = a.getAttribute("data-swiper-parallax-y"); const w = a.getAttribute("data-swiper-parallax-scale"), y = a.getAttribute("data-swiper-parallax-opacity"), p = a.getAttribute("data-swiper-parallax-rotate"); if (v || g ? (v = v || "0", g = g || "0") : e.isHorizontal() ? (v = f, g = "0") : (g = f, v = "0"), v.indexOf("%") >= 0 ? v = `${parseInt(v, 10) * u * d}%` : v = `${v * u * d}px`, g.indexOf("%") >= 0 ? g = `${parseInt(g, 10) * u}%` : g = `${g * u}px`, typeof y < "u" && y !== null) { const h = y - (y - 1) * (1 - Math.abs(u)); a.style.opacity = h } let m = `translate3d(${v}, ${g}, 0px)`; if (typeof w < "u" && w !== null) { const h = w - (w - 1) * (1 - Math.abs(u)); m += ` scale(${h})` } if (p && typeof p < "u" && p !== null) { const h = p * u * -1; m += ` rotate(${h}deg)` } a.style.transform = m }, l = () => { const { el: a, slides: u, progress: c, snapGrid: d, isElement: f } = e, v = ge(a, i); e.isElement && v.push(...ge(e.hostEl, i)), v.forEach(g => { s(g, c) }), u.forEach((g, w) => { let y = g.progress; e.params.slidesPerGroup > 1 && e.params.slidesPerView !== "auto" && (y += Math.ceil(w / 2) - c * (d.length - 1)), y = Math.min(Math.max(y, -1), 1), g.querySelectorAll(`${i}, [data-swiper-parallax-rotate]`).forEach(p => { s(p, y) }) }) }, o = function (a) { a === void 0 && (a = e.params.speed); const { el: u, hostEl: c } = e, d = [...u.querySelectorAll(i)]; e.isElement && d.push(...c.querySelectorAll(i)), d.forEach(f => { let v = parseInt(f.getAttribute("data-swiper-parallax-duration"), 10) || a; a === 0 && (v = 0), f.style.transitionDuration = `${v}ms` }) }; r("beforeInit", () => { e.params.parallax.enabled && (e.params.watchSlidesProgress = !0, e.originalParams.watchSlidesProgress = !0) }), r("init", () => { e.params.parallax.enabled && l() }), r("setTranslate", () => { e.params.parallax.enabled && l() }), r("setTransition", (a, u) => { e.params.parallax.enabled && o(u) }) } function b0(t) { let { swiper: e, extendParams: n, on: r, emit: i } = t; const s = se(); n({ zoom: { enabled: !1, limitToOriginalSize: !1, maxRatio: 3, minRatio: 1, toggle: !0, containerClass: "swiper-zoom-container", zoomedSlideClass: "swiper-slide-zoomed" } }), e.zoom = { enabled: !1 }; let l = 1, o = !1, a, u; const c = [], d = { originX: 0, originY: 0, slideEl: void 0, slideWidth: void 0, slideHeight: void 0, imageEl: void 0, imageWrapEl: void 0, maxRatio: 3 }, f = { isTouched: void 0, isMoved: void 0, currentX: void 0, currentY: void 0, minX: void 0, minY: void 0, maxX: void 0, maxY: void 0, width: void 0, height: void 0, startX: void 0, startY: void 0, touchesStart: {}, touchesCurrent: {} }, v = { x: void 0, y: void 0, prevPositionX: void 0, prevPositionY: void 0, prevTime: void 0 }; let g = 1; Object.defineProperty(e.zoom, "scale", { get() { return g }, set(E) { if (g !== E) { const k = d.imageEl, z = d.slideEl; i("zoomChange", E, k, z) } g = E } }); function w() { if (c.length < 2) return 1; const E = c[0].pageX, k = c[0].pageY, z = c[1].pageX, F = c[1].pageY; return Math.sqrt((z - E) ** 2 + (F - k) ** 2) } function y() { const E = e.params.zoom, k = d.imageWrapEl.getAttribute("data-swiper-zoom") || E.maxRatio; if (E.limitToOriginalSize && d.imageEl && d.imageEl.naturalWidth) { const z = d.imageEl.naturalWidth / d.imageEl.offsetWidth; return Math.min(z, k) } return k } function p() { if (c.length < 2) return { x: null, y: null }; const E = d.imageEl.getBoundingClientRect(); return [(c[0].pageX + (c[1].pageX - c[0].pageX) / 2 - E.x - s.scrollX) / l, (c[0].pageY + (c[1].pageY - c[0].pageY) / 2 - E.y - s.scrollY) / l] } function m() { return e.isElement ? "swiper-slide" : `.${e.params.slideClass}` } function h(E) { const k = m(); return !!(E.target.matches(k) || e.slides.filter(z => z.contains(E.target)).length > 0) } function S(E) { const k = `.${e.params.zoom.containerClass}`; return !!(E.target.matches(k) || [...e.hostEl.querySelectorAll(k)].filter(z => z.contains(E.target)).length > 0) } function x(E) { if (E.pointerType === "mouse" && c.splice(0, c.length), !h(E)) return; const k = e.params.zoom; if (a = !1, u = !1, c.push(E), !(c.length < 2)) { if (a = !0, d.scaleStart = w(), !d.slideEl) { d.slideEl = E.target.closest(`.${e.params.slideClass}, swiper-slide`), d.slideEl || (d.slideEl = e.slides[e.activeIndex]); let z = d.slideEl.querySelector(`.${k.containerClass}`); if (z && (z = z.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), d.imageEl = z, z ? d.imageWrapEl = rn(d.imageEl, `.${k.containerClass}`)[0] : d.imageWrapEl = void 0, !d.imageWrapEl) { d.imageEl = void 0; return } d.maxRatio = y() } if (d.imageEl) { const [z, F] = p(); d.originX = z, d.originY = F, d.imageEl.style.transitionDuration = "0ms" } o = !0 } } function T(E) { if (!h(E)) return; const k = e.params.zoom, z = e.zoom, F = c.findIndex(B => B.pointerId === E.pointerId); F >= 0 && (c[F] = E), !(c.length < 2) && (u = !0, d.scaleMove = w(), d.imageEl && (z.scale = d.scaleMove / d.scaleStart * l, z.scale > d.maxRatio && (z.scale = d.maxRatio - 1 + (z.scale - d.maxRatio + 1) ** .5), z.scale < k.minRatio && (z.scale = k.minRatio + 1 - (k.minRatio - z.scale + 1) ** .5), d.imageEl.style.transform = `translate3d(0,0,0) scale(${z.scale})`)) } function L(E) { if (!h(E) || E.pointerType === "mouse" && E.type === "pointerout") return; const k = e.params.zoom, z = e.zoom, F = c.findIndex(B => B.pointerId === E.pointerId); F >= 0 && c.splice(F, 1), !(!a || !u) && (a = !1, u = !1, d.imageEl && (z.scale = Math.max(Math.min(z.scale, d.maxRatio), k.minRatio), d.imageEl.style.transitionDuration = `${e.params.speed}ms`, d.imageEl.style.transform = `translate3d(0,0,0) scale(${z.scale})`, l = z.scale, o = !1, z.scale > 1 && d.slideEl ? d.slideEl.classList.add(`${k.zoomedSlideClass}`) : z.scale <= 1 && d.slideEl && d.slideEl.classList.remove(`${k.zoomedSlideClass}`), z.scale === 1 && (d.originX = 0, d.originY = 0, d.slideEl = void 0))) } function b(E) { const k = e.device; if (!d.imageEl || f.isTouched) return; k.android && E.cancelable && E.preventDefault(), f.isTouched = !0; const z = c.length > 0 ? c[0] : E; f.touchesStart.x = z.pageX, f.touchesStart.y = z.pageY } function C(E) { if (!h(E) || !S(E)) return; const k = e.zoom; if (!d.imageEl || !f.isTouched || !d.slideEl) return; f.isMoved || (f.width = d.imageEl.offsetWidth || d.imageEl.clientWidth, f.height = d.imageEl.offsetHeight || d.imageEl.clientHeight, f.startX = va(d.imageWrapEl, "x") || 0, f.startY = va(d.imageWrapEl, "y") || 0, d.slideWidth = d.slideEl.offsetWidth, d.slideHeight = d.slideEl.offsetHeight, d.imageWrapEl.style.transitionDuration = "0ms"); const z = f.width * k.scale, F = f.height * k.scale; if (z < d.slideWidth && F < d.slideHeight) return; if (f.minX = Math.min(d.slideWidth / 2 - z / 2, 0), f.maxX = -f.minX, f.minY = Math.min(d.slideHeight / 2 - F / 2, 0), f.maxY = -f.minY, f.touchesCurrent.x = c.length > 0 ? c[0].pageX : E.pageX, f.touchesCurrent.y = c.length > 0 ? c[0].pageY : E.pageY, Math.max(Math.abs(f.touchesCurrent.x - f.touchesStart.x), Math.abs(f.touchesCurrent.y - f.touchesStart.y)) > 5 && (e.allowClick = !1), !f.isMoved && !o) { if (e.isHorizontal() && (Math.floor(f.minX) === Math.floor(f.startX) && f.touchesCurrent.x < f.touchesStart.x || Math.floor(f.maxX) === Math.floor(f.startX) && f.touchesCurrent.x > f.touchesStart.x)) { f.isTouched = !1; return } if (!e.isHorizontal() && (Math.floor(f.minY) === Math.floor(f.startY) && f.touchesCurrent.y < f.touchesStart.y || Math.floor(f.maxY) === Math.floor(f.startY) && f.touchesCurrent.y > f.touchesStart.y)) { f.isTouched = !1; return } } E.cancelable && E.preventDefault(), E.stopPropagation(), f.isMoved = !0; const ue = (k.scale - l) / (d.maxRatio - e.params.zoom.minRatio), { originX: fe, originY: H } = d; f.currentX = f.touchesCurrent.x - f.touchesStart.x + f.startX + ue * (f.width - fe * 2), f.currentY = f.touchesCurrent.y - f.touchesStart.y + f.startY + ue * (f.height - H * 2), f.currentX < f.minX && (f.currentX = f.minX + 1 - (f.minX - f.currentX + 1) ** .8), f.currentX > f.maxX && (f.currentX = f.maxX - 1 + (f.currentX - f.maxX + 1) ** .8), f.currentY < f.minY && (f.currentY = f.minY + 1 - (f.minY - f.currentY + 1) ** .8), f.currentY > f.maxY && (f.currentY = f.maxY - 1 + (f.currentY - f.maxY + 1) ** .8), v.prevPositionX || (v.prevPositionX = f.touchesCurrent.x), v.prevPositionY || (v.prevPositionY = f.touchesCurrent.y), v.prevTime || (v.prevTime = Date.now()), v.x = (f.touchesCurrent.x - v.prevPositionX) / (Date.now() - v.prevTime) / 2, v.y = (f.touchesCurrent.y - v.prevPositionY) / (Date.now() - v.prevTime) / 2, Math.abs(f.touchesCurrent.x - v.prevPositionX) < 2 && (v.x = 0), Math.abs(f.touchesCurrent.y - v.prevPositionY) < 2 && (v.y = 0), v.prevPositionX = f.touchesCurrent.x, v.prevPositionY = f.touchesCurrent.y, v.prevTime = Date.now(), d.imageWrapEl.style.transform = `translate3d(${f.currentX}px, ${f.currentY}px,0)` } function P() { const E = e.zoom; if (!d.imageEl) return; if (!f.isTouched || !f.isMoved) { f.isTouched = !1, f.isMoved = !1; return } f.isTouched = !1, f.isMoved = !1; let k = 300, z = 300; const F = v.x * k, B = f.currentX + F, ue = v.y * z, fe = f.currentY + ue; v.x !== 0 && (k = Math.abs((B - f.currentX) / v.x)), v.y !== 0 && (z = Math.abs((fe - f.currentY) / v.y)); const H = Math.max(k, z); f.currentX = B, f.currentY = fe; const X = f.width * E.scale, re = f.height * E.scale; f.minX = Math.min(d.slideWidth / 2 - X / 2, 0), f.maxX = -f.minX, f.minY = Math.min(d.slideHeight / 2 - re / 2, 0), f.maxY = -f.minY, f.currentX = Math.max(Math.min(f.currentX, f.maxX), f.minX), f.currentY = Math.max(Math.min(f.currentY, f.maxY), f.minY), d.imageWrapEl.style.transitionDuration = `${H}ms`, d.imageWrapEl.style.transform = `translate3d(${f.currentX}px, ${f.currentY}px,0)` } function N() { const E = e.zoom; d.slideEl && e.activeIndex !== e.slides.indexOf(d.slideEl) && (d.imageEl && (d.imageEl.style.transform = "translate3d(0,0,0) scale(1)"), d.imageWrapEl && (d.imageWrapEl.style.transform = "translate3d(0,0,0)"), d.slideEl.classList.remove(`${e.params.zoom.zoomedSlideClass}`), E.scale = 1, l = 1, d.slideEl = void 0, d.imageEl = void 0, d.imageWrapEl = void 0, d.originX = 0, d.originY = 0) } function M(E) { const k = e.zoom, z = e.params.zoom; if (!d.slideEl) { E && E.target && (d.slideEl = E.target.closest(`.${e.params.slideClass}, swiper-slide`)), d.slideEl || (e.params.virtual && e.params.virtual.enabled && e.virtual ? d.slideEl = ge(e.slidesEl, `.${e.params.slideActiveClass}`)[0] : d.slideEl = e.slides[e.activeIndex]); let Qn = d.slideEl.querySelector(`.${z.containerClass}`); Qn && (Qn = Qn.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), d.imageEl = Qn, Qn ? d.imageWrapEl = rn(d.imageEl, `.${z.containerClass}`)[0] : d.imageWrapEl = void 0 } if (!d.imageEl || !d.imageWrapEl) return; e.params.cssMode && (e.wrapperEl.style.overflow = "hidden", e.wrapperEl.style.touchAction = "none"), d.slideEl.classList.add(`${z.zoomedSlideClass}`); let F, B, ue, fe, H, X, re, Ut, Ro, $o, jo, Fo, qr, Qr, Ns, As, Ds, Rs; typeof f.touchesStart.x > "u" && E ? (F = E.pageX, B = E.pageY) : (F = f.touchesStart.x, B = f.touchesStart.y); const qn = typeof E == "number" ? E : null; l === 1 && qn && (F = void 0, B = void 0); const Ho = y(); k.scale = qn || Ho, l = qn || Ho, E && !(l === 1 && qn) ? (Ds = d.slideEl.offsetWidth, Rs = d.slideEl.offsetHeight, ue = ss(d.slideEl).left + s.scrollX, fe = ss(d.slideEl).top + s.scrollY, H = ue + Ds / 2 - F, X = fe + Rs / 2 - B, Ro = d.imageEl.offsetWidth || d.imageEl.clientWidth, $o = d.imageEl.offsetHeight || d.imageEl.clientHeight, jo = Ro * k.scale, Fo = $o * k.scale, qr = Math.min(Ds / 2 - jo / 2, 0), Qr = Math.min(Rs / 2 - Fo / 2, 0), Ns = -qr, As = -Qr, re = H * k.scale, Ut = X * k.scale, re < qr && (re = qr), re > Ns && (re = Ns), Ut < Qr && (Ut = Qr), Ut > As && (Ut = As)) : (re = 0, Ut = 0), qn && k.scale === 1 && (d.originX = 0, d.originY = 0), d.imageWrapEl.style.transitionDuration = "300ms", d.imageWrapEl.style.transform = `translate3d(${re}px, ${Ut}px,0)`, d.imageEl.style.transitionDuration = "300ms", d.imageEl.style.transform = `translate3d(0,0,0) scale(${k.scale})` } function _() { const E = e.zoom, k = e.params.zoom; if (!d.slideEl) { e.params.virtual && e.params.virtual.enabled && e.virtual ? d.slideEl = ge(e.slidesEl, `.${e.params.slideActiveClass}`)[0] : d.slideEl = e.slides[e.activeIndex]; let z = d.slideEl.querySelector(`.${k.containerClass}`); z && (z = z.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), d.imageEl = z, z ? d.imageWrapEl = rn(d.imageEl, `.${k.containerClass}`)[0] : d.imageWrapEl = void 0 } !d.imageEl || !d.imageWrapEl || (e.params.cssMode && (e.wrapperEl.style.overflow = "", e.wrapperEl.style.touchAction = ""), E.scale = 1, l = 1, d.imageWrapEl.style.transitionDuration = "300ms", d.imageWrapEl.style.transform = "translate3d(0,0,0)", d.imageEl.style.transitionDuration = "300ms", d.imageEl.style.transform = "translate3d(0,0,0) scale(1)", d.slideEl.classList.remove(`${k.zoomedSlideClass}`), d.slideEl = void 0, d.originX = 0, d.originY = 0) } function O(E) { const k = e.zoom; k.scale && k.scale !== 1 ? _() : M(E) } function R() { const E = e.params.passiveListeners ? { passive: !0, capture: !1 } : !1, k = e.params.passiveListeners ? { passive: !1, capture: !0 } : !0; return { passiveListener: E, activeListenerWithCapture: k } } function j() { const E = e.zoom; if (E.enabled) return; E.enabled = !0; const { passiveListener: k, activeListenerWithCapture: z } = R(); e.wrapperEl.addEventListener("pointerdown", x, k), e.wrapperEl.addEventListener("pointermove", T, z), ["pointerup", "pointercancel", "pointerout"].forEach(F => { e.wrapperEl.addEventListener(F, L, k) }), e.wrapperEl.addEventListener("pointermove", C, z) } function I() { const E = e.zoom; if (!E.enabled) return; E.enabled = !1; const { passiveListener: k, activeListenerWithCapture: z } = R(); e.wrapperEl.removeEventListener("pointerdown", x, k), e.wrapperEl.removeEventListener("pointermove", T, z), ["pointerup", "pointercancel", "pointerout"].forEach(F => { e.wrapperEl.removeEventListener(F, L, k) }), e.wrapperEl.removeEventListener("pointermove", C, z) } r("init", () => { e.params.zoom.enabled && j() }), r("destroy", () => { I() }), r("touchStart", (E, k) => { e.zoom.enabled && b(k) }), r("touchEnd", (E, k) => { e.zoom.enabled && P() }), r("doubleTap", (E, k) => { !e.animating && e.params.zoom.enabled && e.zoom.enabled && e.params.zoom.toggle && O(k) }), r("transitionEnd", () => { e.zoom.enabled && e.params.zoom.enabled && N() }), r("slideChange", () => { e.zoom.enabled && e.params.zoom.enabled && e.params.cssMode && N() }), Object.assign(e.zoom, { enable: j, disable: I, in: M, out: _, toggle: O }) } function C0(t) { let { swiper: e, extendParams: n, on: r } = t; n({ controller: { control: void 0, inverse: !1, by: "slide" } }), e.controller = { control: void 0 }; function i(u, c) { const d = function () { let w, y, p; return (m, h) => { for (y = -1, w = m.length; w - y > 1;)p = w + y >> 1, m[p] <= h ? y = p : w = p; return w } }(); this.x = u, this.y = c, this.lastIndex = u.length - 1; let f, v; return this.interpolate = function (w) { return w ? (v = d(this.x, w), f = v - 1, (w - this.x[f]) * (this.y[v] - this.y[f]) / (this.x[v] - this.x[f]) + this.y[f]) : 0 }, this } function s(u) { e.controller.spline = e.params.loop ? new i(e.slidesGrid, u.slidesGrid) : new i(e.snapGrid, u.snapGrid) } function l(u, c) { const d = e.controller.control; let f, v; const g = e.constructor; function w(y) { if (y.destroyed) return; const p = e.rtlTranslate ? -e.translate : e.translate; e.params.controller.by === "slide" && (s(y), v = -e.controller.spline.interpolate(-p)), (!v || e.params.controller.by === "container") && (f = (y.maxTranslate() - y.minTranslate()) / (e.maxTranslate() - e.minTranslate()), (Number.isNaN(f) || !Number.isFinite(f)) && (f = 1), v = (p - e.minTranslate()) * f + y.minTranslate()), e.params.controller.inverse && (v = y.maxTranslate() - v), y.updateProgress(v), y.setTranslate(v, e), y.updateActiveIndex(), y.updateSlidesClasses() } if (Array.isArray(d)) for (let y = 0; y < d.length; y += 1)d[y] !== c && d[y] instanceof g && w(d[y]); else d instanceof g && c !== d && w(d) } function o(u, c) { const d = e.constructor, f = e.controller.control; let v; function g(w) { w.destroyed || (w.setTransition(u, e), u !== 0 && (w.transitionStart(), w.params.autoHeight && cn(() => { w.updateAutoHeight() }), Tr(w.wrapperEl, () => { f && w.transitionEnd() }))) } if (Array.isArray(f)) for (v = 0; v < f.length; v += 1)f[v] !== c && f[v] instanceof d && g(f[v]); else f instanceof d && c !== f && g(f) } function a() { e.controller.control && e.controller.spline && (e.controller.spline = void 0, delete e.controller.spline) } r("beforeInit", () => { if (typeof window < "u" && (typeof e.params.controller.control == "string" || e.params.controller.control instanceof HTMLElement)) { const u = document.querySelector(e.params.controller.control); if (u && u.swiper) e.controller.control = u.swiper; else if (u) { const c = d => { e.controller.control = d.detail[0], e.update(), u.removeEventListener("init", c) }; u.addEventListener("init", c) } return } e.controller.control = e.params.controller.control }), r("update", () => { a() }), r("resize", () => { a() }), r("observerUpdate", () => { a() }), r("setTranslate", (u, c, d) => { !e.controller.control || e.controller.control.destroyed || e.controller.setTranslate(c, d) }), r("setTransition", (u, c, d) => { !e.controller.control || e.controller.control.destroyed || e.controller.setTransition(c, d) }), Object.assign(e.controller, { setTranslate: l, setTransition: o }) } function P0(t) { let { swiper: e, extendParams: n, on: r } = t; n({ a11y: { enabled: !0, notificationClass: "swiper-notification", prevSlideMessage: "Previous slide", nextSlideMessage: "Next slide", firstSlideMessage: "This is the first slide", lastSlideMessage: "This is the last slide", paginationBulletMessage: "Go to slide {{index}}", slideLabelMessage: "{{index}} / {{slidesLength}}", containerMessage: null, containerRoleDescriptionMessage: null, itemRoleDescriptionMessage: null, slideRole: "group", id: null } }), e.a11y = { clicked: !1 }; let i = null, s, l, o = new Date().getTime(); function a(I) { const E = i; E.length !== 0 && (E.innerHTML = "", E.innerHTML = I) } function u(I) { I === void 0 && (I = 16); const E = () => Math.round(16 * Math.random()).toString(16); return "x".repeat(I).replace(/x/g, E) } function c(I) { I = V(I), I.forEach(E => { E.setAttribute("tabIndex", "0") }) } function d(I) { I = V(I), I.forEach(E => { E.setAttribute("tabIndex", "-1") }) } function f(I, E) { I = V(I), I.forEach(k => { k.setAttribute("role", E) }) } function v(I, E) { I = V(I), I.forEach(k => { k.setAttribute("aria-roledescription", E) }) } function g(I, E) { I = V(I), I.forEach(k => { k.setAttribute("aria-controls", E) }) } function w(I, E) { I = V(I), I.forEach(k => { k.setAttribute("aria-label", E) }) } function y(I, E) { I = V(I), I.forEach(k => { k.setAttribute("id", E) }) } function p(I, E) { I = V(I), I.forEach(k => { k.setAttribute("aria-live", E) }) } function m(I) { I = V(I), I.forEach(E => { E.setAttribute("aria-disabled", !0) }) } function h(I) { I = V(I), I.forEach(E => { E.setAttribute("aria-disabled", !1) }) } function S(I) { if (I.keyCode !== 13 && I.keyCode !== 32) return; const E = e.params.a11y, k = I.target; if (!(e.pagination && e.pagination.el && (k === e.pagination.el || e.pagination.el.contains(I.target)) && !I.target.matches(mt(e.params.pagination.bulletClass)))) { if (e.navigation && e.navigation.prevEl && e.navigation.nextEl) { const z = V(e.navigation.prevEl); V(e.navigation.nextEl).includes(k) && (e.isEnd && !e.params.loop || e.slideNext(), e.isEnd ? a(E.lastSlideMessage) : a(E.nextSlideMessage)), z.includes(k) && (e.isBeginning && !e.params.loop || e.slidePrev(), e.isBeginning ? a(E.firstSlideMessage) : a(E.prevSlideMessage)) } e.pagination && k.matches(mt(e.params.pagination.bulletClass)) && k.click() } } function x() { if (e.params.loop || e.params.rewind || !e.navigation) return; const { nextEl: I, prevEl: E } = e.navigation; E && (e.isBeginning ? (m(E), d(E)) : (h(E), c(E))), I && (e.isEnd ? (m(I), d(I)) : (h(I), c(I))) } function T() { return e.pagination && e.pagination.bullets && e.pagination.bullets.length } function L() { return T() && e.params.pagination.clickable } function b() { const I = e.params.a11y; T() && e.pagination.bullets.forEach(E => { e.params.pagination.clickable && (c(E), e.params.pagination.renderBullet || (f(E, "button"), w(E, I.paginationBulletMessage.replace(/\{\{index\}\}/, Hr(E) + 1)))), E.matches(mt(e.params.pagination.bulletActiveClass)) ? E.setAttribute("aria-current", "true") : E.removeAttribute("aria-current") }) } const C = (I, E, k) => { c(I), I.tagName !== "BUTTON" && (f(I, "button"), I.addEventListener("keydown", S)), w(I, k), g(I, E) }, P = I => { l && l !== I.target && !l.contains(I.target) && (s = !0), e.a11y.clicked = !0 }, N = () => { s = !1, requestAnimationFrame(() => { requestAnimationFrame(() => { e.destroyed || (e.a11y.clicked = !1) }) }) }, M = I => { o = new Date().getTime() }, _ = I => { if (e.a11y.clicked || new Date().getTime() - o < 100) return; const E = I.target.closest(`.${e.params.slideClass}, swiper-slide`); if (!E || !e.slides.includes(E)) return; l = E; const k = e.slides.indexOf(E) === e.activeIndex, z = e.params.watchSlidesProgress && e.visibleSlides && e.visibleSlides.includes(E); k || z || I.sourceCapabilities && I.sourceCapabilities.firesTouchEvents || (e.isHorizontal() ? e.el.scrollLeft = 0 : e.el.scrollTop = 0, requestAnimationFrame(() => { s || (e.slideTo(e.slides.indexOf(E), 0), s = !1) })) }, O = () => { const I = e.params.a11y; I.itemRoleDescriptionMessage && v(e.slides, I.itemRoleDescriptionMessage), I.slideRole && f(e.slides, I.slideRole); const E = e.slides.length; I.slideLabelMessage && e.slides.forEach((k, z) => { const F = e.params.loop ? parseInt(k.getAttribute("data-swiper-slide-index"), 10) : z, B = I.slideLabelMessage.replace(/\{\{index\}\}/, F + 1).replace(/\{\{slidesLength\}\}/, E); w(k, B) }) }, R = () => { const I = e.params.a11y; e.el.append(i); const E = e.el; I.containerRoleDescriptionMessage && v(E, I.containerRoleDescriptionMessage), I.containerMessage && w(E, I.containerMessage); const k = e.wrapperEl, z = I.id || k.getAttribute("id") || `swiper-wrapper-${u(16)}`, F = e.params.autoplay && e.params.autoplay.enabled ? "off" : "polite"; y(k, z), p(k, F), O(); let { nextEl: B, prevEl: ue } = e.navigation ? e.navigation : {}; B = V(B), ue = V(ue), B && B.forEach(H => C(H, z, I.nextSlideMessage)), ue && ue.forEach(H => C(H, z, I.prevSlideMessage)), L() && V(e.pagination.el).forEach(X => { X.addEventListener("keydown", S) }), we().addEventListener("visibilitychange", M), e.el.addEventListener("focus", _, !0), e.el.addEventListener("focus", _, !0), e.el.addEventListener("pointerdown", P, !0), e.el.addEventListener("pointerup", N, !0) }; function j() { i && i.remove(); let { nextEl: I, prevEl: E } = e.navigation ? e.navigation : {}; I = V(I), E = V(E), I && I.forEach(z => z.removeEventListener("keydown", S)), E && E.forEach(z => z.removeEventListener("keydown", S)), L() && V(e.pagination.el).forEach(F => { F.removeEventListener("keydown", S) }), we().removeEventListener("visibilitychange", M), e.el.removeEventListener("focus", _, !0), e.el.removeEventListener("pointerdown", P, !0), e.el.removeEventListener("pointerup", N, !0) } r("beforeInit", () => { i = He("span", e.params.a11y.notificationClass), i.setAttribute("aria-live", "assertive"), i.setAttribute("aria-atomic", "true") }), r("afterInit", () => { e.params.a11y.enabled && R() }), r("slidesLengthChange snapGridLengthChange slidesGridLengthChange", () => { e.params.a11y.enabled && O() }), r("fromEdge toEdge afterInit lock unlock", () => { e.params.a11y.enabled && x() }), r("paginationUpdate", () => { e.params.a11y.enabled && b() }), r("destroy", () => { e.params.a11y.enabled && j() }) } function k0(t) { let { swiper: e, extendParams: n, on: r } = t; n({ history: { enabled: !1, root: "", replaceState: !1, key: "slides", keepQuery: !1 } }); let i = !1, s = {}; const l = v => v.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, ""), o = v => { const g = se(); let w; v ? w = new URL(v) : w = g.location; const y = w.pathname.slice(1).split("/").filter(S => S !== ""), p = y.length, m = y[p - 2], h = y[p - 1]; return { key: m, value: h } }, a = (v, g) => { const w = se(); if (!i || !e.params.history.enabled) return; let y; e.params.url ? y = new URL(e.params.url) : y = w.location; const p = e.virtual && e.params.virtual.enabled ? e.slidesEl.querySelector(`[data-swiper-slide-index="${g}"]`) : e.slides[g]; let m = l(p.getAttribute("data-history")); if (e.params.history.root.length > 0) { let S = e.params.history.root; S[S.length - 1] === "/" && (S = S.slice(0, S.length - 1)), m = `${S}/${v ? `${v}/` : ""}${m}` } else y.pathname.includes(v) || (m = `${v ? `${v}/` : ""}${m}`); e.params.history.keepQuery && (m += y.search); const h = w.history.state; h && h.value === m || (e.params.history.replaceState ? w.history.replaceState({ value: m }, null, m) : w.history.pushState({ value: m }, null, m)) }, u = (v, g, w) => { if (g) for (let y = 0, p = e.slides.length; y < p; y += 1) { const m = e.slides[y]; if (l(m.getAttribute("data-history")) === g) { const S = e.getSlideIndex(m); e.slideTo(S, v, w) } } else e.slideTo(0, v, w) }, c = () => { s = o(e.params.url), u(e.params.speed, s.value, !1) }, d = () => { const v = se(); if (e.params.history) { if (!v.history || !v.history.pushState) { e.params.history.enabled = !1, e.params.hashNavigation.enabled = !0; return } if (i = !0, s = o(e.params.url), !s.key && !s.value) { e.params.history.replaceState || v.addEventListener("popstate", c); return } u(0, s.value, e.params.runCallbacksOnInit), e.params.history.replaceState || v.addEventListener("popstate", c) } }, f = () => { const v = se(); e.params.history.replaceState || v.removeEventListener("popstate", c) }; r("init", () => { e.params.history.enabled && d() }), r("destroy", () => { e.params.history.enabled && f() }), r("transitionEnd _freeModeNoMomentumRelease", () => { i && a(e.params.history.key, e.activeIndex) }), r("slideChange", () => { i && e.params.cssMode && a(e.params.history.key, e.activeIndex) }) } function M0(t) { let { swiper: e, extendParams: n, emit: r, on: i } = t, s = !1; const l = we(), o = se(); n({ hashNavigation: { enabled: !1, replaceState: !1, watchState: !1, getSlideIndex(f, v) { if (e.virtual && e.params.virtual.enabled) { const g = e.slides.filter(y => y.getAttribute("data-hash") === v)[0]; return g ? parseInt(g.getAttribute("data-swiper-slide-index"), 10) : 0 } return e.getSlideIndex(ge(e.slidesEl, `.${e.params.slideClass}[data-hash="${v}"], swiper-slide[data-hash="${v}"]`)[0]) } } }); const a = () => { r("hashChange"); const f = l.location.hash.replace("#", ""), v = e.virtual && e.params.virtual.enabled ? e.slidesEl.querySelector(`[data-swiper-slide-index="${e.activeIndex}"]`) : e.slides[e.activeIndex], g = v ? v.getAttribute("data-hash") : ""; if (f !== g) { const w = e.params.hashNavigation.getSlideIndex(e, f); if (typeof w > "u" || Number.isNaN(w)) return; e.slideTo(w) } }, u = () => { if (!s || !e.params.hashNavigation.enabled) return; const f = e.virtual && e.params.virtual.enabled ? e.slidesEl.querySelector(`[data-swiper-slide-index="${e.activeIndex}"]`) : e.slides[e.activeIndex], v = f ? f.getAttribute("data-hash") || f.getAttribute("data-history") : ""; e.params.hashNavigation.replaceState && o.history && o.history.replaceState ? (o.history.replaceState(null, null, `#${v}` || ""), r("hashSet")) : (l.location.hash = v || "", r("hashSet")) }, c = () => { if (!e.params.hashNavigation.enabled || e.params.history && e.params.history.enabled) return; s = !0; const f = l.location.hash.replace("#", ""); if (f) { const g = e.params.hashNavigation.getSlideIndex(e, f); e.slideTo(g || 0, 0, e.params.runCallbacksOnInit, !0) } e.params.hashNavigation.watchState && o.addEventListener("hashchange", a) }, d = () => { e.params.hashNavigation.watchState && o.removeEventListener("hashchange", a) }; i("init", () => { e.params.hashNavigation.enabled && c() }), i("destroy", () => { e.params.hashNavigation.enabled && d() }), i("transitionEnd _freeModeNoMomentumRelease", () => { s && u() }), i("slideChange", () => { s && e.params.cssMode && u() }) } function _0(t) { let { swiper: e, extendParams: n, on: r, emit: i, params: s } = t; e.autoplay = { running: !1, paused: !1, timeLeft: 0 }, n({ autoplay: { enabled: !1, delay: 3e3, waitForTransition: !0, disableOnInteraction: !1, stopOnLastSlide: !1, reverseDirection: !1, pauseOnMouseEnter: !1 } }); let l, o, a = s && s.autoplay ? s.autoplay.delay : 3e3, u = s && s.autoplay ? s.autoplay.delay : 3e3, c, d = new Date().getTime(), f, v, g, w, y, p, m; function h(E) { !e || e.destroyed || !e.wrapperEl || E.target === e.wrapperEl && (e.wrapperEl.removeEventListener("transitionend", h), !m && P()) } const S = () => { if (e.destroyed || !e.autoplay.running) return; e.autoplay.paused ? f = !0 : f && (u = c, f = !1); const E = e.autoplay.paused ? c : d + u - new Date().getTime(); e.autoplay.timeLeft = E, i("autoplayTimeLeft", E, E / a), o = requestAnimationFrame(() => { S() }) }, x = () => { let E; return e.virtual && e.params.virtual.enabled ? E = e.slides.filter(z => z.classList.contains("swiper-slide-active"))[0] : E = e.slides[e.activeIndex], E ? parseInt(E.getAttribute("data-swiper-autoplay"), 10) : void 0 }, T = E => { if (e.destroyed || !e.autoplay.running) return; cancelAnimationFrame(o), S(); let k = typeof E > "u" ? e.params.autoplay.delay : E; a = e.params.autoplay.delay, u = e.params.autoplay.delay; const z = x(); !Number.isNaN(z) && z > 0 && typeof E > "u" && (k = z, a = z, u = z), c = k; const F = e.params.speed, B = () => { !e || e.destroyed || (e.params.autoplay.reverseDirection ? !e.isBeginning || e.params.loop || e.params.rewind ? (e.slidePrev(F, !0, !0), i("autoplay")) : e.params.autoplay.stopOnLastSlide || (e.slideTo(e.slides.length - 1, F, !0, !0), i("autoplay")) : !e.isEnd || e.params.loop || e.params.rewind ? (e.slideNext(F, !0, !0), i("autoplay")) : e.params.autoplay.stopOnLastSlide || (e.slideTo(0, F, !0, !0), i("autoplay")), e.params.cssMode && (d = new Date().getTime(), requestAnimationFrame(() => { T() }))) }; return k > 0 ? (clearTimeout(l), l = setTimeout(() => { B() }, k)) : requestAnimationFrame(() => { B() }), k }, L = () => { d = new Date().getTime(), e.autoplay.running = !0, T(), i("autoplayStart") }, b = () => { e.autoplay.running = !1, clearTimeout(l), cancelAnimationFrame(o), i("autoplayStop") }, C = (E, k) => { if (e.destroyed || !e.autoplay.running) return; clearTimeout(l), E || (p = !0); const z = () => { i("autoplayPause"), e.params.autoplay.waitForTransition ? e.wrapperEl.addEventListener("transitionend", h) : P() }; if (e.autoplay.paused = !0, k) { y && (c = e.params.autoplay.delay), y = !1, z(); return } c = (c || e.params.autoplay.delay) - (new Date().getTime() - d), !(e.isEnd && c < 0 && !e.params.loop) && (c < 0 && (c = 0), z()) }, P = () => { e.isEnd && c < 0 && !e.params.loop || e.destroyed || !e.autoplay.running || (d = new Date().getTime(), p ? (p = !1, T(c)) : T(), e.autoplay.paused = !1, i("autoplayResume")) }, N = () => { if (e.destroyed || !e.autoplay.running) return; const E = we(); E.visibilityState === "hidden" && (p = !0, C(!0)), E.visibilityState === "visible" && P() }, M = E => { E.pointerType === "mouse" && (p = !0, m = !0, !(e.animating || e.autoplay.paused) && C(!0)) }, _ = E => { E.pointerType === "mouse" && (m = !1, e.autoplay.paused && P()) }, O = () => { e.params.autoplay.pauseOnMouseEnter && (e.el.addEventListener("pointerenter", M), e.el.addEventListener("pointerleave", _)) }, R = () => { e.el.removeEventListener("pointerenter", M), e.el.removeEventListener("pointerleave", _) }, j = () => { we().addEventListener("visibilitychange", N) }, I = () => { we().removeEventListener("visibilitychange", N) }; r("init", () => { e.params.autoplay.enabled && (O(), j(), L()) }), r("destroy", () => { R(), I(), e.autoplay.running && b() }), r("_freeModeStaticRelease", () => { (g || p) && P() }), r("_freeModeNoMomentumRelease", () => { e.params.autoplay.disableOnInteraction ? b() : C(!0, !0) }), r("beforeTransitionStart", (E, k, z) => { e.destroyed || !e.autoplay.running || (z || !e.params.autoplay.disableOnInteraction ? C(!0, !0) : b()) }), r("sliderFirstMove", () => { if (!(e.destroyed || !e.autoplay.running)) { if (e.params.autoplay.disableOnInteraction) { b(); return } v = !0, g = !1, p = !1, w = setTimeout(() => { p = !0, g = !0, C(!0) }, 200) } }), r("touchEnd", () => { if (!(e.destroyed || !e.autoplay.running || !v)) { if (clearTimeout(w), clearTimeout(l), e.params.autoplay.disableOnInteraction) { g = !1, v = !1; return } g && e.params.cssMode && P(), g = !1, v = !1 } }), r("slideChange", () => { e.destroyed || !e.autoplay.running || (y = !0) }), Object.assign(e.autoplay, { start: L, stop: b, pause: C, resume: P }) } function L0(t) { let { swiper: e, extendParams: n, on: r } = t; n({ thumbs: { swiper: null, multipleActiveThumbs: !0, autoScrollOffset: 0, slideThumbActiveClass: "swiper-slide-thumb-active", thumbsContainerClass: "swiper-thumbs" } }); let i = !1, s = !1; e.thumbs = { swiper: null }; function l() { const u = e.thumbs.swiper; if (!u || u.destroyed) return; const c = u.clickedIndex, d = u.clickedSlide; if (d && d.classList.contains(e.params.thumbs.slideThumbActiveClass) || typeof c > "u" || c === null) return; let f; u.params.loop ? f = parseInt(u.clickedSlide.getAttribute("data-swiper-slide-index"), 10) : f = c, e.params.loop ? e.slideToLoop(f) : e.slideTo(f) } function o() { const { thumbs: u } = e.params; if (i) return !1; i = !0; const c = e.constructor; if (u.swiper instanceof c) e.thumbs.swiper = u.swiper, Object.assign(e.thumbs.swiper.originalParams, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), Object.assign(e.thumbs.swiper.params, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), e.thumbs.swiper.update(); else if (cr(u.swiper)) { const d = Object.assign({}, u.swiper); Object.assign(d, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), e.thumbs.swiper = new c(d), s = !0 } return e.thumbs.swiper.el.classList.add(e.params.thumbs.thumbsContainerClass), e.thumbs.swiper.on("tap", l), !0 } function a(u) { const c = e.thumbs.swiper; if (!c || c.destroyed) return; const d = c.params.slidesPerView === "auto" ? c.slidesPerViewDynamic() : c.params.slidesPerView; let f = 1; const v = e.params.thumbs.slideThumbActiveClass; if (e.params.slidesPerView > 1 && !e.params.centeredSlides && (f = e.params.slidesPerView), e.params.thumbs.multipleActiveThumbs || (f = 1), f = Math.floor(f), c.slides.forEach(y => y.classList.remove(v)), c.params.loop || c.params.virtual && c.params.virtual.enabled) for (let y = 0; y < f; y += 1)ge(c.slidesEl, `[data-swiper-slide-index="${e.realIndex + y}"]`).forEach(p => { p.classList.add(v) }); else for (let y = 0; y < f; y += 1)c.slides[e.realIndex + y] && c.slides[e.realIndex + y].classList.add(v); const g = e.params.thumbs.autoScrollOffset, w = g && !c.params.loop; if (e.realIndex !== c.realIndex || w) { const y = c.activeIndex; let p, m; if (c.params.loop) { const h = c.slides.filter(S => S.getAttribute("data-swiper-slide-index") === `${e.realIndex}`)[0]; p = c.slides.indexOf(h), m = e.activeIndex > e.previousIndex ? "next" : "prev" } else p = e.realIndex, m = p > e.previousIndex ? "next" : "prev"; w && (p += m === "next" ? g : -1 * g), c.visibleSlidesIndexes && c.visibleSlidesIndexes.indexOf(p) < 0 && (c.params.centeredSlides ? p > y ? p = p - Math.floor(d / 2) + 1 : p = p + Math.floor(d / 2) - 1 : p > y && c.params.slidesPerGroup, c.slideTo(p, u ? 0 : void 0)) } } r("beforeInit", () => { const { thumbs: u } = e.params; if (!(!u || !u.swiper)) if (typeof u.swiper == "string" || u.swiper instanceof HTMLElement) { const c = we(), d = () => { const v = typeof u.swiper == "string" ? c.querySelector(u.swiper) : u.swiper; if (v && v.swiper) u.swiper = v.swiper, o(), a(!0); else if (v) { const g = w => { u.swiper = w.detail[0], v.removeEventListener("init", g), o(), a(!0), u.swiper.update(), e.update() }; v.addEventListener("init", g) } return v }, f = () => { if (e.destroyed) return; d() || requestAnimationFrame(f) }; requestAnimationFrame(f) } else o(), a(!0) }), r("slideChange update resize observerUpdate", () => { a() }), r("setTransition", (u, c) => { const d = e.thumbs.swiper; !d || d.destroyed || d.setTransition(c) }), r("beforeDestroy", () => { const u = e.thumbs.swiper; !u || u.destroyed || s && u.destroy() }), Object.assign(e.thumbs, { init: o, update: a }) } function z0(t) { let { swiper: e, extendParams: n, emit: r, once: i } = t; n({ freeMode: { enabled: !1, momentum: !0, momentumRatio: 1, momentumBounce: !0, momentumBounceRatio: 1, momentumVelocityRatio: 1, sticky: !1, minimumVelocity: .02 } }); function s() { if (e.params.cssMode) return; const a = e.getTranslate(); e.setTranslate(a), e.setTransition(0), e.touchEventsData.velocities.length = 0, e.freeMode.onTouchEnd({ currentPos: e.rtl ? e.translate : -e.translate }) } function l() { if (e.params.cssMode) return; const { touchEventsData: a, touches: u } = e; a.velocities.length === 0 && a.velocities.push({ position: u[e.isHorizontal() ? "startX" : "startY"], time: a.touchStartTime }), a.velocities.push({ position: u[e.isHorizontal() ? "currentX" : "currentY"], time: Ye() }) } function o(a) { let { currentPos: u } = a; if (e.params.cssMode) return; const { params: c, wrapperEl: d, rtlTranslate: f, snapGrid: v, touchEventsData: g } = e, y = Ye() - g.touchStartTime; if (u < -e.minTranslate()) { e.slideTo(e.activeIndex); return } if (u > -e.maxTranslate()) { e.slides.length < v.length ? e.slideTo(v.length - 1) : e.slideTo(e.slides.length - 1); return } if (c.freeMode.momentum) { if (g.velocities.length > 1) { const b = g.velocities.pop(), C = g.velocities.pop(), P = b.position - C.position, N = b.time - C.time; e.velocity = P / N, e.velocity /= 2, Math.abs(e.velocity) < c.freeMode.minimumVelocity && (e.velocity = 0), (N > 150 || Ye() - b.time > 300) && (e.velocity = 0) } else e.velocity = 0; e.velocity *= c.freeMode.momentumVelocityRatio, g.velocities.length = 0; let p = 1e3 * c.freeMode.momentumRatio; const m = e.velocity * p; let h = e.translate + m; f && (h = -h); let S = !1, x; const T = Math.abs(e.velocity) * 20 * c.freeMode.momentumBounceRatio; let L; if (h < e.maxTranslate()) c.freeMode.momentumBounce ? (h + e.maxTranslate() < -T && (h = e.maxTranslate() - T), x = e.maxTranslate(), S = !0, g.allowMomentumBounce = !0) : h = e.maxTranslate(), c.loop && c.centeredSlides && (L = !0); else if (h > e.minTranslate()) c.freeMode.momentumBounce ? (h - e.minTranslate() > T && (h = e.minTranslate() + T), x = e.minTranslate(), S = !0, g.allowMomentumBounce = !0) : h = e.minTranslate(), c.loop && c.centeredSlides && (L = !0); else if (c.freeMode.sticky) { let b; for (let C = 0; C < v.length; C += 1)if (v[C] > -h) { b = C; break } Math.abs(v[b] - h) < Math.abs(v[b - 1] - h) || e.swipeDirection === "next" ? h = v[b] : h = v[b - 1], h = -h } if (L && i("transitionEnd", () => { e.loopFix() }), e.velocity !== 0) { if (f ? p = Math.abs((-h - e.translate) / e.velocity) : p = Math.abs((h - e.translate) / e.velocity), c.freeMode.sticky) { const b = Math.abs((f ? -h : h) - e.translate), C = e.slidesSizesGrid[e.activeIndex]; b < C ? p = c.speed : b < 2 * C ? p = c.speed * 1.5 : p = c.speed * 2.5 } } else if (c.freeMode.sticky) { e.slideToClosest(); return } c.freeMode.momentumBounce && S ? (e.updateProgress(x), e.setTransition(p), e.setTranslate(h), e.transitionStart(!0, e.swipeDirection), e.animating = !0, Tr(d, () => { !e || e.destroyed || !g.allowMomentumBounce || (r("momentumBounce"), e.setTransition(c.speed), setTimeout(() => { e.setTranslate(x), Tr(d, () => { !e || e.destroyed || e.transitionEnd() }) }, 0)) })) : e.velocity ? (r("_freeModeNoMomentumRelease"), e.updateProgress(h), e.setTransition(p), e.setTranslate(h), e.transitionStart(!0, e.swipeDirection), e.animating || (e.animating = !0, Tr(d, () => { !e || e.destroyed || e.transitionEnd() }))) : e.updateProgress(h), e.updateActiveIndex(), e.updateSlidesClasses() } else if (c.freeMode.sticky) { e.slideToClosest(); return } else c.freeMode && r("_freeModeNoMomentumRelease"); (!c.freeMode.momentum || y >= c.longSwipesMs) && (r("_freeModeStaticRelease"), e.updateProgress(), e.updateActiveIndex(), e.updateSlidesClasses()) } Object.assign(e, { freeMode: { onTouchStart: s, onTouchMove: l, onTouchEnd: o } }) } function I0(t) { let { swiper: e, extendParams: n, on: r } = t; n({ grid: { rows: 1, fill: "column" } }); let i, s, l, o; const a = () => { let w = e.params.spaceBetween; return typeof w == "string" && w.indexOf("%") >= 0 ? w = parseFloat(w.replace("%", "")) / 100 * e.size : typeof w == "string" && (w = parseFloat(w)), w }, u = w => { const { slidesPerView: y } = e.params, { rows: p, fill: m } = e.params.grid, h = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : w.length; l = Math.floor(h / p), Math.floor(h / p) === h / p ? i = h : i = Math.ceil(h / p) * p, y !== "auto" && m === "row" && (i = Math.max(i, y * p)), s = i / p }, c = () => { e.slides && e.slides.forEach(w => { w.swiperSlideGridSet && (w.style.height = "", w.style[e.getDirectionLabel("margin-top")] = "") }) }, d = (w, y, p) => { const { slidesPerGroup: m } = e.params, h = a(), { rows: S, fill: x } = e.params.grid, T = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : p.length; let L, b, C; if (x === "row" && m > 1) { const P = Math.floor(w / (m * S)), N = w - S * m * P, M = P === 0 ? m : Math.min(Math.ceil((T - P * S * m) / S), m); C = Math.floor(N / M), b = N - C * M + P * m, L = b + C * i / S, y.style.order = L } else x === "column" ? (b = Math.floor(w / S), C = w - b * S, (b > l || b === l && C === S - 1) && (C += 1, C >= S && (C = 0, b += 1))) : (C = Math.floor(w / s), b = w - C * s); y.row = C, y.column = b, y.style.height = `calc((100% - ${(S - 1) * h}px) / ${S})`, y.style[e.getDirectionLabel("margin-top")] = C !== 0 ? h && `${h}px` : "", y.swiperSlideGridSet = !0 }, f = (w, y) => { const { centeredSlides: p, roundLengths: m } = e.params, h = a(), { rows: S } = e.params.grid; if (e.virtualSize = (w + h) * i, e.virtualSize = Math.ceil(e.virtualSize / S) - h, e.params.cssMode || (e.wrapperEl.style[e.getDirectionLabel("width")] = `${e.virtualSize + h}px`), p) { const x = []; for (let T = 0; T < y.length; T += 1) { let L = y[T]; m && (L = Math.floor(L)), y[T] < e.virtualSize + y[0] && x.push(L) } y.splice(0, y.length), y.push(...x) } }, v = () => { o = e.params.grid && e.params.grid.rows > 1 }, g = () => { const { params: w, el: y } = e, p = w.grid && w.grid.rows > 1; o && !p ? (y.classList.remove(`${w.containerModifierClass}grid`, `${w.containerModifierClass}grid-column`), l = 1, e.emitContainerClasses()) : !o && p && (y.classList.add(`${w.containerModifierClass}grid`), w.grid.fill === "column" && y.classList.add(`${w.containerModifierClass}grid-column`), e.emitContainerClasses()), o = p }; r("init", v), r("update", g), e.grid = { initSlides: u, unsetSlides: c, updateSlide: d, updateWrapperSize: f } } function O0(t) { const e = this, { params: n, slidesEl: r } = e; n.loop && e.loopDestroy(); const i = s => { if (typeof s == "string") { const l = document.createElement("div"); l.innerHTML = s, r.append(l.children[0]), l.innerHTML = "" } else r.append(s) }; if (typeof t == "object" && "length" in t) for (let s = 0; s < t.length; s += 1)t[s] && i(t[s]); else i(t); e.recalcSlides(), n.loop && e.loopCreate(), (!n.observer || e.isElement) && e.update() } function N0(t) { const e = this, { params: n, activeIndex: r, slidesEl: i } = e; n.loop && e.loopDestroy(); let s = r + 1; const l = o => { if (typeof o == "string") { const a = document.createElement("div"); a.innerHTML = o, i.prepend(a.children[0]), a.innerHTML = "" } else i.prepend(o) }; if (typeof t == "object" && "length" in t) { for (let o = 0; o < t.length; o += 1)t[o] && l(t[o]); s = r + t.length } else l(t); e.recalcSlides(), n.loop && e.loopCreate(), (!n.observer || e.isElement) && e.update(), e.slideTo(s, 0, !1) } function A0(t, e) { const n = this, { params: r, activeIndex: i, slidesEl: s } = n; let l = i; r.loop && (l -= n.loopedSlides, n.loopDestroy(), n.recalcSlides()); const o = n.slides.length; if (t <= 0) { n.prependSlide(e); return } if (t >= o) { n.appendSlide(e); return } let a = l > t ? l + 1 : l; const u = []; for (let c = o - 1; c >= t; c -= 1) { const d = n.slides[c]; d.remove(), u.unshift(d) } if (typeof e == "object" && "length" in e) { for (let c = 0; c < e.length; c += 1)e[c] && s.append(e[c]); a = l > t ? l + e.length : l } else s.append(e); for (let c = 0; c < u.length; c += 1)s.append(u[c]); n.recalcSlides(), r.loop && n.loopCreate(), (!r.observer || n.isElement) && n.update(), r.loop ? n.slideTo(a + n.loopedSlides, 0, !1) : n.slideTo(a, 0, !1) } function D0(t) { const e = this, { params: n, activeIndex: r } = e; let i = r; n.loop && (i -= e.loopedSlides, e.loopDestroy()); let s = i, l; if (typeof t == "object" && "length" in t) { for (let o = 0; o < t.length; o += 1)l = t[o], e.slides[l] && e.slides[l].remove(), l < s && (s -= 1); s = Math.max(s, 0) } else l = t, e.slides[l] && e.slides[l].remove(), l < s && (s -= 1), s = Math.max(s, 0); e.recalcSlides(), n.loop && e.loopCreate(), (!n.observer || e.isElement) && e.update(), n.loop ? e.slideTo(s + e.loopedSlides, 0, !1) : e.slideTo(s, 0, !1) } function R0() { const t = this, e = []; for (let n = 0; n < t.slides.length; n += 1)e.push(n); t.removeSlide(e) } function $0(t) { let { swiper: e } = t; Object.assign(e, { appendSlide: O0.bind(e), prependSlide: N0.bind(e), addSlide: A0.bind(e), removeSlide: D0.bind(e), removeAllSlides: R0.bind(e) }) } function Yn(t) { const { effect: e, swiper: n, on: r, setTranslate: i, setTransition: s, overwriteParams: l, perspective: o, recreateShadows: a, getEffectParams: u } = t; r("beforeInit", () => { if (n.params.effect !== e) return; n.classNames.push(`${n.params.containerModifierClass}${e}`), o && o() && n.classNames.push(`${n.params.containerModifierClass}3d`); const d = l ? l() : {}; Object.assign(n.params, d), Object.assign(n.originalParams, d) }), r("setTranslate", () => { n.params.effect === e && i() }), r("setTransition", (d, f) => { n.params.effect === e && s(f) }), r("transitionEnd", () => { if (n.params.effect === e && a) { if (!u || !u().slideShadows) return; n.slides.forEach(d => { d.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(f => f.remove()) }), a() } }); let c; r("virtualUpdate", () => { n.params.effect === e && (n.slides.length || (c = !0), requestAnimationFrame(() => { c && n.slides && n.slides.length && (i(), c = !1) })) }) } function Ur(t, e) { const n = pn(e); return n !== e && (n.style.backfaceVisibility = "hidden", n.style["-webkit-backface-visibility"] = "hidden"), n } function Is(t) { let { swiper: e, duration: n, transformElements: r, allSlides: i } = t; const { activeIndex: s } = e, l = o => o.parentElement ? o.parentElement : e.slides.filter(u => u.shadowRoot && u.shadowRoot === o.parentNode)[0]; if (e.params.virtualTranslate && n !== 0) { let o = !1, a; i ? a = r : a = r.filter(u => { const c = u.classList.contains("swiper-slide-transform") ? l(u) : u; return e.getSlideIndex(c) === s }), a.forEach(u => { Tr(u, () => { if (o || !e || e.destroyed) return; o = !0, e.animating = !1; const c = new window.CustomEvent("transitionend", { bubbles: !0, cancelable: !0 }); e.wrapperEl.dispatchEvent(c) }) }) } } function j0(t) { let { swiper: e, extendParams: n, on: r } = t; n({ fadeEffect: { crossFade: !1 } }), Yn({ effect: "fade", swiper: e, on: r, setTranslate: () => { const { slides: l } = e, o = e.params.fadeEffect; for (let a = 0; a < l.length; a += 1) { const u = e.slides[a]; let d = -u.swiperSlideOffset; e.params.virtualTranslate || (d -= e.translate); let f = 0; e.isHorizontal() || (f = d, d = 0); const v = e.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(u.progress), 0) : 1 + Math.min(Math.max(u.progress, -1), 0), g = Ur(o, u); g.style.opacity = v, g.style.transform = `translate3d(${d}px, ${f}px, 0px)` } }, setTransition: l => { const o = e.slides.map(a => pn(a)); o.forEach(a => { a.style.transitionDuration = `${l}ms` }), Is({ swiper: e, duration: l, transformElements: o, allSlides: !0 }) }, overwriteParams: () => ({ slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !e.params.cssMode }) }) } function F0(t) { let { swiper: e, extendParams: n, on: r } = t; n({ cubeEffect: { slideShadows: !0, shadow: !0, shadowOffset: 20, shadowScale: .94 } }); const i = (a, u, c) => { let d = c ? a.querySelector(".swiper-slide-shadow-left") : a.querySelector(".swiper-slide-shadow-top"), f = c ? a.querySelector(".swiper-slide-shadow-right") : a.querySelector(".swiper-slide-shadow-bottom"); d || (d = He("div", `swiper-slide-shadow-cube swiper-slide-shadow-${c ? "left" : "top"}`.split(" ")), a.append(d)), f || (f = He("div", `swiper-slide-shadow-cube swiper-slide-shadow-${c ? "right" : "bottom"}`.split(" ")), a.append(f)), d && (d.style.opacity = Math.max(-u, 0)), f && (f.style.opacity = Math.max(u, 0)) }; Yn({ effect: "cube", swiper: e, on: r, setTranslate: () => { const { el: a, wrapperEl: u, slides: c, width: d, height: f, rtlTranslate: v, size: g, browser: w } = e, y = e.params.cubeEffect, p = e.isHorizontal(), m = e.virtual && e.params.virtual.enabled; let h = 0, S; y.shadow && (p ? (S = e.wrapperEl.querySelector(".swiper-cube-shadow"), S || (S = He("div", "swiper-cube-shadow"), e.wrapperEl.append(S)), S.style.height = `${d}px`) : (S = a.querySelector(".swiper-cube-shadow"), S || (S = He("div", "swiper-cube-shadow"), a.append(S)))); for (let T = 0; T < c.length; T += 1) { const L = c[T]; let b = T; m && (b = parseInt(L.getAttribute("data-swiper-slide-index"), 10)); let C = b * 90, P = Math.floor(C / 360); v && (C = -C, P = Math.floor(-C / 360)); const N = Math.max(Math.min(L.progress, 1), -1); let M = 0, _ = 0, O = 0; b % 4 === 0 ? (M = -P * 4 * g, O = 0) : (b - 1) % 4 === 0 ? (M = 0, O = -P * 4 * g) : (b - 2) % 4 === 0 ? (M = g + P * 4 * g, O = g) : (b - 3) % 4 === 0 && (M = -g, O = 3 * g + g * 4 * P), v && (M = -M), p || (_ = M, M = 0); const R = `rotateX(${p ? 0 : -C}deg) rotateY(${p ? C : 0}deg) translate3d(${M}px, ${_}px, ${O}px)`; N <= 1 && N > -1 && (h = b * 90 + N * 90, v && (h = -b * 90 - N * 90), e.browser && e.browser.need3dFix && Math.abs(h) / 90 % 2 === 1 && (h += .001)), L.style.transform = R, y.slideShadows && i(L, N, p) } if (u.style.transformOrigin = `50% 50% -${g / 2}px`, u.style["-webkit-transform-origin"] = `50% 50% -${g / 2}px`, y.shadow) if (p) S.style.transform = `translate3d(0px, ${d / 2 + y.shadowOffset}px, ${-d / 2}px) rotateX(89.99deg) rotateZ(0deg) scale(${y.shadowScale})`; else { const T = Math.abs(h) - Math.floor(Math.abs(h) / 90) * 90, L = 1.5 - (Math.sin(T * 2 * Math.PI / 360) / 2 + Math.cos(T * 2 * Math.PI / 360) / 2), b = y.shadowScale, C = y.shadowScale / L, P = y.shadowOffset; S.style.transform = `scale3d(${b}, 1, ${C}) translate3d(0px, ${f / 2 + P}px, ${-f / 2 / C}px) rotateX(-89.99deg)` } const x = (w.isSafari || w.isWebView) && w.needPerspectiveFix ? -g / 2 : 0; u.style.transform = `translate3d(0px,0,${x}px) rotateX(${e.isHorizontal() ? 0 : h}deg) rotateY(${e.isHorizontal() ? -h : 0}deg)`, u.style.setProperty("--swiper-cube-translate-z", `${x}px`) }, setTransition: a => { const { el: u, slides: c } = e; if (c.forEach(d => { d.style.transitionDuration = `${a}ms`, d.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(f => { f.style.transitionDuration = `${a}ms` }) }), e.params.cubeEffect.shadow && !e.isHorizontal()) { const d = u.querySelector(".swiper-cube-shadow"); d && (d.style.transitionDuration = `${a}ms`) } }, recreateShadows: () => { const a = e.isHorizontal(); e.slides.forEach(u => { const c = Math.max(Math.min(u.progress, 1), -1); i(u, c, a) }) }, getEffectParams: () => e.params.cubeEffect, perspective: () => !0, overwriteParams: () => ({ slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, resistanceRatio: 0, spaceBetween: 0, centeredSlides: !1, virtualTranslate: !0 }) }) } function Vn(t, e, n) { const r = `swiper-slide-shadow${n ? `-${n}` : ""}${t ? ` swiper-slide-shadow-${t}` : ""}`, i = pn(e); let s = i.querySelector(`.${r.split(" ").join(".")}`); return s || (s = He("div", r.split(" ")), i.append(s)), s } function H0(t) { let { swiper: e, extendParams: n, on: r } = t; n({ flipEffect: { slideShadows: !0, limitRotation: !0 } }); const i = (a, u) => { let c = e.isHorizontal() ? a.querySelector(".swiper-slide-shadow-left") : a.querySelector(".swiper-slide-shadow-top"), d = e.isHorizontal() ? a.querySelector(".swiper-slide-shadow-right") : a.querySelector(".swiper-slide-shadow-bottom"); c || (c = Vn("flip", a, e.isHorizontal() ? "left" : "top")), d || (d = Vn("flip", a, e.isHorizontal() ? "right" : "bottom")), c && (c.style.opacity = Math.max(-u, 0)), d && (d.style.opacity = Math.max(u, 0)) }; Yn({ effect: "flip", swiper: e, on: r, setTranslate: () => { const { slides: a, rtlTranslate: u } = e, c = e.params.flipEffect; for (let d = 0; d < a.length; d += 1) { const f = a[d]; let v = f.progress; e.params.flipEffect.limitRotation && (v = Math.max(Math.min(f.progress, 1), -1)); const g = f.swiperSlideOffset; let y = -180 * v, p = 0, m = e.params.cssMode ? -g - e.translate : -g, h = 0; e.isHorizontal() ? u && (y = -y) : (h = m, m = 0, p = -y, y = 0), e.browser && e.browser.need3dFix && (Math.abs(y) / 90 % 2 === 1 && (y += .001), Math.abs(p) / 90 % 2 === 1 && (p += .001)), f.style.zIndex = -Math.abs(Math.round(v)) + a.length, c.slideShadows && i(f, v); const S = `translate3d(${m}px, ${h}px, 0px) rotateX(${p}deg) rotateY(${y}deg)`, x = Ur(c, f); x.style.transform = S } }, setTransition: a => { const u = e.slides.map(c => pn(c)); u.forEach(c => { c.style.transitionDuration = `${a}ms`, c.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(d => { d.style.transitionDuration = `${a}ms` }) }), Is({ swiper: e, duration: a, transformElements: u }) }, recreateShadows: () => { e.params.flipEffect, e.slides.forEach(a => { let u = a.progress; e.params.flipEffect.limitRotation && (u = Math.max(Math.min(a.progress, 1), -1)), i(a, u) }) }, getEffectParams: () => e.params.flipEffect, perspective: () => !0, overwriteParams: () => ({ slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !e.params.cssMode }) }) } function B0(t) { let { swiper: e, extendParams: n, on: r } = t; n({ coverflowEffect: { rotate: 50, stretch: 0, depth: 100, scale: 1, modifier: 1, slideShadows: !0 } }), Yn({ effect: "coverflow", swiper: e, on: r, setTranslate: () => { const { width: l, height: o, slides: a, slidesSizesGrid: u } = e, c = e.params.coverflowEffect, d = e.isHorizontal(), f = e.translate, v = d ? -f + l / 2 : -f + o / 2, g = d ? c.rotate : -c.rotate, w = c.depth; for (let y = 0, p = a.length; y < p; y += 1) { const m = a[y], h = u[y], S = m.swiperSlideOffset, x = (v - S - h / 2) / h, T = typeof c.modifier == "function" ? c.modifier(x) : x * c.modifier; let L = d ? g * T : 0, b = d ? 0 : g * T, C = -w * Math.abs(T), P = c.stretch; typeof P == "string" && P.indexOf("%") !== -1 && (P = parseFloat(c.stretch) / 100 * h); let N = d ? 0 : P * T, M = d ? P * T : 0, _ = 1 - (1 - c.scale) * Math.abs(T); Math.abs(M) < .001 && (M = 0), Math.abs(N) < .001 && (N = 0), Math.abs(C) < .001 && (C = 0), Math.abs(L) < .001 && (L = 0), Math.abs(b) < .001 && (b = 0), Math.abs(_) < .001 && (_ = 0), e.browser && e.browser.need3dFix && (Math.abs(L) / 90 % 2 === 1 && (L += .001), Math.abs(b) / 90 % 2 === 1 && (b += .001)); const O = `translate3d(${M}px,${N}px,${C}px)  rotateX(${b}deg) rotateY(${L}deg) scale(${_})`, R = Ur(c, m); if (R.style.transform = O, m.style.zIndex = -Math.abs(Math.round(T)) + 1, c.slideShadows) { let j = d ? m.querySelector(".swiper-slide-shadow-left") : m.querySelector(".swiper-slide-shadow-top"), I = d ? m.querySelector(".swiper-slide-shadow-right") : m.querySelector(".swiper-slide-shadow-bottom"); j || (j = Vn("coverflow", m, d ? "left" : "top")), I || (I = Vn("coverflow", m, d ? "right" : "bottom")), j && (j.style.opacity = T > 0 ? T : 0), I && (I.style.opacity = -T > 0 ? -T : 0) } } }, setTransition: l => { e.slides.map(a => pn(a)).forEach(a => { a.style.transitionDuration = `${l}ms`, a.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(u => { u.style.transitionDuration = `${l}ms` }) }) }, perspective: () => !0, overwriteParams: () => ({ watchSlidesProgress: !0 }) }) } function V0(t) { let { swiper: e, extendParams: n, on: r } = t; n({ creativeEffect: { limitProgress: 1, shadowPerProgress: !1, progressMultiplier: 1, perspective: !0, prev: { translate: [0, 0, 0], rotate: [0, 0, 0], opacity: 1, scale: 1 }, next: { translate: [0, 0, 0], rotate: [0, 0, 0], opacity: 1, scale: 1 } } }); const i = o => typeof o == "string" ? o : `${o}px`; Yn({ effect: "creative", swiper: e, on: r, setTranslate: () => { const { slides: o, wrapperEl: a, slidesSizesGrid: u } = e, c = e.params.creativeEffect, { progressMultiplier: d } = c, f = e.params.centeredSlides; if (f) { const v = u[0] / 2 - e.params.slidesOffsetBefore || 0; a.style.transform = `translateX(calc(50% - ${v}px))` } for (let v = 0; v < o.length; v += 1) { const g = o[v], w = g.progress, y = Math.min(Math.max(g.progress, -c.limitProgress), c.limitProgress); let p = y; f || (p = Math.min(Math.max(g.originalProgress, -c.limitProgress), c.limitProgress)); const m = g.swiperSlideOffset, h = [e.params.cssMode ? -m - e.translate : -m, 0, 0], S = [0, 0, 0]; let x = !1; e.isHorizontal() || (h[1] = h[0], h[0] = 0); let T = { translate: [0, 0, 0], rotate: [0, 0, 0], scale: 1, opacity: 1 }; y < 0 ? (T = c.next, x = !0) : y > 0 && (T = c.prev, x = !0), h.forEach((_, O) => { h[O] = `calc(${_}px + (${i(T.translate[O])} * ${Math.abs(y * d)}))` }), S.forEach((_, O) => { let R = T.rotate[O] * Math.abs(y * d); e.browser && e.browser.need3dFix && Math.abs(R) / 90 % 2 === 1 && (R += .001), S[O] = R }), g.style.zIndex = -Math.abs(Math.round(w)) + o.length; const L = h.join(", "), b = `rotateX(${S[0]}deg) rotateY(${S[1]}deg) rotateZ(${S[2]}deg)`, C = p < 0 ? `scale(${1 + (1 - T.scale) * p * d})` : `scale(${1 - (1 - T.scale) * p * d})`, P = p < 0 ? 1 + (1 - T.opacity) * p * d : 1 - (1 - T.opacity) * p * d, N = `translate3d(${L}) ${b} ${C}`; if (x && T.shadow || !x) { let _ = g.querySelector(".swiper-slide-shadow"); if (!_ && T.shadow && (_ = Vn("creative", g)), _) { const O = c.shadowPerProgress ? y * (1 / c.limitProgress) : y; _.style.opacity = Math.min(Math.max(Math.abs(O), 0), 1) } } const M = Ur(c, g); M.style.transform = N, M.style.opacity = P, T.origin && (M.style.transformOrigin = T.origin) } }, setTransition: o => { const a = e.slides.map(u => pn(u)); a.forEach(u => { u.style.transitionDuration = `${o}ms`, u.querySelectorAll(".swiper-slide-shadow").forEach(c => { c.style.transitionDuration = `${o}ms` }) }), Is({ swiper: e, duration: o, transformElements: a, allSlides: !0 }) }, perspective: () => e.params.creativeEffect.perspective, overwriteParams: () => ({ watchSlidesProgress: !0, virtualTranslate: !e.params.cssMode }) }) } function G0(t) {
  let { swiper: e, extendParams: n, on: r } = t; n({ cardsEffect: { slideShadows: !0, rotate: !0, perSlideRotate: 2, perSlideOffset: 8 } }), Yn({
    effect: "cards", swiper: e, on: r, setTranslate: () => {
      const { slides: l, activeIndex: o, rtlTranslate: a } = e, u = e.params.cardsEffect, { startTranslate: c, isTouched: d } = e.touchEventsData, f = a ? -e.translate : e.translate; for (let v = 0; v < l.length; v += 1) {
        const g = l[v], w = g.progress, y = Math.min(Math.max(w, -4), 4); let p = g.swiperSlideOffset; e.params.centeredSlides && !e.params.cssMode && (e.wrapperEl.style.transform = `translateX(${e.minTranslate()}px)`), e.params.centeredSlides && e.params.cssMode && (p -= l[0].swiperSlideOffset); let m = e.params.cssMode ? -p - e.translate : -p, h = 0; const S = -100 * Math.abs(y); let x = 1, T = -u.perSlideRotate * y, L = u.perSlideOffset - Math.abs(y) * .75; const b = e.virtual && e.params.virtual.enabled ? e.virtual.from + v : v, C = (b === o || b === o - 1) && y > 0 && y < 1 && (d || e.params.cssMode) && f < c, P = (b === o || b === o + 1) && y < 0 && y > -1 && (d || e.params.cssMode) && f > c; if (C || P) { const O = (1 - Math.abs((Math.abs(y) - .5) / .5)) ** .5; T += -28 * y * O, x += -.5 * O, L += 96 * O, h = `${-25 * O * Math.abs(y)}%` } if (y < 0 ? m = `calc(${m}px ${a ? "-" : "+"} (${L * Math.abs(y)}%))` : y > 0 ? m = `calc(${m}px ${a ? "-" : "+"} (-${L * Math.abs(y)}%))` : m = `${m}px`, !e.isHorizontal()) { const O = h; h = m, m = O } const N = y < 0 ? `${1 + (1 - x) * y}` : `${1 - (1 - x) * y}`, M = `
        translate3d(${m}, ${h}, ${S}px)
        rotateZ(${u.rotate ? a ? -T : T : 0}deg)
        scale(${N})
      `; if (u.slideShadows) { let O = g.querySelector(".swiper-slide-shadow"); O || (O = Vn("cards", g)), O && (O.style.opacity = Math.min(Math.max((Math.abs(y) - .5) / .5, 0), 1)) } g.style.zIndex = -Math.abs(Math.round(w)) + l.length; const _ = Ur(u, g); _.style.transform = M
      }
    }, setTransition: l => { const o = e.slides.map(a => pn(a)); o.forEach(a => { a.style.transitionDuration = `${l}ms`, a.querySelectorAll(".swiper-slide-shadow").forEach(u => { u.style.transitionDuration = `${l}ms` }) }), Is({ swiper: e, duration: l, transformElements: o }) }, perspective: () => !0, overwriteParams: () => ({ watchSlidesProgress: !0, virtualTranslate: !e.params.cssMode })
  })
} const W0 = [v0, w0, y0, S0, E0, x0, T0, b0, C0, P0, k0, M0, _0, L0, z0, I0, $0, j0, F0, H0, B0, V0, G0]; $e.use(W0); const Os = ["eventsPrefix", "injectStyles", "injectStylesUrls", "modules", "init", "_direction", "oneWayMovement", "swiperElementNodeName", "touchEventsTarget", "initialSlide", "_speed", "cssMode", "updateOnWindowResize", "resizeObserver", "nested", "focusableElements", "_enabled", "_width", "_height", "preventInteractionOnTransition", "userAgent", "url", "_edgeSwipeDetection", "_edgeSwipeThreshold", "_freeMode", "_autoHeight", "setWrapperSize", "virtualTranslate", "_effect", "breakpoints", "breakpointsBase", "_spaceBetween", "_slidesPerView", "maxBackfaceHiddenSlides", "_grid", "_slidesPerGroup", "_slidesPerGroupSkip", "_slidesPerGroupAuto", "_centeredSlides", "_centeredSlidesBounds", "_slidesOffsetBefore", "_slidesOffsetAfter", "normalizeSlideIndex", "_centerInsufficientSlides", "_watchOverflow", "roundLengths", "touchRatio", "touchAngle", "simulateTouch", "_shortSwipes", "_longSwipes", "longSwipesRatio", "longSwipesMs", "_followFinger", "allowTouchMove", "_threshold", "touchMoveStopPropagation", "touchStartPreventDefault", "touchStartForcePreventDefault", "touchReleaseOnEdges", "uniqueNavElements", "_resistance", "_resistanceRatio", "_watchSlidesProgress", "_grabCursor", "preventClicks", "preventClicksPropagation", "_slideToClickedSlide", "_loop", "loopAdditionalSlides", "loopAddBlankSlides", "loopPreventsSliding", "_rewind", "_allowSlidePrev", "_allowSlideNext", "_swipeHandler", "_noSwiping", "noSwipingClass", "noSwipingSelector", "passiveListeners", "containerModifierClass", "slideClass", "slideActiveClass", "slideVisibleClass", "slideFullyVisibleClass", "slideNextClass", "slidePrevClass", "slideBlankClass", "wrapperClass", "lazyPreloaderClass", "lazyPreloadPrevNext", "runCallbacksOnInit", "observer", "observeParents", "observeSlideChildren", "a11y", "_autoplay", "_controller", "coverflowEffect", "cubeEffect", "fadeEffect", "flipEffect", "creativeEffect", "cardsEffect", "hashNavigation", "history", "keyboard", "mousewheel", "_navigation", "_pagination", "parallax", "_scrollbar", "_thumbs", "virtual", "zoom", "control"]; function Gn(t) { return typeof t == "object" && t !== null && t.constructor && Object.prototype.toString.call(t).slice(8, -1) === "Object" && !t.__swiper__ } function Ea(t, e) { const n = ["__proto__", "constructor", "prototype"]; Object.keys(e).filter(r => n.indexOf(r) < 0).forEach(r => { typeof t[r] > "u" ? t[r] = e[r] : Gn(e[r]) && Gn(t[r]) && Object.keys(e[r]).length > 0 ? e[r].__swiper__ ? t[r] = e[r] : Ea(t[r], e[r]) : t[r] = e[r] }) } function X0(t) { return t === void 0 && (t = {}), t.navigation && typeof t.navigation.nextEl > "u" && typeof t.navigation.prevEl > "u" } function U0(t) { return t === void 0 && (t = {}), t.pagination && typeof t.pagination.el > "u" } function Y0(t) { return t === void 0 && (t = {}), t.scrollbar && typeof t.scrollbar.el > "u" } function Ii(t) { return t === void 0 && (t = ""), t.replace(/-[a-z]/g, e => e.toUpperCase().replace("-", "")) } function q0(t) { let { swiper: e, slides: n, passedParams: r, changedParams: i, nextEl: s, prevEl: l, scrollbarEl: o, paginationEl: a } = t; const u = i.filter(C => C !== "children" && C !== "direction" && C !== "wrapperClass"), { params: c, pagination: d, navigation: f, scrollbar: v, virtual: g, thumbs: w } = e; let y, p, m, h, S, x, T, L; i.includes("thumbs") && r.thumbs && r.thumbs.swiper && c.thumbs && !c.thumbs.swiper && (y = !0), i.includes("controller") && r.controller && r.controller.control && c.controller && !c.controller.control && (p = !0), i.includes("pagination") && r.pagination && (r.pagination.el || a) && (c.pagination || c.pagination === !1) && d && !d.el && (m = !0), i.includes("scrollbar") && r.scrollbar && (r.scrollbar.el || o) && (c.scrollbar || c.scrollbar === !1) && v && !v.el && (h = !0), i.includes("navigation") && r.navigation && (r.navigation.prevEl || l) && (r.navigation.nextEl || s) && (c.navigation || c.navigation === !1) && f && !f.prevEl && !f.nextEl && (S = !0); const b = C => { e[C] && (e[C].destroy(), C === "navigation" ? (e.isElement && (e[C].prevEl.remove(), e[C].nextEl.remove()), c[C].prevEl = void 0, c[C].nextEl = void 0, e[C].prevEl = void 0, e[C].nextEl = void 0) : (e.isElement && e[C].el.remove(), c[C].el = void 0, e[C].el = void 0)) }; i.includes("loop") && e.isElement && (c.loop && !r.loop ? x = !0 : !c.loop && r.loop ? T = !0 : L = !0), u.forEach(C => { if (Gn(c[C]) && Gn(r[C])) Object.assign(c[C], r[C]), (C === "navigation" || C === "pagination" || C === "scrollbar") && "enabled" in r[C] && !r[C].enabled && b(C); else { const P = r[C]; (P === !0 || P === !1) && (C === "navigation" || C === "pagination" || C === "scrollbar") ? P === !1 && b(C) : c[C] = r[C] } }), u.includes("controller") && !p && e.controller && e.controller.control && c.controller && c.controller.control && (e.controller.control = c.controller.control), i.includes("children") && n && g && c.virtual.enabled ? (g.slides = n, g.update(!0)) : i.includes("virtual") && g && c.virtual.enabled && (n && (g.slides = n), g.update(!0)), i.includes("children") && n && c.loop && (L = !0), y && w.init() && w.update(!0), p && (e.controller.control = c.controller.control), m && (e.isElement && (!a || typeof a == "string") && (a = document.createElement("div"), a.classList.add("swiper-pagination"), a.part.add("pagination"), e.el.appendChild(a)), a && (c.pagination.el = a), d.init(), d.render(), d.update()), h && (e.isElement && (!o || typeof o == "string") && (o = document.createElement("div"), o.classList.add("swiper-scrollbar"), o.part.add("scrollbar"), e.el.appendChild(o)), o && (c.scrollbar.el = o), v.init(), v.updateSize(), v.setTranslate()), S && (e.isElement && ((!s || typeof s == "string") && (s = document.createElement("div"), s.classList.add("swiper-button-next"), s.innerHTML = e.hostEl.constructor.nextButtonSvg, s.part.add("button-next"), e.el.appendChild(s)), (!l || typeof l == "string") && (l = document.createElement("div"), l.classList.add("swiper-button-prev"), l.innerHTML = e.hostEl.constructor.prevButtonSvg, l.part.add("button-prev"), e.el.appendChild(l))), s && (c.navigation.nextEl = s), l && (c.navigation.prevEl = l), f.init(), f.update()), i.includes("allowSlideNext") && (e.allowSlideNext = r.allowSlideNext), i.includes("allowSlidePrev") && (e.allowSlidePrev = r.allowSlidePrev), i.includes("direction") && e.changeDirection(r.direction, !1), (x || L) && e.loopDestroy(), (T || L) && e.loopCreate(), e.update() } const hc = t => { if (parseFloat(t) === Number(t)) return Number(t); if (t === "true" || t === "") return !0; if (t === "false") return !1; if (t === "null") return null; if (t !== "undefined") { if (typeof t == "string" && t.includes("{") && t.includes("}") && t.includes('"')) { let e; try { e = JSON.parse(t) } catch { e = t } return e } return t } }, gc = ["a11y", "autoplay", "controller", "cards-effect", "coverflow-effect", "creative-effect", "cube-effect", "fade-effect", "flip-effect", "free-mode", "grid", "hash-navigation", "history", "keyboard", "mousewheel", "navigation", "pagination", "parallax", "scrollbar", "thumbs", "virtual", "zoom"]; function vc(t, e, n) { const r = {}, i = {}; Ea(r, Sa); const s = [...Os, "on"], l = s.map(a => a.replace(/_/, "")); s.forEach(a => { a = a.replace("_", ""), typeof t[a] < "u" && (i[a] = t[a]) }); const o = [...t.attributes]; return typeof e == "string" && typeof n < "u" && o.push({ name: e, value: Gn(n) ? { ...n } : n }), o.forEach(a => { const u = gc.filter(c => a.name.indexOf(`${c}-`) === 0)[0]; if (u) { const c = Ii(u), d = Ii(a.name.split(`${u}-`)[1]); typeof i[c] > "u" && (i[c] = {}), i[c] === !0 && (i[c] = { enabled: !0 }), i[c][d] = hc(a.value) } else { const c = Ii(a.name); if (!l.includes(c)) return; const d = hc(a.value); i[c] && gc.includes(a.name) && !Gn(d) ? (i[c].constructor !== Object && (i[c] = {}), i[c].enabled = !!d) : i[c] = d } }), Ea(r, i), r.navigation ? r.navigation = { prevEl: ".swiper-button-prev", nextEl: ".swiper-button-next", ...r.navigation !== !0 ? r.navigation : {} } : r.navigation === !1 && delete r.navigation, r.scrollbar ? r.scrollbar = { el: ".swiper-scrollbar", ...r.scrollbar !== !0 ? r.scrollbar : {} } : r.scrollbar === !1 && delete r.scrollbar, r.pagination ? r.pagination = { el: ".swiper-pagination", ...r.pagination !== !0 ? r.pagination : {} } : r.pagination === !1 && delete r.pagination, { params: r, passedParams: i } } const Q0 = ":host{--swiper-theme-color:#007aff}:host{position:relative;display:block;margin-left:auto;margin-right:auto;z-index:1}.swiper{width:100%;height:100%;margin-left:auto;margin-right:auto;position:relative;overflow:hidden;list-style:none;padding:0;z-index:1;display:block}.swiper-vertical>.swiper-wrapper{flex-direction:column}.swiper-wrapper{position:relative;width:100%;height:100%;z-index:1;display:flex;transition-property:transform;transition-timing-function:var(--swiper-wrapper-transition-timing-function,initial);box-sizing:content-box}.swiper-android ::slotted(swiper-slide),.swiper-ios ::slotted(swiper-slide),.swiper-wrapper{transform:translate3d(0px,0,0)}.swiper-horizontal{touch-action:pan-y}.swiper-vertical{touch-action:pan-x}::slotted(swiper-slide){flex-shrink:0;width:100%;height:100%;position:relative;transition-property:transform;display:block}::slotted(.swiper-slide-invisible-blank){visibility:hidden}.swiper-autoheight,.swiper-autoheight ::slotted(swiper-slide){height:auto}.swiper-autoheight .swiper-wrapper{align-items:flex-start;transition-property:transform,height}.swiper-backface-hidden ::slotted(swiper-slide){transform:translateZ(0);-webkit-backface-visibility:hidden;backface-visibility:hidden}.swiper-3d.swiper-css-mode .swiper-wrapper{perspective:1200px}.swiper-3d .swiper-wrapper{transform-style:preserve-3d}.swiper-3d{perspective:1200px}.swiper-3d .swiper-cube-shadow,.swiper-3d ::slotted(swiper-slide){transform-style:preserve-3d}.swiper-css-mode>.swiper-wrapper{overflow:auto;scrollbar-width:none;-ms-overflow-style:none}.swiper-css-mode>.swiper-wrapper::-webkit-scrollbar{display:none}.swiper-css-mode ::slotted(swiper-slide){scroll-snap-align:start start}.swiper-css-mode.swiper-horizontal>.swiper-wrapper{scroll-snap-type:x mandatory}.swiper-css-mode.swiper-vertical>.swiper-wrapper{scroll-snap-type:y mandatory}.swiper-css-mode.swiper-free-mode>.swiper-wrapper{scroll-snap-type:none}.swiper-css-mode.swiper-free-mode ::slotted(swiper-slide){scroll-snap-align:none}.swiper-css-mode.swiper-centered>.swiper-wrapper::before{content:'';flex-shrink:0;order:9999}.swiper-css-mode.swiper-centered ::slotted(swiper-slide){scroll-snap-align:center center;scroll-snap-stop:always}.swiper-css-mode.swiper-centered.swiper-horizontal ::slotted(swiper-slide):first-child{margin-inline-start:var(--swiper-centered-offset-before)}.swiper-css-mode.swiper-centered.swiper-horizontal>.swiper-wrapper::before{height:100%;min-height:1px;width:var(--swiper-centered-offset-after)}.swiper-css-mode.swiper-centered.swiper-vertical ::slotted(swiper-slide):first-child{margin-block-start:var(--swiper-centered-offset-before)}.swiper-css-mode.swiper-centered.swiper-vertical>.swiper-wrapper::before{width:100%;min-width:1px;height:var(--swiper-centered-offset-after)}.swiper-virtual ::slotted(swiper-slide){-webkit-backface-visibility:hidden;transform:translateZ(0)}.swiper-virtual.swiper-css-mode .swiper-wrapper::after{content:'';position:absolute;left:0;top:0;pointer-events:none}.swiper-virtual.swiper-css-mode.swiper-horizontal .swiper-wrapper::after{height:1px;width:var(--swiper-virtual-size)}.swiper-virtual.swiper-css-mode.swiper-vertical .swiper-wrapper::after{width:1px;height:var(--swiper-virtual-size)}:host{--swiper-navigation-size:44px}.swiper-button-next,.swiper-button-prev{position:absolute;top:var(--swiper-navigation-top-offset,50%);width:calc(var(--swiper-navigation-size)/ 44 * 27);height:var(--swiper-navigation-size);margin-top:calc(0px - (var(--swiper-navigation-size)/ 2));z-index:10;cursor:pointer;display:flex;align-items:center;justify-content:center;color:var(--swiper-navigation-color,var(--swiper-theme-color))}.swiper-button-next.swiper-button-disabled,.swiper-button-prev.swiper-button-disabled{opacity:.35;cursor:auto;pointer-events:none}.swiper-button-next.swiper-button-hidden,.swiper-button-prev.swiper-button-hidden{opacity:0;cursor:auto;pointer-events:none}.swiper-navigation-disabled .swiper-button-next,.swiper-navigation-disabled .swiper-button-prev{display:none!important}.swiper-button-next svg,.swiper-button-prev svg{width:100%;height:100%;object-fit:contain;transform-origin:center}.swiper-rtl .swiper-button-next svg,.swiper-rtl .swiper-button-prev svg{transform:rotate(180deg)}.swiper-button-prev,.swiper-rtl .swiper-button-next{left:var(--swiper-navigation-sides-offset,10px);right:auto}.swiper-button-next,.swiper-rtl .swiper-button-prev{right:var(--swiper-navigation-sides-offset,10px);left:auto}.swiper-button-lock{display:none}.swiper-pagination{position:absolute;text-align:center;transition:.3s opacity;transform:translate3d(0,0,0);z-index:10}.swiper-pagination.swiper-pagination-hidden{opacity:0}.swiper-pagination-disabled>.swiper-pagination,.swiper-pagination.swiper-pagination-disabled{display:none!important}.swiper-horizontal>.swiper-pagination-bullets,.swiper-pagination-bullets.swiper-pagination-horizontal,.swiper-pagination-custom,.swiper-pagination-fraction{bottom:var(--swiper-pagination-bottom,8px);top:var(--swiper-pagination-top,auto);left:0;width:100%}.swiper-pagination-bullets-dynamic{overflow:hidden;font-size:0}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transform:scale(.33);position:relative}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active{transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-main{transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev{transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev-prev{transform:scale(.33)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next{transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next-next{transform:scale(.33)}.swiper-pagination-bullet{width:var(--swiper-pagination-bullet-width,var(--swiper-pagination-bullet-size,8px));height:var(--swiper-pagination-bullet-height,var(--swiper-pagination-bullet-size,8px));display:inline-block;border-radius:var(--swiper-pagination-bullet-border-radius,50%);background:var(--swiper-pagination-bullet-inactive-color,#000);opacity:var(--swiper-pagination-bullet-inactive-opacity, .2)}button.swiper-pagination-bullet{border:none;margin:0;padding:0;box-shadow:none;-webkit-appearance:none;appearance:none}.swiper-pagination-clickable .swiper-pagination-bullet{cursor:pointer}.swiper-pagination-bullet:only-child{display:none!important}.swiper-pagination-bullet-active{opacity:var(--swiper-pagination-bullet-opacity, 1);background:var(--swiper-pagination-color,var(--swiper-theme-color))}.swiper-pagination-vertical.swiper-pagination-bullets,.swiper-vertical>.swiper-pagination-bullets{right:var(--swiper-pagination-right,8px);left:var(--swiper-pagination-left,auto);top:50%;transform:translate3d(0px,-50%,0)}.swiper-pagination-vertical.swiper-pagination-bullets .swiper-pagination-bullet,.swiper-vertical>.swiper-pagination-bullets .swiper-pagination-bullet{margin:var(--swiper-pagination-bullet-vertical-gap,6px) 0;display:block}.swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic,.swiper-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{top:50%;transform:translateY(-50%);width:8px}.swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,.swiper-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{display:inline-block;transition:.2s transform,.2s top}.swiper-horizontal>.swiper-pagination-bullets .swiper-pagination-bullet,.swiper-pagination-horizontal.swiper-pagination-bullets .swiper-pagination-bullet{margin:0 var(--swiper-pagination-bullet-horizontal-gap,4px)}.swiper-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic,.swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{left:50%;transform:translateX(-50%);white-space:nowrap}.swiper-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,.swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transition:.2s transform,.2s left}.swiper-horizontal.swiper-rtl>.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transition:.2s transform,.2s right}.swiper-pagination-fraction{color:var(--swiper-pagination-fraction-color,inherit)}.swiper-pagination-progressbar{background:var(--swiper-pagination-progressbar-bg-color,rgba(0,0,0,.25));position:absolute}.swiper-pagination-progressbar .swiper-pagination-progressbar-fill{background:var(--swiper-pagination-color,var(--swiper-theme-color));position:absolute;left:0;top:0;width:100%;height:100%;transform:scale(0);transform-origin:left top}.swiper-rtl .swiper-pagination-progressbar .swiper-pagination-progressbar-fill{transform-origin:right top}.swiper-horizontal>.swiper-pagination-progressbar,.swiper-pagination-progressbar.swiper-pagination-horizontal,.swiper-pagination-progressbar.swiper-pagination-vertical.swiper-pagination-progressbar-opposite,.swiper-vertical>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite{width:100%;height:var(--swiper-pagination-progressbar-size,4px);left:0;top:0}.swiper-horizontal>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite,.swiper-pagination-progressbar.swiper-pagination-horizontal.swiper-pagination-progressbar-opposite,.swiper-pagination-progressbar.swiper-pagination-vertical,.swiper-vertical>.swiper-pagination-progressbar{width:var(--swiper-pagination-progressbar-size,4px);height:100%;left:0;top:0}.swiper-pagination-lock{display:none}.swiper-scrollbar{border-radius:var(--swiper-scrollbar-border-radius,10px);position:relative;touch-action:none;background:var(--swiper-scrollbar-bg-color,rgba(0,0,0,.1))}.swiper-scrollbar-disabled>.swiper-scrollbar,.swiper-scrollbar.swiper-scrollbar-disabled{display:none!important}.swiper-horizontal>.swiper-scrollbar,.swiper-scrollbar.swiper-scrollbar-horizontal{position:absolute;left:var(--swiper-scrollbar-sides-offset,1%);bottom:var(--swiper-scrollbar-bottom,4px);top:var(--swiper-scrollbar-top,auto);z-index:50;height:var(--swiper-scrollbar-size,4px);width:calc(100% - 2 * var(--swiper-scrollbar-sides-offset,1%))}.swiper-scrollbar.swiper-scrollbar-vertical,.swiper-vertical>.swiper-scrollbar{position:absolute;left:var(--swiper-scrollbar-left,auto);right:var(--swiper-scrollbar-right,4px);top:var(--swiper-scrollbar-sides-offset,1%);z-index:50;width:var(--swiper-scrollbar-size,4px);height:calc(100% - 2 * var(--swiper-scrollbar-sides-offset,1%))}.swiper-scrollbar-drag{height:100%;width:100%;position:relative;background:var(--swiper-scrollbar-drag-bg-color,rgba(0,0,0,.5));border-radius:var(--swiper-scrollbar-border-radius,10px);left:0;top:0}.swiper-scrollbar-cursor-drag{cursor:move}.swiper-scrollbar-lock{display:none}::slotted(.swiper-slide-zoomed){cursor:move;touch-action:none}.swiper .swiper-notification{position:absolute;left:0;top:0;pointer-events:none;opacity:0;z-index:-1000}.swiper-free-mode>.swiper-wrapper{transition-timing-function:ease-out;margin:0 auto}.swiper-grid>.swiper-wrapper{flex-wrap:wrap}.swiper-grid-column>.swiper-wrapper{flex-wrap:wrap;flex-direction:column}.swiper-fade.swiper-free-mode ::slotted(swiper-slide){transition-timing-function:ease-out}.swiper-fade ::slotted(swiper-slide){pointer-events:none;transition-property:opacity}.swiper-fade ::slotted(swiper-slide) ::slotted(swiper-slide){pointer-events:none}.swiper-fade ::slotted(.swiper-slide-active){pointer-events:auto}.swiper-fade ::slotted(.swiper-slide-active) ::slotted(.swiper-slide-active){pointer-events:auto}.swiper-cube{overflow:visible}.swiper-cube ::slotted(swiper-slide){pointer-events:none;-webkit-backface-visibility:hidden;backface-visibility:hidden;z-index:1;visibility:hidden;transform-origin:0 0;width:100%;height:100%}.swiper-cube ::slotted(swiper-slide) ::slotted(swiper-slide){pointer-events:none}.swiper-cube.swiper-rtl ::slotted(swiper-slide){transform-origin:100% 0}.swiper-cube ::slotted(.swiper-slide-active),.swiper-cube ::slotted(.swiper-slide-active) ::slotted(.swiper-slide-active){pointer-events:auto}.swiper-cube ::slotted(.swiper-slide-active),.swiper-cube ::slotted(.swiper-slide-next),.swiper-cube ::slotted(.swiper-slide-prev){pointer-events:auto;visibility:visible}.swiper-cube .swiper-cube-shadow{position:absolute;left:0;bottom:0px;width:100%;height:100%;opacity:.6;z-index:0}.swiper-cube .swiper-cube-shadow:before{content:'';background:#000;position:absolute;left:0;top:0;bottom:0;right:0;filter:blur(50px)}.swiper-cube ::slotted(.swiper-slide-next)+::slotted(swiper-slide){pointer-events:auto;visibility:visible}.swiper-flip{overflow:visible}.swiper-flip ::slotted(swiper-slide){pointer-events:none;-webkit-backface-visibility:hidden;backface-visibility:hidden;z-index:1}.swiper-flip ::slotted(swiper-slide) ::slotted(swiper-slide){pointer-events:none}.swiper-flip ::slotted(.swiper-slide-active),.swiper-flip ::slotted(.swiper-slide-active) ::slotted(.swiper-slide-active){pointer-events:auto}.swiper-creative ::slotted(swiper-slide){-webkit-backface-visibility:hidden;backface-visibility:hidden;overflow:hidden;transition-property:transform,opacity,height}.swiper-cards{overflow:visible}.swiper-cards ::slotted(swiper-slide){transform-origin:center bottom;-webkit-backface-visibility:hidden;backface-visibility:hidden;overflow:hidden}", K0 = "::slotted(.swiper-slide-shadow),::slotted(.swiper-slide-shadow-bottom),::slotted(.swiper-slide-shadow-left),::slotted(.swiper-slide-shadow-right),::slotted(.swiper-slide-shadow-top){position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:10}::slotted(.swiper-slide-shadow){background:rgba(0,0,0,.15)}::slotted(.swiper-slide-shadow-left){background-image:linear-gradient(to left,rgba(0,0,0,.5),rgba(0,0,0,0))}::slotted(.swiper-slide-shadow-right){background-image:linear-gradient(to right,rgba(0,0,0,.5),rgba(0,0,0,0))}::slotted(.swiper-slide-shadow-top){background-image:linear-gradient(to top,rgba(0,0,0,.5),rgba(0,0,0,0))}::slotted(.swiper-slide-shadow-bottom){background-image:linear-gradient(to bottom,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-lazy-preloader{animation:swiper-preloader-spin 1s infinite linear;width:42px;height:42px;position:absolute;left:50%;top:50%;margin-left:-21px;margin-top:-21px;z-index:10;transform-origin:50%;box-sizing:border-box;border:4px solid var(--swiper-preloader-color,var(--swiper-theme-color));border-radius:50%;border-top-color:transparent}@keyframes swiper-preloader-spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}::slotted(.swiper-slide-shadow-cube.swiper-slide-shadow-bottom),::slotted(.swiper-slide-shadow-cube.swiper-slide-shadow-left),::slotted(.swiper-slide-shadow-cube.swiper-slide-shadow-right),::slotted(.swiper-slide-shadow-cube.swiper-slide-shadow-top){z-index:0;-webkit-backface-visibility:hidden;backface-visibility:hidden}::slotted(.swiper-slide-shadow-flip.swiper-slide-shadow-bottom),::slotted(.swiper-slide-shadow-flip.swiper-slide-shadow-left),::slotted(.swiper-slide-shadow-flip.swiper-slide-shadow-right),::slotted(.swiper-slide-shadow-flip.swiper-slide-shadow-top){z-index:0;-webkit-backface-visibility:hidden;backface-visibility:hidden}::slotted(.swiper-zoom-container){width:100%;height:100%;display:flex;justify-content:center;align-items:center;text-align:center}::slotted(.swiper-zoom-container)>canvas,::slotted(.swiper-zoom-container)>img,::slotted(.swiper-zoom-container)>svg{max-width:100%;max-height:100%;object-fit:contain}"; class Z0 { } const pp = typeof window > "u" || typeof HTMLElement > "u" ? Z0 : HTMLElement, wc = `<svg width="11" height="20" viewBox="0 0 11 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M0.38296 20.0762C0.111788 19.805 0.111788 19.3654 0.38296 19.0942L9.19758 10.2796L0.38296 1.46497C0.111788 1.19379 0.111788 0.754138 0.38296 0.482966C0.654131 0.211794 1.09379 0.211794 1.36496 0.482966L10.4341 9.55214C10.8359 9.9539 10.8359 10.6053 10.4341 11.007L1.36496 20.0762C1.09379 20.3474 0.654131 20.3474 0.38296 20.0762Z" fill="currentColor"/></svg>
    `, mp = (t, e) => { if (typeof CSSStyleSheet < "u" && t.adoptedStyleSheets) { const n = new CSSStyleSheet; n.replaceSync(e), t.adoptedStyleSheets = [n] } else { const n = document.createElement("style"); n.rel = "stylesheet", n.textContent = e, t.appendChild(n) } }; class hp extends pp {
  constructor() { super(), this.attachShadow({ mode: "open" }) } static get nextButtonSvg() { return wc } static get prevButtonSvg() { return wc.replace("/></svg>", ' transform-origin="center" transform="rotate(180)"/></svg>') } cssStyles() {
    return [Q0, ...this.injectStyles && Array.isArray(this.injectStyles) ? this.injectStyles : []].join(`
`)
  } cssLinks() { return this.injectStylesUrls || [] } calcSlideSlots() { const e = this.slideSlots || 0, n = [...this.querySelectorAll("[slot^=slide-]")].map(r => parseInt(r.getAttribute("slot").split("slide-")[1], 10)); if (this.slideSlots = n.length ? Math.max(...n) + 1 : 0, !!this.rendered) { if (this.slideSlots > e) for (let r = e; r < this.slideSlots; r += 1) { const i = document.createElement("swiper-slide"); i.setAttribute("part", `slide slide-${r + 1}`); const s = document.createElement("slot"); s.setAttribute("name", `slide-${r + 1}`), i.appendChild(s), this.shadowRoot.querySelector(".swiper-wrapper").appendChild(i) } else if (this.slideSlots < e) { const r = this.swiper.slides; for (let i = r.length - 1; i >= 0; i -= 1)i > this.slideSlots && r[i].remove() } } } render() {
    if (this.rendered) return; this.calcSlideSlots(); let e = this.cssStyles(); this.slideSlots > 0 && (e = e.replace(/::slotted\(([a-z-0-9.]*)\)/g, "$1")), e.length && mp(this.shadowRoot, e), this.cssLinks().forEach(r => { if (this.shadowRoot.querySelector(`link[href="${r}"]`)) return; const s = document.createElement("link"); s.rel = "stylesheet", s.href = r, this.shadowRoot.appendChild(s) }); const n = document.createElement("div"); n.classList.add("swiper"), n.part = "container", n.innerHTML = `
      <slot name="container-start"></slot>
      <div class="swiper-wrapper" part="wrapper">
        <slot></slot>
        ${Array.from({ length: this.slideSlots }).map((r, i) => `
        <swiper-slide part="slide slide-${i}">
          <slot name="slide-${i}"></slot>
        </swiper-slide>
        `).join("")}
      </div>
      <slot name="container-end"></slot>
      ${X0(this.passedParams) ? `
        <div part="button-prev" class="swiper-button-prev">${this.constructor.prevButtonSvg}</div>
        <div part="button-next" class="swiper-button-next">${this.constructor.nextButtonSvg}</div>
      `: ""}
      ${U0(this.passedParams) ? `
        <div part="pagination" class="swiper-pagination"></div>
      `: ""}
      ${Y0(this.passedParams) ? `
        <div part="scrollbar" class="swiper-scrollbar"></div>
      `: ""}
    `, this.shadowRoot.appendChild(n), this.rendered = !0
  } initialize() { var e = this; if (this.initialized) return; this.initialized = !0; const { params: n, passedParams: r } = vc(this); this.swiperParams = n, this.passedParams = r, delete this.swiperParams.init, this.render(), this.swiper = new $e(this.shadowRoot.querySelector(".swiper"), { ...n.virtual ? {} : { observer: !0, observeSlideChildren: this.slideSlots > 0 }, ...n, touchEventsTarget: "container", onAny: function (i) { i === "observerUpdate" && e.calcSlideSlots(); const s = n.eventsPrefix ? `${n.eventsPrefix}${i.toLowerCase()}` : i.toLowerCase(); for (var l = arguments.length, o = new Array(l > 1 ? l - 1 : 0), a = 1; a < l; a++)o[a - 1] = arguments[a]; const u = new CustomEvent(s, { detail: o, bubbles: i !== "hashChange", cancelable: !0 }); e.dispatchEvent(u) } }) } connectedCallback() { this.initialized && this.nested && this.closest("swiper-slide") && this.closest("swiper-slide").swiperLoopMoveDOM || this.init === !1 || this.getAttribute("init") === "false" || this.initialize() } disconnectedCallback() { this.nested && this.closest("swiper-slide") && this.closest("swiper-slide").swiperLoopMoveDOM || (this.swiper && this.swiper.destroy && this.swiper.destroy(), this.initialized = !1) } updateSwiperOnPropChange(e, n) { const { params: r, passedParams: i } = vc(this, e, n); this.passedParams = i, this.swiperParams = r, !(this.swiper && this.swiper.params[e] === n) && q0({ swiper: this.swiper, passedParams: this.passedParams, changedParams: [Ii(e)], ...e === "navigation" && i[e] ? { prevEl: ".swiper-button-prev", nextEl: ".swiper-button-next" } : {}, ...e === "pagination" && i[e] ? { paginationEl: ".swiper-pagination" } : {}, ...e === "scrollbar" && i[e] ? { scrollbarEl: ".swiper-scrollbar" } : {} }) } attributeChangedCallback(e, n, r) { this.initialized && (n === "true" && r === null && (r = !1), this.updateSwiperOnPropChange(e, r)) } static get observedAttributes() { return Os.filter(n => n.includes("_")).map(n => n.replace(/[A-Z]/g, r => `-${r}`).replace("_", "").toLowerCase()) }
} Os.forEach(t => { t !== "init" && (t = t.replace("_", ""), Object.defineProperty(hp.prototype, t, { configurable: !0, get() { return (this.passedParams || {})[t] }, set(e) { this.passedParams || (this.passedParams = {}), this.passedParams[t] = e, this.initialized && this.updateSwiperOnPropChange(t, e) } })) }); class J0 extends pp { constructor() { super(), this.attachShadow({ mode: "open" }) } render() { const e = this.lazy || this.getAttribute("lazy") === "" || this.getAttribute("lazy") === "true"; if (mp(this.shadowRoot, K0), this.shadowRoot.appendChild(document.createElement("slot")), e) { const n = document.createElement("div"); n.classList.add("swiper-lazy-preloader"), n.part.add("preloader"), this.shadowRoot.appendChild(n) } } initialize() { this.render() } connectedCallback() { this.initialize() } } const ew = () => { typeof window > "u" || (window.customElements.get("swiper-container") || window.customElements.define("swiper-container", hp), window.customElements.get("swiper-slide") || window.customElements.define("swiper-slide", J0)) }; typeof window < "u" && (window.SwiperElementRegisterParams = t => { Os.push(...t) }); ew(); const tw = [{ id: 1, name: " ,  ", description: ":  ,  <br />  : 17    ", img: "./face1.jpeg" }, { id: 2, name: " ,  ", description: ": ,   <br />  : 9 ", img: "./face2.jpg" }, { id: 3, name: " , ", description: ": , :  <br/>: 6 ", img: "./face3.jpg" }]; function nw() { return A.jsxs("section", { className: "team", id: "team", children: [A.jsx("h2", { className: "title", children: " " }), A.jsxs("div", { className: "swiper-wrapper", children: [A.jsx("swiper-container", { spaceBetween: 50, slidesPerView: 1, navigation: "true", "navigation-next-el": ".button-next", "navigation-prev-el": ".button-prev", onSlideChange: () => console.log("slide change"), onSwiper: t => console.log(t), children: tw.map(t => A.jsxs("swiper-slide", { children: [A.jsx("div", { className: "avatar", children: A.jsx("img", { src: t.img, alt: "avatar" }) }), A.jsx("p", { className: "name", children: t.name }), A.jsx("p", { className: "description", children: lp(t.description) })] }, t.id)) }), A.jsxs("div", { className: "slider-navigation", children: [A.jsx("button", { className: "button-prev ", children: A.jsx("img", { src: "arrow.svg", alt: "" }) }), A.jsx("button", { className: "button-next", children: A.jsx("img", { src: "arrow.svg", alt: "" }) })] })] })] }) } function Te() { return Te = Object.assign ? Object.assign.bind() : function (t) { for (var e = 1; e < arguments.length; e++) { var n = arguments[e]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]) } return t }, Te.apply(this, arguments) } function Yr(t, e) { if (t == null) return {}; var n = {}, r = Object.keys(t), i, s; for (s = 0; s < r.length; s++)i = r[s], !(e.indexOf(i) >= 0) && (n[i] = t[i]); return n } const xa = 0, Ta = 1, ls = 2, as = 3, os = 4, rw = 5, gp = 6, iw = ["preEnter", "entering", "entered", "preExit", "exiting", "exited", "unmounted"], sw = t => ({ _s: t, status: iw[t], isEnter: t < as, isMounted: t !== gp, isResolved: t === ls || t > os }), ba = t => t ? gp : rw, lw = (t, e) => { switch (t) { case Ta: case xa: return ls; case os: case as: return ba(e) } }, aw = t => typeof t == "object" ? [t.enter, t.exit] : [t, t], ow = (t, e) => setTimeout(() => { isNaN(document.body.offsetTop) || t(e + 1) }, 0), uw = new Map, cw = new Map, yl = (t, e, n, r, i, s) => { clearTimeout(i); const l = sw(e), o = new Map(r.current); o.set(t, l), n(o), r.current = o, s && s({ key: t, current: l }) }, dw = ({ allowMultiple: t, enter: e = !0, exit: n = !0, preEnter: r, preExit: i, timeout: s, initialEntered: l, mountOnEnter: o, unmountOnExit: a, onStateChange: u } = {}) => { const [c, d] = Y.useState(uw), f = Y.useRef(c), v = Y.useRef(cw), [g, w] = aw(s), y = Y.useCallback((x, T) => { const { initialEntered: L = l } = T || {}, b = L ? ls : ba(o); yl(x, b, d, f), v.current.set(x, {}) }, [l, o]), p = Y.useCallback(x => { const T = new Map(f.current); return T.delete(x) ? (d(T), f.current = T, v.current.delete(x), !0) : !1 }, []), m = Y.useCallback(x => { const T = f.current.get(x); if (!T) return; const { timeoutId: L } = v.current.get(x), b = lw(T._s, a); b && yl(x, b, d, f, L, u) }, [u, a]), h = Y.useCallback((x, T) => { const L = f.current.get(x); if (!L) return; const b = v.current.get(x), C = N => { switch (yl(x, N, d, f, b.timeoutId, u), N) { case Ta: g >= 0 && (b.timeoutId = setTimeout(() => m(x), g)); break; case os: w >= 0 && (b.timeoutId = setTimeout(() => m(x), w)); break; case xa: case as: b.timeoutId = ow(C, N); break } }, P = L.isEnter; typeof T != "boolean" && (T = !P), T ? P || (C(e ? r ? xa : Ta : ls), !t && f.current.forEach((N, M) => M !== x && h(M, !1))) : P && C(n ? i ? as : os : ba(a)) }, [u, m, t, e, n, r, i, g, w, a]), S = Y.useCallback(x => { if (!(!t && x !== !1)) for (const T of f.current.keys()) h(T, x) }, [t, h]); return { stateMap: c, toggle: h, toggleAll: S, endTransition: m, setItem: y, deleteItem: p } }, fw = ["transition", "transitionTimeout"], wi = (t, e) => t === !0 || !!(t && t[e]), pw = (t = {}) => { let { transition: e, transitionTimeout: n } = t, r = Yr(t, fw); const i = dw(Te({ timeout: n, enter: wi(e, "enter"), exit: wi(e, "exit"), preEnter: wi(e, "preEnter"), preExit: wi(e, "preExit") }, r)); return Te({ mountOnEnter: !!r.mountOnEnter, initialEntered: !!r.initialEntered }, i) }, hn = "szh-accordion", Do = "szh-adn", vp = `data-${Do}`, Ca = `data-${Do}-btn`, wp = Y.createContext({}), gn = (t, e, n) => (r, i) => { const s = e ? `${t}__${e}` : t; let l = s; n && Object.keys(n).forEach(a => { const u = n[a]; u && (l += ` ${s}--${u === !0 ? a : `${a}-${u}`}`) }); let o = typeof r == "function" ? r(i) : r; return typeof o == "string" && (o = o.trim(), o && (l += ` ${o}`)), l }, Pa = (t, e) => { if (!e) return t; const n = Te({}, t); return Object.keys(e).forEach(r => { const i = t[r], s = e[r]; typeof s == "function" && i ? n[r] = (...l) => { i(...l), s(...l) } : n[r] = s }), n }, mw = t => A.jsx(wp.Provider, Te({}, t)), Sl = t => { do t = t.parentElement; while (t && !t.hasAttribute(vp)); return t }, yc = (t, e, n) => t ? e > 0 ? e - 1 : n - 1 : (e + 1) % n, Sc = (t, e) => { const { activeElement: n } = document; if (!n || !n.hasAttribute(Ca) || Sl(n) !== e.currentTarget) return; const r = e.currentTarget.querySelectorAll(`[${Ca}]`), { length: i } = r; for (let s = 0; s < i; s++)if (r[s] === n) { let l = yc(t, s, i); for (; Sl(r[s]) !== Sl(r[l]);)l = yc(t, l, i); s !== l && (e.preventDefault(), r[l].focus()); break } }, hw = () => ({ accordionProps: { [vp]: "", onKeyDown: e => e.key === "ArrowUp" ? Sc(!0, e) : e.key === "ArrowDown" && Sc(!1, e) } }), gw = ["providerValue", "className"], yp = Y.forwardRef((t, e) => { let { providerValue: n, className: r } = t, i = Yr(t, gw); const { accordionProps: s } = hw(); return A.jsx(mw, { value: n, children: A.jsx("div", Te({}, Pa(s, i), { ref: e, className: gn(hn)(r) })) }) }); yp.displayName = "ControlledAccordion"; const vw = ["allowMultiple", "initialEntered", "mountOnEnter", "unmountOnExit", "transition", "transitionTimeout", "onStateChange"], Sp = Y.forwardRef((t, e) => { let { allowMultiple: n, initialEntered: r, mountOnEnter: i, unmountOnExit: s, transition: l, transitionTimeout: o, onStateChange: a } = t, u = Yr(t, vw); const c = pw({ allowMultiple: n, initialEntered: r, mountOnEnter: i, unmountOnExit: s, transition: l, transitionTimeout: o, onStateChange: a }); return A.jsx(yp, Te({}, u, { ref: e, providerValue: c })) }); Sp.displayName = "Accordion"; let ww = 0; const yw = () => { const [t, e] = Y.useState(); return Y.useEffect(() => e(++ww), []), t && `${Do}-${t}` }, Sw = Nc.useId || yw, Ew = ({ state: t, toggle: e, disabled: n }) => { const r = Sw(), i = r && r + "-", s = { id: r, "aria-controls": i, "aria-expanded": t.isEnter, onClick: e }; return n ? s.disabled = !0 : s[Ca] = "", { buttonProps: s, panelProps: { id: i, "aria-labelledby": r, role: "region" } } }, xw = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? Y.useLayoutEffect : Y.useEffect, Tw = ({ status: t, isResolved: e }) => { const [n, r] = Y.useState(), i = Y.useRef(null); return xw(() => { (t === "preEnter" || t === "preExit") && r(i.current.getBoundingClientRect().height) }, [t]), [{ height: t === "preEnter" || t === "exiting" ? 0 : t === "entering" || t === "preExit" ? n : void 0, overflow: e ? void 0 : "hidden" }, i] }; function Ec(t, e) { typeof t == "function" ? t(e) : t.current = e } function xc(t, e) { return Y.useMemo(() => t ? e ? n => { Ec(t, n), Ec(e, n) } : t : e, [t, e]) } const bw = (t, e, n) => { const { stateMap: r, mountOnEnter: i, initialEntered: s } = t, l = n ?? s; return r.get(e) || { status: l ? "entered" : i ? "unmounted" : "exited", isMounted: !i, isEnter: l, isResolved: !0 } }, Cw = () => Y.useContext(wp), Pw = ({ itemKey: t, initialEntered: e, disabled: n } = {}) => { const r = Y.useRef(null), i = Cw(), s = t ?? r.current, l = bw(i, s, e), { setItem: o, deleteItem: a, toggle: u } = i; return Y.useEffect(() => { if (n) return; const c = t ?? r.current; return o(c, { initialEntered: e }), () => void a(c) }, [o, a, t, e, n]), { itemRef: r, state: l, toggle: Y.useCallback(c => u(s, c), [u, s]) } }, kw = ["itemKey", "initialEntered"], Mw = t => { const e = Y.forwardRef((n, r) => { let { itemKey: i, initialEntered: s } = n, l = Yr(n, kw); return A.jsx(t, Te({ forwardedRef: r }, l, Pw({ itemKey: i, initialEntered: s, disabled: l.disabled }))) }); return e.displayName = "WithAccordionItem", e }, _w = ["forwardedRef", "itemRef", "state", "toggle", "className", "disabled", "header", "headingTag", "headingProps", "buttonProps", "contentProps", "panelProps", "children"], Tc = (t, e) => typeof t == "function" ? t(e) : t, Ep = Y.memo(t => { let { forwardedRef: e, itemRef: n, state: r, toggle: i, className: s, disabled: l, header: o, headingTag: a = "h3", headingProps: u, buttonProps: c, contentProps: d, panelProps: f, children: v } = t, g = Yr(t, _w); const w = { state: r, toggle: i, disabled: l }, { buttonProps: y, panelProps: p } = Ew(w), [m, h] = Tw(r), S = xc(f && f.ref, h), { status: x, isMounted: T, isEnter: L } = r; return A.jsxs("div", Te({}, g, { ref: xc(e, n), className: gn(hn, "item", { status: x, expanded: L })(s, r), children: [A.jsx(a, Te({}, u, { style: Te({ margin: 0 }, u && u.style), className: gn(hn, "item-heading")(u && u.className, r), children: A.jsx("button", Te({}, Pa(y, c), { type: "button", className: gn(hn, "item-btn")(c && c.className, r), children: Tc(o, w) })) })), T && A.jsx("div", Te({}, d, { style: Te({ display: x === "exited" ? "none" : void 0 }, m, d && d.style), className: gn(hn, "item-content")(d && d.className, r), children: A.jsx("div", Te({}, Pa(p, f), { ref: S, className: gn(hn, "item-panel")(f && f.className, r), children: Tc(v, w) })) }))] })) }); Ep.displayName = "AccordionItem"; const Lw = Mw(Ep), zw = "_item_100l0_1", Iw = "_accordion_100l0_7", Ow = "_itemBtn_100l0_19", Nw = "_itemContent_100l0_73", Aw = "_itemPanel_100l0_81", Dw = "_chevron_100l0_99", Rw = "_itemBtnExpanded_100l0_109", Qt = { item: zw, accordion: Iw, itemBtn: Ow, itemContent: Nw, itemPanel: Aw, chevron: Dw, itemBtnExpanded: Rw }, $w = [{ header: "  ", content: "       , ,     .            ." }, { header: "  ", content: "    ,           .     ." }, { header: " ", content: "       ,      " }, { header: " ", content: "<ul><li>  </li><li>   </li><li>    </li></ul>" }], jw = ({ header: t, ...e }) => A.jsx(Lw, { ...e, header: A.jsxs(A.Fragment, { children: [t, A.jsx("img", { className: Qt.chevron, src: "acc-arrow.svg", alt: "Chevron Down" })] }), className: Qt.item, buttonProps: { className: ({ isEnter: n }) => `${Qt.itemBtn} ${n && Qt.itemBtnExpanded}` }, contentProps: { className: Qt.itemContent }, panelProps: { className: Qt.itemPanel } }); function Fw() { return A.jsxs("section", { className: "services", id: "services", children: [A.jsx("h2", { className: "title", children: ",   " }), A.jsx(Sp, { allowMultiple: !0, transition: !0, transitionTimeout: 250, className: Qt.accordion, children: $w.map(({ header: t, content: e }, n) => A.jsx(jw, { header: t, children: lp(e) }, n)) })] }) } var Hw = function (t) { return t.value.replace(/\D/g, "") }, Bw = function (t) { var e = t.target, n = Hw(e), r = e.selectionStart, i = ""; if (!n) return ""; if (e.value.length != r) return t.data && /\D/g.test(t.data) ? n : void 0; if (["7", "8", "9"].indexOf(n[0]) > -1) { n[0] == "9" && (n = "7" + n); var s = n[0] == "8" ? "8" : "+7"; i = e.value = s + " ", n.length > 1 && (i += "(" + n.substring(1, 4)), n.length >= 5 && (i += ") " + n.substring(4, 7)), n.length >= 8 && (i += "-" + n.substring(7, 9)), n.length >= 10 && (i += "-" + n.substring(9, 11)) } else i = "+" + n.substring(0, 16); return i }; function Vw() { const [t, e] = Y.useState(""); function n(i) { e(Bw(i)) } function r(i) { var s = i.target.value.replace(/\D/g, ""); i.keyCode == 8 && s.length == 1 && e("") } return A.jsxs(A.Fragment, { children: [A.jsxs("section", { className: "contacts", id: "contacts", children: [A.jsx("h2", { className: "title", children: "   ?" }), A.jsxs("div", { className: "content", children: [A.jsxs("ul", { className: "info", children: [A.jsxs("li", { children: [A.jsx("span", { className: "bold", children: " : " }), A.jsx("p", { children: ". , . , .5" })] }), A.jsxs("li", { children: [A.jsx("span", { className: "bold", children: " : " }), A.jsx("span", { children: "- 9:00-18:00" })] }), A.jsxs("li", { children: [A.jsx("span", { className: "bold", children: ": " }), A.jsx("a", { href: "tel:+74951234567", children: "+7 (495) 123-45-67" })] }), A.jsxs("li", { children: [A.jsx("span", { className: "bold", children: "Email:" }), A.jsx("a", { href: "mailto:info@fin-spas.ru", children: "info@fin-spas.ru" })] }), A.jsxs("li", { className: "socials", children: [A.jsx("a", { href: "https://www.whatsapp.com/", children: A.jsx("img", { src: "bxl-whatsapp.svg", alt: "" }) }), A.jsx("a", { href: "https://telegram.org/", children: A.jsx("img", { src: "bxl-telegram.svg", alt: "" }) })] })] }), A.jsxs("form", { action: "", children: [A.jsx("p", { className: "form-title", children: "  ,         !" }), A.jsx("input", { type: "tel", "data-tel-input": !0, placeholder: "8 (800) 555-35-35 ", maxLength: "18", value: t, onChange: n, onKeyDown: r }), A.jsx("button", { type: "submit", className: "btn", children: " " })] })] })] }), A.jsxs("footer", { children: [A.jsx("iframe", { src: "https://yandex.ru/map-widget/v1/?um=constructor%3A12e9e17d30fd16b37016e9102a292dfd87d514284ff5d84e69cd686867e8e41b&source=constructor", width: "100%", height: "550", frameBorder: "0" }), A.jsx("div", { className: "hr" }), A.jsx("p", { className: "copyright", children: "  2024" })] })] }) } function Gw() { return A.jsxs(A.Fragment, { children: [A.jsx(Qh, {}), A.jsx(Uh, {}), A.jsx(nw, {}), A.jsx(Fw, {}), A.jsx(Vw, {})] }) } El.createRoot(document.getElementById("root")).render(A.jsx(Nc.StrictMode, { children: A.jsx(Gw, {}) }));
